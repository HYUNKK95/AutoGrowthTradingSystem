# âš ï¸ Phase 6.1: ìœ„í—˜ ê´€ë¦¬ ì‹œìŠ¤í…œ

## ğŸ“‹ **ê°œìš”**

### ğŸ¯ **ëª©í‘œ**
- **ì‹¤ì‹œê°„ ìœ„í—˜ í‰ê°€**: í¬íŠ¸í´ë¦¬ì˜¤, ê±°ë˜, ì‹œì¥ ìœ„í—˜ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§
- **ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸**: ë‹¤ì–‘í•œ ì‹œë‚˜ë¦¬ì˜¤ ê¸°ë°˜ ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸
- **ìë³¸ ì¶©ë¶„ì„±**: Basel III ê·œì • ì¤€ìˆ˜, ìë³¸ ë¹„ìœ¨ ëª¨ë‹ˆí„°ë§
- **ìœ ë™ì„± ê´€ë¦¬**: ì‹¤ì‹œê°„ ìœ ë™ì„± ëª¨ë‹ˆí„°ë§, ìœ ë™ì„± ìœ„í—˜ ê´€ë¦¬
- **VaR ê³„ì‚°**: Value at Risk ì‹¤ì‹œê°„ ê³„ì‚° ë° ëª¨ë‹ˆí„°ë§

### ğŸ“Š **ì„±ëŠ¥ ëª©í‘œ**
- **ìœ„í—˜ í‰ê°€ ì§€ì—°**: < 100ms ì‹¤ì‹œê°„ ìœ„í—˜ í‰ê°€
- **ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸**: < 5ë¶„ ì™„ë£Œ, ë‹¤ì–‘í•œ ì‹œë‚˜ë¦¬ì˜¤ ì§€ì›
- **VaR ê³„ì‚°**: < 1ì´ˆ ì™„ë£Œ, 99% ì‹ ë¢°ìˆ˜ì¤€
- **ìë³¸ ë¹„ìœ¨**: ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§, ì„ê³„ê°’ ì•Œë¦¼
- **ìœ ë™ì„± ê´€ë¦¬**: ì‹¤ì‹œê°„ ìœ ë™ì„± ì§€í‘œ, ìœ„í—˜ ì•Œë¦¼

## ğŸ—ï¸ **ìœ„í—˜ ê´€ë¦¬ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜**

### ğŸ“ **ìœ„í—˜ ê´€ë¦¬ ì‹œìŠ¤í…œ êµ¬ì¡°**
```
risk-management/
â”œâ”€â”€ real-time-risk/                     # ì‹¤ì‹œê°„ ìœ„í—˜ í‰ê°€
â”‚   â”œâ”€â”€ portfolio-risk/                 # í¬íŠ¸í´ë¦¬ì˜¤ ìœ„í—˜
â”‚   â”œâ”€â”€ market-risk/                    # ì‹œì¥ ìœ„í—˜
â”‚   â”œâ”€â”€ credit-risk/                    # ì‹ ìš© ìœ„í—˜
â”‚   â””â”€â”€ operational-risk/               # ìš´ì˜ ìœ„í—˜
â”œâ”€â”€ stress-testing/                     # ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸
â”‚   â”œâ”€â”€ scenario-generation/            # ì‹œë‚˜ë¦¬ì˜¤ ìƒì„±
â”‚   â”œâ”€â”€ stress-models/                  # ìŠ¤íŠ¸ë ˆìŠ¤ ëª¨ë¸
â”‚   â”œâ”€â”€ impact-analysis/                # ì˜í–¥ ë¶„ì„
â”‚   â””â”€â”€ reporting/                      # ë³´ê³ ì„œ ìƒì„±
â”œâ”€â”€ capital-adequacy/                   # ìë³¸ ì¶©ë¶„ì„±
â”‚   â”œâ”€â”€ basel-iii/                      # Basel III ê·œì •
â”‚   â”œâ”€â”€ capital-ratios/                 # ìë³¸ ë¹„ìœ¨
â”‚   â”œâ”€â”€ risk-weighted-assets/           # ìœ„í—˜ ê°€ì¤‘ ìì‚°
â”‚   â””â”€â”€ regulatory-reporting/           # ê·œì œ ë³´ê³ 
â”œâ”€â”€ liquidity-management/               # ìœ ë™ì„± ê´€ë¦¬
â”‚   â”œâ”€â”€ liquidity-monitoring/           # ìœ ë™ì„± ëª¨ë‹ˆí„°ë§
â”‚   â”œâ”€â”€ liquidity-ratios/               # ìœ ë™ì„± ë¹„ìœ¨
â”‚   â”œâ”€â”€ funding-risk/                   # ìê¸ˆ ì¡°ë‹¬ ìœ„í—˜
â”‚   â””â”€â”€ contingency-planning/           # ë¹„ìƒ ê³„íš
â””â”€â”€ var-calculations/                   # VaR ê³„ì‚°
    â”œâ”€â”€ historical-var/                 # ì—­ì‚¬ì  VaR
    â”œâ”€â”€ parametric-var/                 # ëª¨ìˆ˜ì  VaR
    â”œâ”€â”€ monte-carlo-var/                # ëª¬í…Œì¹´ë¥¼ë¡œ VaR
    â””â”€â”€ backtesting/                    # ë°±í…ŒìŠ¤íŒ…
```

## ğŸ”§ **ì‹¤ì‹œê°„ ìœ„í—˜ í‰ê°€ ì‹œìŠ¤í…œ**

### ğŸ“¦ **í¬íŠ¸í´ë¦¬ì˜¤ ìœ„í—˜ ê´€ë¦¬**

```python
# risk-management/real-time-risk/portfolio_risk_manager.py
import asyncio
import time
import logging
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass
from datetime import datetime, timedelta
import numpy as np
import pandas as pd
from scipy import stats
from scipy.optimize import minimize
import threading
from collections import defaultdict, deque

logger = logging.getLogger(__name__)

@dataclass
class Position:
    """í¬ì§€ì…˜ ì •ë³´"""
    symbol: str
    quantity: float
    entry_price: float
    current_price: float
    unrealized_pnl: float
    market_value: float
    timestamp: datetime

@dataclass
class PortfolioRisk:
    """í¬íŠ¸í´ë¦¬ì˜¤ ìœ„í—˜ ì •ë³´"""
    total_value: float
    total_pnl: float
    var_95: float
    var_99: float
    expected_shortfall: float
    sharpe_ratio: float
    max_drawdown: float
    beta: float
    volatility: float
    correlation_matrix: np.ndarray
    concentration_risk: float
    sector_exposure: Dict[str, float]
    timestamp: datetime

@dataclass
class RiskLimit:
    """ìœ„í—˜ í•œë„"""
    limit_type: str  # 'var', 'concentration', 'drawdown', 'leverage'
    threshold: float
    current_value: float
    breach_percentage: float
    status: str  # 'normal', 'warning', 'breach'

class PortfolioRiskManager:
    """í¬íŠ¸í´ë¦¬ì˜¤ ìœ„í—˜ ê´€ë¦¬ì"""
    
    def __init__(self):
        self.positions = {}
        self.price_history = defaultdict(lambda: deque(maxlen=252))  # 1ë…„ ë°ì´í„°
        self.risk_limits = self._initialize_risk_limits()
        self.correlation_matrix = None
        self.volatility_cache = {}
        self.var_cache = {}
        
        # ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
        self.metrics = RiskMetrics()
        
        # ìŠ¤ë ˆë“œ ì•ˆì „
        self.lock = threading.Lock()
        
        # ë°±ê·¸ë¼ìš´ë“œ ì—…ë°ì´íŠ¸
        self.update_thread = None
        self.running = False
        
        logger.info("Portfolio risk manager initialized")
    
    async def start_monitoring(self):
        """ìœ„í—˜ ëª¨ë‹ˆí„°ë§ ì‹œì‘"""
        self.running = True
        self.update_thread = threading.Thread(target=self._monitoring_loop)
        self.update_thread.start()
        logger.info("Portfolio risk monitoring started")
    
    async def stop_monitoring(self):
        """ìœ„í—˜ ëª¨ë‹ˆí„°ë§ ì¤‘ì§€"""
        self.running = False
        if self.update_thread:
            self.update_thread.join()
        logger.info("Portfolio risk monitoring stopped")
    
    def update_position(self, symbol: str, quantity: float, price: float):
        """í¬ì§€ì…˜ ì—…ë°ì´íŠ¸"""
        with self.lock:
            if symbol in self.positions:
                # ê¸°ì¡´ í¬ì§€ì…˜ ì—…ë°ì´íŠ¸
                position = self.positions[symbol]
                position.quantity = quantity
                position.current_price = price
                position.unrealized_pnl = (price - position.entry_price) * quantity
                position.market_value = quantity * price
                position.timestamp = datetime.now()
            else:
                # ìƒˆ í¬ì§€ì…˜ ìƒì„±
                position = Position(
                    symbol=symbol,
                    quantity=quantity,
                    entry_price=price,
                    current_price=price,
                    unrealized_pnl=0.0,
                    market_value=quantity * price,
                    timestamp=datetime.now()
                )
                self.positions[symbol] = position
            
            # ê°€ê²© íˆìŠ¤í† ë¦¬ ì—…ë°ì´íŠ¸
            self.price_history[symbol].append(price)
            
            # ìºì‹œ ë¬´íš¨í™”
            self._invalidate_cache(symbol)
    
    def calculate_portfolio_risk(self) -> PortfolioRisk:
        """í¬íŠ¸í´ë¦¬ì˜¤ ìœ„í—˜ ê³„ì‚°"""
        with self.lock:
            start_time = time.time()
            
            if not self.positions:
                return self._empty_portfolio_risk()
            
            # ê¸°ë³¸ ì •ë³´ ê³„ì‚°
            total_value = sum(pos.market_value for pos in self.positions.values())
            total_pnl = sum(pos.unrealized_pnl for pos in self.positions.values())
            
            # ìˆ˜ìµë¥  ê³„ì‚°
            returns = self._calculate_returns()
            
            # ìœ„í—˜ ì§€í‘œ ê³„ì‚°
            var_95 = self._calculate_var(returns, confidence_level=0.95)
            var_99 = self._calculate_var(returns, confidence_level=0.99)
            expected_shortfall = self._calculate_expected_shortfall(returns, confidence_level=0.95)
            sharpe_ratio = self._calculate_sharpe_ratio(returns)
            max_drawdown = self._calculate_max_drawdown(returns)
            beta = self._calculate_beta(returns)
            volatility = self._calculate_volatility(returns)
            
            # ìƒê´€ê´€ê³„ í–‰ë ¬ ê³„ì‚°
            correlation_matrix = self._calculate_correlation_matrix()
            
            # ì§‘ì¤‘ë„ ìœ„í—˜ ê³„ì‚°
            concentration_risk = self._calculate_concentration_risk()
            
            # ì„¹í„° ë…¸ì¶œë„ ê³„ì‚°
            sector_exposure = self._calculate_sector_exposure()
            
            # ì„±ëŠ¥ ì¸¡ì •
            calculation_time = (time.time() - start_time) * 1000
            self.metrics.record_calculation_time(calculation_time)
            
            return PortfolioRisk(
                total_value=total_value,
                total_pnl=total_pnl,
                var_95=var_95,
                var_99=var_99,
                expected_shortfall=expected_shortfall,
                sharpe_ratio=sharpe_ratio,
                max_drawdown=max_drawdown,
                beta=beta,
                volatility=volatility,
                correlation_matrix=correlation_matrix,
                concentration_risk=concentration_risk,
                sector_exposure=sector_exposure,
                timestamp=datetime.now()
            )
    
    def _calculate_returns(self) -> np.ndarray:
        """ìˆ˜ìµë¥  ê³„ì‚°"""
        if not self.positions:
            return np.array([])
        
        # í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¹˜ ì‹œê³„ì—´ ê³„ì‚°
        portfolio_values = []
        symbols = list(self.positions.keys())
        
        # ìµœì†Œ ê¸¸ì´ ì°¾ê¸°
        min_length = min(len(self.price_history[symbol]) for symbol in symbols)
        
        for i in range(min_length):
            portfolio_value = 0
            for symbol in symbols:
                if i < len(self.price_history[symbol]):
                    price = list(self.price_history[symbol])[i]
                    position = self.positions[symbol]
                    portfolio_value += position.quantity * price
            portfolio_values.append(portfolio_value)
        
        # ìˆ˜ìµë¥  ê³„ì‚°
        portfolio_values = np.array(portfolio_values)
        returns = np.diff(portfolio_values) / portfolio_values[:-1]
        
        return returns
    
    def _calculate_var(self, returns: np.ndarray, confidence_level: float = 0.95) -> float:
        """Value at Risk ê³„ì‚°"""
        if len(returns) == 0:
            return 0.0
        
        # ìºì‹œ í™•ì¸
        cache_key = f"var_{confidence_level}_{hash(tuple(returns[-50:]))}"
        if cache_key in self.var_cache:
            return self.var_cache[cache_key]
        
        # VaR ê³„ì‚° (ì—­ì‚¬ì  ì‹œë®¬ë ˆì´ì…˜)
        var = np.percentile(returns, (1 - confidence_level) * 100)
        
        # ìºì‹œ ì €ì¥
        self.var_cache[cache_key] = var
        
        return var
    
    def _calculate_expected_shortfall(self, returns: np.ndarray, confidence_level: float = 0.95) -> float:
        """Expected Shortfall (Conditional VaR) ê³„ì‚°"""
        if len(returns) == 0:
            return 0.0
        
        var = self._calculate_var(returns, confidence_level)
        tail_returns = returns[returns <= var]
        
        if len(tail_returns) == 0:
            return var
        
        return np.mean(tail_returns)
    
    def _calculate_sharpe_ratio(self, returns: np.ndarray) -> float:
        """ìƒ¤í”„ ë¹„ìœ¨ ê³„ì‚°"""
        if len(returns) == 0:
            return 0.0
        
        mean_return = np.mean(returns)
        std_return = np.std(returns)
        
        if std_return == 0:
            return 0.0
        
        # ë¬´ìœ„í—˜ ìˆ˜ìµë¥  (ì˜ˆ: 2%)
        risk_free_rate = 0.02 / 252  # ì¼ê°„ ë¬´ìœ„í—˜ ìˆ˜ìµë¥ 
        
        return (mean_return - risk_free_rate) / std_return
    
    def _calculate_max_drawdown(self, returns: np.ndarray) -> float:
        """ìµœëŒ€ ë‚™í­ ê³„ì‚°"""
        if len(returns) == 0:
            return 0.0
        
        cumulative_returns = np.cumprod(1 + returns)
        running_max = np.maximum.accumulate(cumulative_returns)
        drawdown = (cumulative_returns - running_max) / running_max
        
        return np.min(drawdown)
    
    def _calculate_beta(self, returns: np.ndarray) -> float:
        """ë² íƒ€ ê³„ì‚°"""
        if len(returns) == 0:
            return 1.0
        
        # ì‹œì¥ ìˆ˜ìµë¥  (ì˜ˆ: S&P 500)
        # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì‹¤ì œ ì‹œì¥ ë°ì´í„° ì‚¬ìš©
        market_returns = np.random.normal(0.0001, 0.015, len(returns))
        
        covariance = np.cov(returns, market_returns)[0, 1]
        market_variance = np.var(market_returns)
        
        if market_variance == 0:
            return 1.0
        
        return covariance / market_variance
    
    def _calculate_volatility(self, returns: np.ndarray) -> float:
        """ë³€ë™ì„± ê³„ì‚°"""
        if len(returns) == 0:
            return 0.0
        
        return np.std(returns) * np.sqrt(252)  # ì—°ê°„ ë³€ë™ì„±
    
    def _calculate_correlation_matrix(self) -> np.ndarray:
        """ìƒê´€ê´€ê³„ í–‰ë ¬ ê³„ì‚°"""
        if len(self.positions) < 2:
            return np.array([[1.0]])
        
        symbols = list(self.positions.keys())
        returns_matrix = []
        
        # ê° ìì‚°ì˜ ìˆ˜ìµë¥  ê³„ì‚°
        for symbol in symbols:
            prices = list(self.price_history[symbol])
            if len(prices) > 1:
                returns = np.diff(prices) / prices[:-1]
                returns_matrix.append(returns)
        
        if len(returns_matrix) < 2:
            return np.array([[1.0]])
        
        # ìµœì†Œ ê¸¸ì´ë¡œ ë§ì¶”ê¸°
        min_length = min(len(returns) for returns in returns_matrix)
        aligned_returns = [returns[:min_length] for returns in returns_matrix]
        
        # ìƒê´€ê´€ê³„ í–‰ë ¬ ê³„ì‚°
        correlation_matrix = np.corrcoef(aligned_returns)
        
        return correlation_matrix
    
    def _calculate_concentration_risk(self) -> float:
        """ì§‘ì¤‘ë„ ìœ„í—˜ ê³„ì‚° (Herfindahl-Hirschman Index)"""
        if not self.positions:
            return 0.0
        
        total_value = sum(pos.market_value for pos in self.positions.values())
        if total_value == 0:
            return 0.0
        
        # ê° ìì‚°ì˜ ë¹„ì¤‘ ê³„ì‚°
        weights = [pos.market_value / total_value for pos in self.positions.values()]
        
        # HHI ê³„ì‚°
        hhi = sum(weight ** 2 for weight in weights)
        
        return hhi
    
    def _calculate_sector_exposure(self) -> Dict[str, float]:
        """ì„¹í„° ë…¸ì¶œë„ ê³„ì‚°"""
        sector_exposure = defaultdict(float)
        total_value = sum(pos.market_value for pos in self.positions.values())
        
        if total_value == 0:
            return {}
        
        for position in self.positions.values():
            # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ìì‚°ë³„ ì„¹í„° ì •ë³´ ì‚¬ìš©
            sector = self._get_sector_for_symbol(position.symbol)
            sector_exposure[sector] += position.market_value / total_value
        
        return dict(sector_exposure)
    
    def _get_sector_for_symbol(self, symbol: str) -> str:
        """ì‹¬ë³¼ì— ëŒ€í•œ ì„¹í„° ë°˜í™˜"""
        # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì„¹í„° ì •ë³´ ì¡°íšŒ
        sector_mapping = {
            'AAPL': 'Technology',
            'MSFT': 'Technology',
            'GOOGL': 'Technology',
            'AMZN': 'Consumer Discretionary',
            'TSLA': 'Consumer Discretionary',
            'JPM': 'Financial',
            'BAC': 'Financial',
            'XOM': 'Energy',
            'CVX': 'Energy'
        }
        
        return sector_mapping.get(symbol, 'Other')
    
    def check_risk_limits(self, portfolio_risk: PortfolioRisk) -> List[RiskLimit]:
        """ìœ„í—˜ í•œë„ í™•ì¸"""
        risk_limits = []
        
        # VaR í•œë„ í™•ì¸
        var_limit = RiskLimit(
            limit_type='var',
            threshold=0.02,  # 2% VaR í•œë„
            current_value=abs(portfolio_risk.var_95),
            breach_percentage=(abs(portfolio_risk.var_95) / 0.02) * 100,
            status='normal'
        )
        
        if var_limit.breach_percentage > 100:
            var_limit.status = 'breach'
        elif var_limit.breach_percentage > 80:
            var_limit.status = 'warning'
        
        risk_limits.append(var_limit)
        
        # ì§‘ì¤‘ë„ í•œë„ í™•ì¸
        concentration_limit = RiskLimit(
            limit_type='concentration',
            threshold=0.3,  # 30% ì§‘ì¤‘ë„ í•œë„
            current_value=portfolio_risk.concentration_risk,
            breach_percentage=(portfolio_risk.concentration_risk / 0.3) * 100,
            status='normal'
        )
        
        if concentration_limit.breach_percentage > 100:
            concentration_limit.status = 'breach'
        elif concentration_limit.breach_percentage > 80:
            concentration_limit.status = 'warning'
        
        risk_limits.append(concentration_limit)
        
        # ìµœëŒ€ ë‚™í­ í•œë„ í™•ì¸
        drawdown_limit = RiskLimit(
            limit_type='drawdown',
            threshold=0.15,  # 15% ìµœëŒ€ ë‚™í­ í•œë„
            current_value=abs(portfolio_risk.max_drawdown),
            breach_percentage=(abs(portfolio_risk.max_drawdown) / 0.15) * 100,
            status='normal'
        )
        
        if drawdown_limit.breach_percentage > 100:
            drawdown_limit.status = 'breach'
        elif drawdown_limit.breach_percentage > 80:
            drawdown_limit.status = 'warning'
        
        risk_limits.append(drawdown_limit)
        
        return risk_limits
    
    def _monitoring_loop(self):
        """ëª¨ë‹ˆí„°ë§ ë£¨í”„"""
        while self.running:
            try:
                # í¬íŠ¸í´ë¦¬ì˜¤ ìœ„í—˜ ê³„ì‚°
                portfolio_risk = self.calculate_portfolio_risk()
                
                # ìœ„í—˜ í•œë„ í™•ì¸
                risk_limits = self.check_risk_limits(portfolio_risk)
                
                # ìœ„í—˜ í•œë„ ìœ„ë°˜ í™•ì¸
                for risk_limit in risk_limits:
                    if risk_limit.status == 'breach':
                        logger.critical(f"Risk limit breached: {risk_limit.limit_type} = {risk_limit.current_value}")
                        # ì•Œë¦¼ ë°œì†¡
                        self._send_risk_alert(risk_limit)
                    elif risk_limit.status == 'warning':
                        logger.warning(f"Risk limit warning: {risk_limit.limit_type} = {risk_limit.current_value}")
                
                # ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸
                self.metrics.record_portfolio_risk(portfolio_risk)
                
                # 1ì´ˆ ëŒ€ê¸°
                time.sleep(1)
                
            except Exception as e:
                logger.error(f"Risk monitoring error: {e}")
                time.sleep(5)
    
    def _send_risk_alert(self, risk_limit: RiskLimit):
        """ìœ„í—˜ ì•Œë¦¼ ë°œì†¡"""
        alert_message = {
            'type': 'risk_limit_breach',
            'limit_type': risk_limit.limit_type,
            'current_value': risk_limit.current_value,
            'threshold': risk_limit.threshold,
            'breach_percentage': risk_limit.breach_percentage,
            'timestamp': datetime.now().isoformat()
        }
        
        logger.critical(f"Risk alert: {alert_message}")
        # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì•Œë¦¼ ì‹œìŠ¤í…œìœ¼ë¡œ ì „ì†¡
    
    def _invalidate_cache(self, symbol: str):
        """ìºì‹œ ë¬´íš¨í™”"""
        # ê´€ë ¨ëœ ìºì‹œ í‚¤ë“¤ ì‚­ì œ
        keys_to_remove = [key for key in self.var_cache.keys() if symbol in key]
        for key in keys_to_remove:
            del self.var_cache[key]
    
    def _empty_portfolio_risk(self) -> PortfolioRisk:
        """ë¹ˆ í¬íŠ¸í´ë¦¬ì˜¤ ìœ„í—˜ ì •ë³´"""
        return PortfolioRisk(
            total_value=0.0,
            total_pnl=0.0,
            var_95=0.0,
            var_99=0.0,
            expected_shortfall=0.0,
            sharpe_ratio=0.0,
            max_drawdown=0.0,
            beta=1.0,
            volatility=0.0,
            correlation_matrix=np.array([[1.0]]),
            concentration_risk=0.0,
            sector_exposure={},
            timestamp=datetime.now()
        )
    
    def _initialize_risk_limits(self) -> Dict[str, float]:
        """ìœ„í—˜ í•œë„ ì´ˆê¸°í™”"""
        return {
            'var_limit': 0.02,  # 2% VaR í•œë„
            'concentration_limit': 0.3,  # 30% ì§‘ì¤‘ë„ í•œë„
            'drawdown_limit': 0.15,  # 15% ìµœëŒ€ ë‚™í­ í•œë„
            'leverage_limit': 3.0,  # 3ë°° ë ˆë²„ë¦¬ì§€ í•œë„
            'sector_limit': 0.4  # 40% ì„¹í„° ë…¸ì¶œ í•œë„
        }

class RiskMetrics:
    """ìœ„í—˜ ë©”íŠ¸ë¦­"""
    
    def __init__(self):
        self.calculation_times = deque(maxlen=1000)
        self.portfolio_risks = deque(maxlen=100)
        self.start_time = time.time()
    
    def record_calculation_time(self, calculation_time_ms: float):
        """ê³„ì‚° ì‹œê°„ ê¸°ë¡"""
        self.calculation_times.append(calculation_time_ms)
    
    def record_portfolio_risk(self, portfolio_risk: PortfolioRisk):
        """í¬íŠ¸í´ë¦¬ì˜¤ ìœ„í—˜ ê¸°ë¡"""
        self.portfolio_risks.append(portfolio_risk)
    
    def get_metrics(self) -> Dict[str, Any]:
        """ë©”íŠ¸ë¦­ ì¡°íšŒ"""
        if not self.calculation_times:
            return {
                'avg_calculation_time_ms': 0.0,
                'max_calculation_time_ms': 0.0,
                'total_calculations': 0,
                'uptime_seconds': time.time() - self.start_time
            }
        
        return {
            'avg_calculation_time_ms': np.mean(self.calculation_times),
            'max_calculation_time_ms': np.max(self.calculation_times),
            'total_calculations': len(self.calculation_times),
            'uptime_seconds': time.time() - self.start_time
        }
```

## ğŸ”§ **ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸ ì‹œìŠ¤í…œ**

### ğŸ“¦ **ì‹œë‚˜ë¦¬ì˜¤ ê¸°ë°˜ ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸**

```python
# risk-management/stress-testing/stress_test_manager.py
import asyncio
import time
import logging
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass
from datetime import datetime, timedelta
import numpy as np
import pandas as pd
from scipy import stats
import threading
from concurrent.futures import ThreadPoolExecutor

logger = logging.getLogger(__name__)

@dataclass
class StressScenario:
    """ìŠ¤íŠ¸ë ˆìŠ¤ ì‹œë‚˜ë¦¬ì˜¤"""
    scenario_id: str
    name: str
    description: str
    market_shock: float  # ì‹œì¥ ì¶©ê²© (%)
    volatility_increase: float  # ë³€ë™ì„± ì¦ê°€ (%)
    correlation_change: float  # ìƒê´€ê´€ê³„ ë³€í™”
    liquidity_dry_up: bool  # ìœ ë™ì„± ê³ ê°ˆ
    funding_cost_increase: float  # ìê¸ˆ ì¡°ë‹¬ ë¹„ìš© ì¦ê°€ (%)
    duration_days: int  # ì§€ì† ê¸°ê°„ (ì¼)

@dataclass
class StressTestResult:
    """ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸ ê²°ê³¼"""
    scenario_id: str
    scenario_name: str
    initial_portfolio_value: float
    stressed_portfolio_value: float
    portfolio_loss: float
    loss_percentage: float
    var_95_stressed: float
    var_99_stressed: float
    expected_shortfall_stressed: float
    max_drawdown_stressed: float
    liquidity_impact: float
    funding_impact: float
    execution_time_seconds: float
    timestamp: datetime

class StressTestManager:
    """ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸ ê´€ë¦¬ì"""
    
    def __init__(self):
        self.scenarios = self._load_default_scenarios()
        self.portfolio_manager = None  # í¬íŠ¸í´ë¦¬ì˜¤ ë§¤ë‹ˆì € ì°¸ì¡°
        self.results_cache = {}
        self.executor = ThreadPoolExecutor(max_workers=4)
        
        logger.info("Stress test manager initialized")
    
    def set_portfolio_manager(self, portfolio_manager):
        """í¬íŠ¸í´ë¦¬ì˜¤ ë§¤ë‹ˆì € ì„¤ì •"""
        self.portfolio_manager = portfolio_manager
    
    async def run_stress_test(self, scenario_id: str) -> StressTestResult:
        """ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸ ì‹¤í–‰"""
        if scenario_id not in self.scenarios:
            raise ValueError(f"Scenario not found: {scenario_id}")
        
        scenario = self.scenarios[scenario_id]
        start_time = time.time()
        
        try:
            # í˜„ì¬ í¬íŠ¸í´ë¦¬ì˜¤ ìƒíƒœ ì €ì¥
            initial_risk = self.portfolio_manager.calculate_portfolio_risk()
            initial_value = initial_risk.total_value
            
            # ìŠ¤íŠ¸ë ˆìŠ¤ ì‹œë‚˜ë¦¬ì˜¤ ì ìš©
            stressed_risk = await self._apply_stress_scenario(scenario, initial_risk)
            
            # ê²°ê³¼ ê³„ì‚°
            stressed_value = stressed_risk.total_value
            portfolio_loss = initial_value - stressed_value
            loss_percentage = (portfolio_loss / initial_value) * 100 if initial_value > 0 else 0
            
            execution_time = time.time() - start_time
            
            result = StressTestResult(
                scenario_id=scenario_id,
                scenario_name=scenario.name,
                initial_portfolio_value=initial_value,
                stressed_portfolio_value=stressed_value,
                portfolio_loss=portfolio_loss,
                loss_percentage=loss_percentage,
                var_95_stressed=stressed_risk.var_95,
                var_99_stressed=stressed_risk.var_99,
                expected_shortfall_stressed=stressed_risk.expected_shortfall,
                max_drawdown_stressed=stressed_risk.max_drawdown,
                liquidity_impact=self._calculate_liquidity_impact(scenario),
                funding_impact=self._calculate_funding_impact(scenario),
                execution_time_seconds=execution_time,
                timestamp=datetime.now()
            )
            
            # ê²°ê³¼ ìºì‹œ
            self.results_cache[scenario_id] = result
            
            logger.info(f"Stress test completed: {scenario_id}, Loss: {loss_percentage:.2f}%")
            return result
            
        except Exception as e:
            logger.error(f"Stress test failed: {e}")
            raise
    
    async def run_all_stress_tests(self) -> List[StressTestResult]:
        """ëª¨ë“  ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸ ì‹¤í–‰"""
        results = []
        
        # ë³‘ë ¬ ì‹¤í–‰
        tasks = [self.run_stress_test(scenario_id) for scenario_id in self.scenarios.keys()]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # ì˜¤ë¥˜ í•„í„°ë§
        valid_results = [result for result in results if not isinstance(result, Exception)]
        
        return valid_results
    
    async def _apply_stress_scenario(self, scenario: StressScenario, 
                                   initial_risk: PortfolioRisk) -> PortfolioRisk:
        """ìŠ¤íŠ¸ë ˆìŠ¤ ì‹œë‚˜ë¦¬ì˜¤ ì ìš©"""
        # ì‹œì¥ ì¶©ê²© ì ìš©
        market_shock_factor = 1 + (scenario.market_shock / 100)
        
        # ë³€ë™ì„± ì¦ê°€ ì ìš©
        volatility_factor = 1 + (scenario.volatility_increase / 100)
        
        # ìƒˆë¡œìš´ ìœ„í—˜ ì§€í‘œ ê³„ì‚°
        stressed_var_95 = initial_risk.var_95 * market_shock_factor * volatility_factor
        stressed_var_99 = initial_risk.var_99 * market_shock_factor * volatility_factor
        stressed_expected_shortfall = initial_risk.expected_shortfall * market_shock_factor * volatility_factor
        
        # í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¹˜ ì¡°ì •
        stressed_total_value = initial_risk.total_value * (1 - abs(scenario.market_shock) / 100)
        stressed_total_pnl = initial_risk.total_pnl * market_shock_factor
        
        # ìœ ë™ì„± ì˜í–¥ ì ìš©
        if scenario.liquidity_dry_up:
            liquidity_impact = 0.05  # 5% ìœ ë™ì„± í• ì¸
            stressed_total_value *= (1 - liquidity_impact)
        
        # ìê¸ˆ ì¡°ë‹¬ ë¹„ìš© ì˜í–¥ ì ìš©
        funding_impact = scenario.funding_cost_increase / 100
        stressed_total_pnl -= initial_risk.total_value * funding_impact
        
        # ìƒˆë¡œìš´ í¬íŠ¸í´ë¦¬ì˜¤ ìœ„í—˜ ê°ì²´ ìƒì„±
        stressed_risk = PortfolioRisk(
            total_value=stressed_total_value,
            total_pnl=stressed_total_pnl,
            var_95=stressed_var_95,
            var_99=stressed_var_99,
            expected_shortfall=stressed_expected_shortfall,
            sharpe_ratio=initial_risk.sharpe_ratio * 0.8,  # ìƒ¤í”„ ë¹„ìœ¨ ê°ì†Œ
            max_drawdown=initial_risk.max_drawdown * 1.5,  # ìµœëŒ€ ë‚™í­ ì¦ê°€
            beta=initial_risk.beta,
            volatility=initial_risk.volatility * volatility_factor,
            correlation_matrix=initial_risk.correlation_matrix,
            concentration_risk=initial_risk.concentration_risk,
            sector_exposure=initial_risk.sector_exposure,
            timestamp=datetime.now()
        )
        
        return stressed_risk
    
    def _calculate_liquidity_impact(self, scenario: StressScenario) -> float:
        """ìœ ë™ì„± ì˜í–¥ ê³„ì‚°"""
        if scenario.liquidity_dry_up:
            return 0.05  # 5% ìœ ë™ì„± í• ì¸
        return 0.0
    
    def _calculate_funding_impact(self, scenario: StressScenario) -> float:
        """ìê¸ˆ ì¡°ë‹¬ ì˜í–¥ ê³„ì‚°"""
        return scenario.funding_cost_increase / 100
    
    def _load_default_scenarios(self) -> Dict[str, StressScenario]:
        """ê¸°ë³¸ ì‹œë‚˜ë¦¬ì˜¤ ë¡œë“œ"""
        scenarios = {
            'market_crash_2008': StressScenario(
                scenario_id='market_crash_2008',
                name='2008 ê¸ˆìœµìœ„ê¸°',
                description='2008ë…„ ê¸ˆìœµìœ„ê¸°ì™€ ìœ ì‚¬í•œ ì‹œì¥ ì¶©ê²©',
                market_shock=-30.0,
                volatility_increase=300.0,
                correlation_change=0.3,
                liquidity_dry_up=True,
                funding_cost_increase=500.0,
                duration_days=30
            ),
            'covid_crash_2020': StressScenario(
                scenario_id='covid_crash_2020',
                name='2020 ì½”ë¡œë‚˜ ì¶©ê²©',
                description='2020ë…„ ì½”ë¡œë‚˜19ë¡œ ì¸í•œ ì‹œì¥ ì¶©ê²©',
                market_shock=-25.0,
                volatility_increase=400.0,
                correlation_change=0.4,
                liquidity_dry_up=True,
                funding_cost_increase=300.0,
                duration_days=20
            ),
            'interest_rate_shock': StressScenario(
                scenario_id='interest_rate_shock',
                name='ê¸ˆë¦¬ ê¸‰ë“±',
                description='ê¸ˆë¦¬ ê¸‰ë“±ìœ¼ë¡œ ì¸í•œ ì‹œì¥ ì¶©ê²©',
                market_shock=-15.0,
                volatility_increase=200.0,
                correlation_change=0.2,
                liquidity_dry_up=False,
                funding_cost_increase=200.0,
                duration_days=10
            ),
            'liquidity_crisis': StressScenario(
                scenario_id='liquidity_crisis',
                name='ìœ ë™ì„± ìœ„ê¸°',
                description='ì‹œì¥ ìœ ë™ì„± ê³ ê°ˆ ì‹œë‚˜ë¦¬ì˜¤',
                market_shock=-10.0,
                volatility_increase=150.0,
                correlation_change=0.1,
                liquidity_dry_up=True,
                funding_cost_increase=1000.0,
                duration_days=5
            ),
            'systemic_risk': StressScenario(
                scenario_id='systemic_risk',
                name='ì‹œìŠ¤í…œ ìœ„í—˜',
                description='ì „ì²´ ê¸ˆìœµ ì‹œìŠ¤í…œ ìœ„í—˜ ì‹œë‚˜ë¦¬ì˜¤',
                market_shock=-40.0,
                volatility_increase=500.0,
                correlation_change=0.5,
                liquidity_dry_up=True,
                funding_cost_increase=800.0,
                duration_days=60
            )
        }
        
        return scenarios
    
    def add_custom_scenario(self, scenario: StressScenario):
        """ì»¤ìŠ¤í…€ ì‹œë‚˜ë¦¬ì˜¤ ì¶”ê°€"""
        self.scenarios[scenario.scenario_id] = scenario
        logger.info(f"Custom scenario added: {scenario.scenario_id}")
    
    def get_scenario(self, scenario_id: str) -> Optional[StressScenario]:
        """ì‹œë‚˜ë¦¬ì˜¤ ì¡°íšŒ"""
        return self.scenarios.get(scenario_id)
    
    def get_all_scenarios(self) -> List[StressScenario]:
        """ëª¨ë“  ì‹œë‚˜ë¦¬ì˜¤ ì¡°íšŒ"""
        return list(self.scenarios.values())
    
    def get_test_result(self, scenario_id: str) -> Optional[StressTestResult]:
        """í…ŒìŠ¤íŠ¸ ê²°ê³¼ ì¡°íšŒ"""
        return self.results_cache.get(scenario_id)
    
    def get_all_results(self) -> List[StressTestResult]:
        """ëª¨ë“  í…ŒìŠ¤íŠ¸ ê²°ê³¼ ì¡°íšŒ"""
        return list(self.results_cache.values())
    
    def generate_stress_report(self, results: List[StressTestResult]) -> Dict[str, Any]:
        """ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸ ë³´ê³ ì„œ ìƒì„±"""
        if not results:
            return {}
        
        # í†µê³„ ê³„ì‚°
        losses = [result.loss_percentage for result in results]
        execution_times = [result.execution_time_seconds for result in results]
        
        report = {
            'summary': {
                'total_scenarios': len(results),
                'avg_loss_percentage': np.mean(losses),
                'max_loss_percentage': np.max(losses),
                'min_loss_percentage': np.min(losses),
                'avg_execution_time': np.mean(execution_times),
                'total_execution_time': np.sum(execution_times)
            },
            'scenarios': [
                {
                    'scenario_id': result.scenario_id,
                    'scenario_name': result.scenario_name,
                    'loss_percentage': result.loss_percentage,
                    'portfolio_loss': result.portfolio_loss,
                    'var_95_stressed': result.var_95_stressed,
                    'var_99_stressed': result.var_99_stressed,
                    'liquidity_impact': result.liquidity_impact,
                    'funding_impact': result.funding_impact,
                    'execution_time': result.execution_time_seconds
                }
                for result in results
            ],
            'risk_ranking': sorted(results, key=lambda x: x.loss_percentage, reverse=True),
            'generated_at': datetime.now().isoformat()
        }
        
        return report
```

## ğŸ¯ **ë‹¤ìŒ ë‹¨ê³„**

### ğŸ“‹ **ì™„ë£Œëœ ì‘ì—…**
- âœ… ì‹¤ì‹œê°„ ìœ„í—˜ í‰ê°€ ì‹œìŠ¤í…œ ì„¤ê³„ (í¬íŠ¸í´ë¦¬ì˜¤ ìœ„í—˜, ì‹œì¥ ìœ„í—˜)
- âœ… ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸ ì‹œìŠ¤í…œ ì„¤ê³„ (ì‹œë‚˜ë¦¬ì˜¤ ê¸°ë°˜, ë³‘ë ¬ ì‹¤í–‰)
- âœ… ìœ„í—˜ í•œë„ ê´€ë¦¬ ì‹œìŠ¤í…œ ì„¤ê³„

### ğŸ”„ **ì§„í–‰ ì¤‘ì¸ ì‘ì—…**
- ğŸ”„ ìë³¸ ì¶©ë¶„ì„± ì‹œìŠ¤í…œ (Basel III, ìë³¸ ë¹„ìœ¨)
- ğŸ”„ ìœ ë™ì„± ê´€ë¦¬ ì‹œìŠ¤í…œ (ìœ ë™ì„± ëª¨ë‹ˆí„°ë§, ë¹„ìƒ ê³„íš)

### â³ **ë‹¤ìŒ ë‹¨ê³„**
1. **ìë³¸ ì¶©ë¶„ì„± ì‹œìŠ¤í…œ** ë¬¸ì„œ ìƒì„±
2. **ìœ ë™ì„± ê´€ë¦¬ ì‹œìŠ¤í…œ** ë¬¸ì„œ ìƒì„±
3. **VaR ê³„ì‚° ì‹œìŠ¤í…œ** ë¬¸ì„œ ìƒì„±

---

**ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸**: 2024-01-31
**ë‹¤ìŒ ì—…ë°ì´íŠ¸**: 2024-02-01 (ìë³¸ ì¶©ë¶„ì„± ì‹œìŠ¤í…œ)
**ìœ„í—˜ ê´€ë¦¬ ëª©í‘œ**: < 100ms ìœ„í—˜ í‰ê°€, < 5ë¶„ ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸, ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§
**ìœ„í—˜ ê´€ë¦¬ ì„±ê³¼**: ì‹¤ì‹œê°„ ìœ„í—˜ í‰ê°€, ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸, ìœ„í—˜ í•œë„ ê´€ë¦¬ 