# ⚠️ Phase 6.1: 위험 관리 시스템

## 📋 **개요**

### 🎯 **목표**
- **실시간 위험 평가**: 포트폴리오, 거래, 시장 위험 실시간 모니터링
- **스트레스 테스트**: 다양한 시나리오 기반 스트레스 테스트
- **자본 충분성**: Basel III 규정 준수, 자본 비율 모니터링
- **유동성 관리**: 실시간 유동성 모니터링, 유동성 위험 관리
- **VaR 계산**: Value at Risk 실시간 계산 및 모니터링

### 📊 **성능 목표**
- **위험 평가 지연**: < 100ms 실시간 위험 평가
- **스트레스 테스트**: < 5분 완료, 다양한 시나리오 지원
- **VaR 계산**: < 1초 완료, 99% 신뢰수준
- **자본 비율**: 실시간 모니터링, 임계값 알림
- **유동성 관리**: 실시간 유동성 지표, 위험 알림

## 🏗️ **위험 관리 시스템 아키텍처**

### 📁 **위험 관리 시스템 구조**
```
risk-management/
├── real-time-risk/                     # 실시간 위험 평가
│   ├── portfolio-risk/                 # 포트폴리오 위험
│   ├── market-risk/                    # 시장 위험
│   ├── credit-risk/                    # 신용 위험
│   └── operational-risk/               # 운영 위험
├── stress-testing/                     # 스트레스 테스트
│   ├── scenario-generation/            # 시나리오 생성
│   ├── stress-models/                  # 스트레스 모델
│   ├── impact-analysis/                # 영향 분석
│   └── reporting/                      # 보고서 생성
├── capital-adequacy/                   # 자본 충분성
│   ├── basel-iii/                      # Basel III 규정
│   ├── capital-ratios/                 # 자본 비율
│   ├── risk-weighted-assets/           # 위험 가중 자산
│   └── regulatory-reporting/           # 규제 보고
├── liquidity-management/               # 유동성 관리
│   ├── liquidity-monitoring/           # 유동성 모니터링
│   ├── liquidity-ratios/               # 유동성 비율
│   ├── funding-risk/                   # 자금 조달 위험
│   └── contingency-planning/           # 비상 계획
└── var-calculations/                   # VaR 계산
    ├── historical-var/                 # 역사적 VaR
    ├── parametric-var/                 # 모수적 VaR
    ├── monte-carlo-var/                # 몬테카를로 VaR
    └── backtesting/                    # 백테스팅
```

## 🔧 **실시간 위험 평가 시스템**

### 📦 **포트폴리오 위험 관리**

```python
# risk-management/real-time-risk/portfolio_risk_manager.py
import asyncio
import time
import logging
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass
from datetime import datetime, timedelta
import numpy as np
import pandas as pd
from scipy import stats
from scipy.optimize import minimize
import threading
from collections import defaultdict, deque

logger = logging.getLogger(__name__)

@dataclass
class Position:
    """포지션 정보"""
    symbol: str
    quantity: float
    entry_price: float
    current_price: float
    unrealized_pnl: float
    market_value: float
    timestamp: datetime

@dataclass
class PortfolioRisk:
    """포트폴리오 위험 정보"""
    total_value: float
    total_pnl: float
    var_95: float
    var_99: float
    expected_shortfall: float
    sharpe_ratio: float
    max_drawdown: float
    beta: float
    volatility: float
    correlation_matrix: np.ndarray
    concentration_risk: float
    sector_exposure: Dict[str, float]
    timestamp: datetime

@dataclass
class RiskLimit:
    """위험 한도"""
    limit_type: str  # 'var', 'concentration', 'drawdown', 'leverage'
    threshold: float
    current_value: float
    breach_percentage: float
    status: str  # 'normal', 'warning', 'breach'

class PortfolioRiskManager:
    """포트폴리오 위험 관리자"""
    
    def __init__(self):
        self.positions = {}
        self.price_history = defaultdict(lambda: deque(maxlen=252))  # 1년 데이터
        self.risk_limits = self._initialize_risk_limits()
        self.correlation_matrix = None
        self.volatility_cache = {}
        self.var_cache = {}
        
        # 성능 모니터링
        self.metrics = RiskMetrics()
        
        # 스레드 안전
        self.lock = threading.Lock()
        
        # 백그라운드 업데이트
        self.update_thread = None
        self.running = False
        
        logger.info("Portfolio risk manager initialized")
    
    async def start_monitoring(self):
        """위험 모니터링 시작"""
        self.running = True
        self.update_thread = threading.Thread(target=self._monitoring_loop)
        self.update_thread.start()
        logger.info("Portfolio risk monitoring started")
    
    async def stop_monitoring(self):
        """위험 모니터링 중지"""
        self.running = False
        if self.update_thread:
            self.update_thread.join()
        logger.info("Portfolio risk monitoring stopped")
    
    def update_position(self, symbol: str, quantity: float, price: float):
        """포지션 업데이트"""
        with self.lock:
            if symbol in self.positions:
                # 기존 포지션 업데이트
                position = self.positions[symbol]
                position.quantity = quantity
                position.current_price = price
                position.unrealized_pnl = (price - position.entry_price) * quantity
                position.market_value = quantity * price
                position.timestamp = datetime.now()
            else:
                # 새 포지션 생성
                position = Position(
                    symbol=symbol,
                    quantity=quantity,
                    entry_price=price,
                    current_price=price,
                    unrealized_pnl=0.0,
                    market_value=quantity * price,
                    timestamp=datetime.now()
                )
                self.positions[symbol] = position
            
            # 가격 히스토리 업데이트
            self.price_history[symbol].append(price)
            
            # 캐시 무효화
            self._invalidate_cache(symbol)
    
    def calculate_portfolio_risk(self) -> PortfolioRisk:
        """포트폴리오 위험 계산"""
        with self.lock:
            start_time = time.time()
            
            if not self.positions:
                return self._empty_portfolio_risk()
            
            # 기본 정보 계산
            total_value = sum(pos.market_value for pos in self.positions.values())
            total_pnl = sum(pos.unrealized_pnl for pos in self.positions.values())
            
            # 수익률 계산
            returns = self._calculate_returns()
            
            # 위험 지표 계산
            var_95 = self._calculate_var(returns, confidence_level=0.95)
            var_99 = self._calculate_var(returns, confidence_level=0.99)
            expected_shortfall = self._calculate_expected_shortfall(returns, confidence_level=0.95)
            sharpe_ratio = self._calculate_sharpe_ratio(returns)
            max_drawdown = self._calculate_max_drawdown(returns)
            beta = self._calculate_beta(returns)
            volatility = self._calculate_volatility(returns)
            
            # 상관관계 행렬 계산
            correlation_matrix = self._calculate_correlation_matrix()
            
            # 집중도 위험 계산
            concentration_risk = self._calculate_concentration_risk()
            
            # 섹터 노출도 계산
            sector_exposure = self._calculate_sector_exposure()
            
            # 성능 측정
            calculation_time = (time.time() - start_time) * 1000
            self.metrics.record_calculation_time(calculation_time)
            
            return PortfolioRisk(
                total_value=total_value,
                total_pnl=total_pnl,
                var_95=var_95,
                var_99=var_99,
                expected_shortfall=expected_shortfall,
                sharpe_ratio=sharpe_ratio,
                max_drawdown=max_drawdown,
                beta=beta,
                volatility=volatility,
                correlation_matrix=correlation_matrix,
                concentration_risk=concentration_risk,
                sector_exposure=sector_exposure,
                timestamp=datetime.now()
            )
    
    def _calculate_returns(self) -> np.ndarray:
        """수익률 계산"""
        if not self.positions:
            return np.array([])
        
        # 포트폴리오 가치 시계열 계산
        portfolio_values = []
        symbols = list(self.positions.keys())
        
        # 최소 길이 찾기
        min_length = min(len(self.price_history[symbol]) for symbol in symbols)
        
        for i in range(min_length):
            portfolio_value = 0
            for symbol in symbols:
                if i < len(self.price_history[symbol]):
                    price = list(self.price_history[symbol])[i]
                    position = self.positions[symbol]
                    portfolio_value += position.quantity * price
            portfolio_values.append(portfolio_value)
        
        # 수익률 계산
        portfolio_values = np.array(portfolio_values)
        returns = np.diff(portfolio_values) / portfolio_values[:-1]
        
        return returns
    
    def _calculate_var(self, returns: np.ndarray, confidence_level: float = 0.95) -> float:
        """Value at Risk 계산"""
        if len(returns) == 0:
            return 0.0
        
        # 캐시 확인
        cache_key = f"var_{confidence_level}_{hash(tuple(returns[-50:]))}"
        if cache_key in self.var_cache:
            return self.var_cache[cache_key]
        
        # VaR 계산 (역사적 시뮬레이션)
        var = np.percentile(returns, (1 - confidence_level) * 100)
        
        # 캐시 저장
        self.var_cache[cache_key] = var
        
        return var
    
    def _calculate_expected_shortfall(self, returns: np.ndarray, confidence_level: float = 0.95) -> float:
        """Expected Shortfall (Conditional VaR) 계산"""
        if len(returns) == 0:
            return 0.0
        
        var = self._calculate_var(returns, confidence_level)
        tail_returns = returns[returns <= var]
        
        if len(tail_returns) == 0:
            return var
        
        return np.mean(tail_returns)
    
    def _calculate_sharpe_ratio(self, returns: np.ndarray) -> float:
        """샤프 비율 계산"""
        if len(returns) == 0:
            return 0.0
        
        mean_return = np.mean(returns)
        std_return = np.std(returns)
        
        if std_return == 0:
            return 0.0
        
        # 무위험 수익률 (예: 2%)
        risk_free_rate = 0.02 / 252  # 일간 무위험 수익률
        
        return (mean_return - risk_free_rate) / std_return
    
    def _calculate_max_drawdown(self, returns: np.ndarray) -> float:
        """최대 낙폭 계산"""
        if len(returns) == 0:
            return 0.0
        
        cumulative_returns = np.cumprod(1 + returns)
        running_max = np.maximum.accumulate(cumulative_returns)
        drawdown = (cumulative_returns - running_max) / running_max
        
        return np.min(drawdown)
    
    def _calculate_beta(self, returns: np.ndarray) -> float:
        """베타 계산"""
        if len(returns) == 0:
            return 1.0
        
        # 시장 수익률 (예: S&P 500)
        # 실제 구현에서는 실제 시장 데이터 사용
        market_returns = np.random.normal(0.0001, 0.015, len(returns))
        
        covariance = np.cov(returns, market_returns)[0, 1]
        market_variance = np.var(market_returns)
        
        if market_variance == 0:
            return 1.0
        
        return covariance / market_variance
    
    def _calculate_volatility(self, returns: np.ndarray) -> float:
        """변동성 계산"""
        if len(returns) == 0:
            return 0.0
        
        return np.std(returns) * np.sqrt(252)  # 연간 변동성
    
    def _calculate_correlation_matrix(self) -> np.ndarray:
        """상관관계 행렬 계산"""
        if len(self.positions) < 2:
            return np.array([[1.0]])
        
        symbols = list(self.positions.keys())
        returns_matrix = []
        
        # 각 자산의 수익률 계산
        for symbol in symbols:
            prices = list(self.price_history[symbol])
            if len(prices) > 1:
                returns = np.diff(prices) / prices[:-1]
                returns_matrix.append(returns)
        
        if len(returns_matrix) < 2:
            return np.array([[1.0]])
        
        # 최소 길이로 맞추기
        min_length = min(len(returns) for returns in returns_matrix)
        aligned_returns = [returns[:min_length] for returns in returns_matrix]
        
        # 상관관계 행렬 계산
        correlation_matrix = np.corrcoef(aligned_returns)
        
        return correlation_matrix
    
    def _calculate_concentration_risk(self) -> float:
        """집중도 위험 계산 (Herfindahl-Hirschman Index)"""
        if not self.positions:
            return 0.0
        
        total_value = sum(pos.market_value for pos in self.positions.values())
        if total_value == 0:
            return 0.0
        
        # 각 자산의 비중 계산
        weights = [pos.market_value / total_value for pos in self.positions.values()]
        
        # HHI 계산
        hhi = sum(weight ** 2 for weight in weights)
        
        return hhi
    
    def _calculate_sector_exposure(self) -> Dict[str, float]:
        """섹터 노출도 계산"""
        sector_exposure = defaultdict(float)
        total_value = sum(pos.market_value for pos in self.positions.values())
        
        if total_value == 0:
            return {}
        
        for position in self.positions.values():
            # 실제 구현에서는 자산별 섹터 정보 사용
            sector = self._get_sector_for_symbol(position.symbol)
            sector_exposure[sector] += position.market_value / total_value
        
        return dict(sector_exposure)
    
    def _get_sector_for_symbol(self, symbol: str) -> str:
        """심볼에 대한 섹터 반환"""
        # 실제 구현에서는 데이터베이스에서 섹터 정보 조회
        sector_mapping = {
            'AAPL': 'Technology',
            'MSFT': 'Technology',
            'GOOGL': 'Technology',
            'AMZN': 'Consumer Discretionary',
            'TSLA': 'Consumer Discretionary',
            'JPM': 'Financial',
            'BAC': 'Financial',
            'XOM': 'Energy',
            'CVX': 'Energy'
        }
        
        return sector_mapping.get(symbol, 'Other')
    
    def check_risk_limits(self, portfolio_risk: PortfolioRisk) -> List[RiskLimit]:
        """위험 한도 확인"""
        risk_limits = []
        
        # VaR 한도 확인
        var_limit = RiskLimit(
            limit_type='var',
            threshold=0.02,  # 2% VaR 한도
            current_value=abs(portfolio_risk.var_95),
            breach_percentage=(abs(portfolio_risk.var_95) / 0.02) * 100,
            status='normal'
        )
        
        if var_limit.breach_percentage > 100:
            var_limit.status = 'breach'
        elif var_limit.breach_percentage > 80:
            var_limit.status = 'warning'
        
        risk_limits.append(var_limit)
        
        # 집중도 한도 확인
        concentration_limit = RiskLimit(
            limit_type='concentration',
            threshold=0.3,  # 30% 집중도 한도
            current_value=portfolio_risk.concentration_risk,
            breach_percentage=(portfolio_risk.concentration_risk / 0.3) * 100,
            status='normal'
        )
        
        if concentration_limit.breach_percentage > 100:
            concentration_limit.status = 'breach'
        elif concentration_limit.breach_percentage > 80:
            concentration_limit.status = 'warning'
        
        risk_limits.append(concentration_limit)
        
        # 최대 낙폭 한도 확인
        drawdown_limit = RiskLimit(
            limit_type='drawdown',
            threshold=0.15,  # 15% 최대 낙폭 한도
            current_value=abs(portfolio_risk.max_drawdown),
            breach_percentage=(abs(portfolio_risk.max_drawdown) / 0.15) * 100,
            status='normal'
        )
        
        if drawdown_limit.breach_percentage > 100:
            drawdown_limit.status = 'breach'
        elif drawdown_limit.breach_percentage > 80:
            drawdown_limit.status = 'warning'
        
        risk_limits.append(drawdown_limit)
        
        return risk_limits
    
    def _monitoring_loop(self):
        """모니터링 루프"""
        while self.running:
            try:
                # 포트폴리오 위험 계산
                portfolio_risk = self.calculate_portfolio_risk()
                
                # 위험 한도 확인
                risk_limits = self.check_risk_limits(portfolio_risk)
                
                # 위험 한도 위반 확인
                for risk_limit in risk_limits:
                    if risk_limit.status == 'breach':
                        logger.critical(f"Risk limit breached: {risk_limit.limit_type} = {risk_limit.current_value}")
                        # 알림 발송
                        self._send_risk_alert(risk_limit)
                    elif risk_limit.status == 'warning':
                        logger.warning(f"Risk limit warning: {risk_limit.limit_type} = {risk_limit.current_value}")
                
                # 메트릭 업데이트
                self.metrics.record_portfolio_risk(portfolio_risk)
                
                # 1초 대기
                time.sleep(1)
                
            except Exception as e:
                logger.error(f"Risk monitoring error: {e}")
                time.sleep(5)
    
    def _send_risk_alert(self, risk_limit: RiskLimit):
        """위험 알림 발송"""
        alert_message = {
            'type': 'risk_limit_breach',
            'limit_type': risk_limit.limit_type,
            'current_value': risk_limit.current_value,
            'threshold': risk_limit.threshold,
            'breach_percentage': risk_limit.breach_percentage,
            'timestamp': datetime.now().isoformat()
        }
        
        logger.critical(f"Risk alert: {alert_message}")
        # 실제 구현에서는 알림 시스템으로 전송
    
    def _invalidate_cache(self, symbol: str):
        """캐시 무효화"""
        # 관련된 캐시 키들 삭제
        keys_to_remove = [key for key in self.var_cache.keys() if symbol in key]
        for key in keys_to_remove:
            del self.var_cache[key]
    
    def _empty_portfolio_risk(self) -> PortfolioRisk:
        """빈 포트폴리오 위험 정보"""
        return PortfolioRisk(
            total_value=0.0,
            total_pnl=0.0,
            var_95=0.0,
            var_99=0.0,
            expected_shortfall=0.0,
            sharpe_ratio=0.0,
            max_drawdown=0.0,
            beta=1.0,
            volatility=0.0,
            correlation_matrix=np.array([[1.0]]),
            concentration_risk=0.0,
            sector_exposure={},
            timestamp=datetime.now()
        )
    
    def _initialize_risk_limits(self) -> Dict[str, float]:
        """위험 한도 초기화"""
        return {
            'var_limit': 0.02,  # 2% VaR 한도
            'concentration_limit': 0.3,  # 30% 집중도 한도
            'drawdown_limit': 0.15,  # 15% 최대 낙폭 한도
            'leverage_limit': 3.0,  # 3배 레버리지 한도
            'sector_limit': 0.4  # 40% 섹터 노출 한도
        }

class RiskMetrics:
    """위험 메트릭"""
    
    def __init__(self):
        self.calculation_times = deque(maxlen=1000)
        self.portfolio_risks = deque(maxlen=100)
        self.start_time = time.time()
    
    def record_calculation_time(self, calculation_time_ms: float):
        """계산 시간 기록"""
        self.calculation_times.append(calculation_time_ms)
    
    def record_portfolio_risk(self, portfolio_risk: PortfolioRisk):
        """포트폴리오 위험 기록"""
        self.portfolio_risks.append(portfolio_risk)
    
    def get_metrics(self) -> Dict[str, Any]:
        """메트릭 조회"""
        if not self.calculation_times:
            return {
                'avg_calculation_time_ms': 0.0,
                'max_calculation_time_ms': 0.0,
                'total_calculations': 0,
                'uptime_seconds': time.time() - self.start_time
            }
        
        return {
            'avg_calculation_time_ms': np.mean(self.calculation_times),
            'max_calculation_time_ms': np.max(self.calculation_times),
            'total_calculations': len(self.calculation_times),
            'uptime_seconds': time.time() - self.start_time
        }
```

## 🔧 **스트레스 테스트 시스템**

### 📦 **시나리오 기반 스트레스 테스트**

```python
# risk-management/stress-testing/stress_test_manager.py
import asyncio
import time
import logging
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass
from datetime import datetime, timedelta
import numpy as np
import pandas as pd
from scipy import stats
import threading
from concurrent.futures import ThreadPoolExecutor

logger = logging.getLogger(__name__)

@dataclass
class StressScenario:
    """스트레스 시나리오"""
    scenario_id: str
    name: str
    description: str
    market_shock: float  # 시장 충격 (%)
    volatility_increase: float  # 변동성 증가 (%)
    correlation_change: float  # 상관관계 변화
    liquidity_dry_up: bool  # 유동성 고갈
    funding_cost_increase: float  # 자금 조달 비용 증가 (%)
    duration_days: int  # 지속 기간 (일)

@dataclass
class StressTestResult:
    """스트레스 테스트 결과"""
    scenario_id: str
    scenario_name: str
    initial_portfolio_value: float
    stressed_portfolio_value: float
    portfolio_loss: float
    loss_percentage: float
    var_95_stressed: float
    var_99_stressed: float
    expected_shortfall_stressed: float
    max_drawdown_stressed: float
    liquidity_impact: float
    funding_impact: float
    execution_time_seconds: float
    timestamp: datetime

class StressTestManager:
    """스트레스 테스트 관리자"""
    
    def __init__(self):
        self.scenarios = self._load_default_scenarios()
        self.portfolio_manager = None  # 포트폴리오 매니저 참조
        self.results_cache = {}
        self.executor = ThreadPoolExecutor(max_workers=4)
        
        logger.info("Stress test manager initialized")
    
    def set_portfolio_manager(self, portfolio_manager):
        """포트폴리오 매니저 설정"""
        self.portfolio_manager = portfolio_manager
    
    async def run_stress_test(self, scenario_id: str) -> StressTestResult:
        """스트레스 테스트 실행"""
        if scenario_id not in self.scenarios:
            raise ValueError(f"Scenario not found: {scenario_id}")
        
        scenario = self.scenarios[scenario_id]
        start_time = time.time()
        
        try:
            # 현재 포트폴리오 상태 저장
            initial_risk = self.portfolio_manager.calculate_portfolio_risk()
            initial_value = initial_risk.total_value
            
            # 스트레스 시나리오 적용
            stressed_risk = await self._apply_stress_scenario(scenario, initial_risk)
            
            # 결과 계산
            stressed_value = stressed_risk.total_value
            portfolio_loss = initial_value - stressed_value
            loss_percentage = (portfolio_loss / initial_value) * 100 if initial_value > 0 else 0
            
            execution_time = time.time() - start_time
            
            result = StressTestResult(
                scenario_id=scenario_id,
                scenario_name=scenario.name,
                initial_portfolio_value=initial_value,
                stressed_portfolio_value=stressed_value,
                portfolio_loss=portfolio_loss,
                loss_percentage=loss_percentage,
                var_95_stressed=stressed_risk.var_95,
                var_99_stressed=stressed_risk.var_99,
                expected_shortfall_stressed=stressed_risk.expected_shortfall,
                max_drawdown_stressed=stressed_risk.max_drawdown,
                liquidity_impact=self._calculate_liquidity_impact(scenario),
                funding_impact=self._calculate_funding_impact(scenario),
                execution_time_seconds=execution_time,
                timestamp=datetime.now()
            )
            
            # 결과 캐시
            self.results_cache[scenario_id] = result
            
            logger.info(f"Stress test completed: {scenario_id}, Loss: {loss_percentage:.2f}%")
            return result
            
        except Exception as e:
            logger.error(f"Stress test failed: {e}")
            raise
    
    async def run_all_stress_tests(self) -> List[StressTestResult]:
        """모든 스트레스 테스트 실행"""
        results = []
        
        # 병렬 실행
        tasks = [self.run_stress_test(scenario_id) for scenario_id in self.scenarios.keys()]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        # 오류 필터링
        valid_results = [result for result in results if not isinstance(result, Exception)]
        
        return valid_results
    
    async def _apply_stress_scenario(self, scenario: StressScenario, 
                                   initial_risk: PortfolioRisk) -> PortfolioRisk:
        """스트레스 시나리오 적용"""
        # 시장 충격 적용
        market_shock_factor = 1 + (scenario.market_shock / 100)
        
        # 변동성 증가 적용
        volatility_factor = 1 + (scenario.volatility_increase / 100)
        
        # 새로운 위험 지표 계산
        stressed_var_95 = initial_risk.var_95 * market_shock_factor * volatility_factor
        stressed_var_99 = initial_risk.var_99 * market_shock_factor * volatility_factor
        stressed_expected_shortfall = initial_risk.expected_shortfall * market_shock_factor * volatility_factor
        
        # 포트폴리오 가치 조정
        stressed_total_value = initial_risk.total_value * (1 - abs(scenario.market_shock) / 100)
        stressed_total_pnl = initial_risk.total_pnl * market_shock_factor
        
        # 유동성 영향 적용
        if scenario.liquidity_dry_up:
            liquidity_impact = 0.05  # 5% 유동성 할인
            stressed_total_value *= (1 - liquidity_impact)
        
        # 자금 조달 비용 영향 적용
        funding_impact = scenario.funding_cost_increase / 100
        stressed_total_pnl -= initial_risk.total_value * funding_impact
        
        # 새로운 포트폴리오 위험 객체 생성
        stressed_risk = PortfolioRisk(
            total_value=stressed_total_value,
            total_pnl=stressed_total_pnl,
            var_95=stressed_var_95,
            var_99=stressed_var_99,
            expected_shortfall=stressed_expected_shortfall,
            sharpe_ratio=initial_risk.sharpe_ratio * 0.8,  # 샤프 비율 감소
            max_drawdown=initial_risk.max_drawdown * 1.5,  # 최대 낙폭 증가
            beta=initial_risk.beta,
            volatility=initial_risk.volatility * volatility_factor,
            correlation_matrix=initial_risk.correlation_matrix,
            concentration_risk=initial_risk.concentration_risk,
            sector_exposure=initial_risk.sector_exposure,
            timestamp=datetime.now()
        )
        
        return stressed_risk
    
    def _calculate_liquidity_impact(self, scenario: StressScenario) -> float:
        """유동성 영향 계산"""
        if scenario.liquidity_dry_up:
            return 0.05  # 5% 유동성 할인
        return 0.0
    
    def _calculate_funding_impact(self, scenario: StressScenario) -> float:
        """자금 조달 영향 계산"""
        return scenario.funding_cost_increase / 100
    
    def _load_default_scenarios(self) -> Dict[str, StressScenario]:
        """기본 시나리오 로드"""
        scenarios = {
            'market_crash_2008': StressScenario(
                scenario_id='market_crash_2008',
                name='2008 금융위기',
                description='2008년 금융위기와 유사한 시장 충격',
                market_shock=-30.0,
                volatility_increase=300.0,
                correlation_change=0.3,
                liquidity_dry_up=True,
                funding_cost_increase=500.0,
                duration_days=30
            ),
            'covid_crash_2020': StressScenario(
                scenario_id='covid_crash_2020',
                name='2020 코로나 충격',
                description='2020년 코로나19로 인한 시장 충격',
                market_shock=-25.0,
                volatility_increase=400.0,
                correlation_change=0.4,
                liquidity_dry_up=True,
                funding_cost_increase=300.0,
                duration_days=20
            ),
            'interest_rate_shock': StressScenario(
                scenario_id='interest_rate_shock',
                name='금리 급등',
                description='금리 급등으로 인한 시장 충격',
                market_shock=-15.0,
                volatility_increase=200.0,
                correlation_change=0.2,
                liquidity_dry_up=False,
                funding_cost_increase=200.0,
                duration_days=10
            ),
            'liquidity_crisis': StressScenario(
                scenario_id='liquidity_crisis',
                name='유동성 위기',
                description='시장 유동성 고갈 시나리오',
                market_shock=-10.0,
                volatility_increase=150.0,
                correlation_change=0.1,
                liquidity_dry_up=True,
                funding_cost_increase=1000.0,
                duration_days=5
            ),
            'systemic_risk': StressScenario(
                scenario_id='systemic_risk',
                name='시스템 위험',
                description='전체 금융 시스템 위험 시나리오',
                market_shock=-40.0,
                volatility_increase=500.0,
                correlation_change=0.5,
                liquidity_dry_up=True,
                funding_cost_increase=800.0,
                duration_days=60
            )
        }
        
        return scenarios
    
    def add_custom_scenario(self, scenario: StressScenario):
        """커스텀 시나리오 추가"""
        self.scenarios[scenario.scenario_id] = scenario
        logger.info(f"Custom scenario added: {scenario.scenario_id}")
    
    def get_scenario(self, scenario_id: str) -> Optional[StressScenario]:
        """시나리오 조회"""
        return self.scenarios.get(scenario_id)
    
    def get_all_scenarios(self) -> List[StressScenario]:
        """모든 시나리오 조회"""
        return list(self.scenarios.values())
    
    def get_test_result(self, scenario_id: str) -> Optional[StressTestResult]:
        """테스트 결과 조회"""
        return self.results_cache.get(scenario_id)
    
    def get_all_results(self) -> List[StressTestResult]:
        """모든 테스트 결과 조회"""
        return list(self.results_cache.values())
    
    def generate_stress_report(self, results: List[StressTestResult]) -> Dict[str, Any]:
        """스트레스 테스트 보고서 생성"""
        if not results:
            return {}
        
        # 통계 계산
        losses = [result.loss_percentage for result in results]
        execution_times = [result.execution_time_seconds for result in results]
        
        report = {
            'summary': {
                'total_scenarios': len(results),
                'avg_loss_percentage': np.mean(losses),
                'max_loss_percentage': np.max(losses),
                'min_loss_percentage': np.min(losses),
                'avg_execution_time': np.mean(execution_times),
                'total_execution_time': np.sum(execution_times)
            },
            'scenarios': [
                {
                    'scenario_id': result.scenario_id,
                    'scenario_name': result.scenario_name,
                    'loss_percentage': result.loss_percentage,
                    'portfolio_loss': result.portfolio_loss,
                    'var_95_stressed': result.var_95_stressed,
                    'var_99_stressed': result.var_99_stressed,
                    'liquidity_impact': result.liquidity_impact,
                    'funding_impact': result.funding_impact,
                    'execution_time': result.execution_time_seconds
                }
                for result in results
            ],
            'risk_ranking': sorted(results, key=lambda x: x.loss_percentage, reverse=True),
            'generated_at': datetime.now().isoformat()
        }
        
        return report
```

## 🎯 **다음 단계**

### 📋 **완료된 작업**
- ✅ 실시간 위험 평가 시스템 설계 (포트폴리오 위험, 시장 위험)
- ✅ 스트레스 테스트 시스템 설계 (시나리오 기반, 병렬 실행)
- ✅ 위험 한도 관리 시스템 설계

### 🔄 **진행 중인 작업**
- 🔄 자본 충분성 시스템 (Basel III, 자본 비율)
- 🔄 유동성 관리 시스템 (유동성 모니터링, 비상 계획)

### ⏳ **다음 단계**
1. **자본 충분성 시스템** 문서 생성
2. **유동성 관리 시스템** 문서 생성
3. **VaR 계산 시스템** 문서 생성

---

**마지막 업데이트**: 2024-01-31
**다음 업데이트**: 2024-02-01 (자본 충분성 시스템)
**위험 관리 목표**: < 100ms 위험 평가, < 5분 스트레스 테스트, 실시간 모니터링
**위험 관리 성과**: 실시간 위험 평가, 스트레스 테스트, 위험 한도 관리 