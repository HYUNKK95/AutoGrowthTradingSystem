# π”’ Phase 6.2: λ°μ΄ν„° λ³΄νΈ μ‹μ¤ν…

## π“‹ **κ°μ”**

### π― **λ©ν‘**
- **λ°μ΄ν„° μ•”νΈν™”**: μ €μ¥ λ° μ „μ†΅ μ‹ AES-256, RSA-4096 μ•”νΈν™”
- **λ°μ΄ν„° μµλ…ν™”**: PII λ°μ΄ν„° μµλ…ν™” λ° κ°€λ…ν™”
- **μ ‘κ·Ό μ μ–΄**: μ„Έλ°€ν• κ¶ν• κ΄€λ¦¬, RBAC, ABAC
- **λ°μ΄ν„° λ¶„λ¥**: λ―Όκ°λ„λ³„ λ°μ΄ν„° λ¶„λ¥ λ° μ²λ¦¬
- **κ°μΈμ •λ³΄ λ³΄νΈ**: GDPR, CCPA μ™„μ „ μ¤€μ

### π“ **μ„±λ¥ λ©ν‘**
- **μ•”νΈν™” μ„±λ¥**: < 10ms μ•”νΈν™”/λ³µνΈν™”
- **μµλ…ν™” μ„±λ¥**: < 50ms λ°μ΄ν„° μµλ…ν™”
- **μ ‘κ·Ό μ μ–΄**: < 5ms κ¶ν• κ²€μ¦
- **λ°μ΄ν„° λ¶„λ¥**: < 100ms μλ™ λ¶„λ¥
- **κ°μΈμ •λ³΄ λ³΄νΈ**: 100% κ·μ • μ¤€μ

## π—οΈ **λ°μ΄ν„° λ³΄νΈ μ‹μ¤ν… μ•„ν‚¤ν…μ²**

### π“ **λ°μ΄ν„° λ³΄νΈ μ‹μ¤ν… κµ¬μ΅°**
```
data-protection/
β”β”€β”€ encryption/                        # μ•”νΈν™” μ‹μ¤ν…
β”‚   β”β”€β”€ symmetric-encryption/          # λ€μΉ­ν‚¤ μ•”νΈν™”
β”‚   β”β”€β”€ asymmetric-encryption/         # λΉ„λ€μΉ­ν‚¤ μ•”νΈν™”
β”‚   β”β”€β”€ key-management/                # ν‚¤ κ΄€λ¦¬
β”‚   β””β”€β”€ hardware-security/             # ν•λ“μ›¨μ–΄ λ³΄μ•
β”β”€β”€ anonymization/                     # μµλ…ν™” μ‹μ¤ν…
β”‚   β”β”€β”€ data-masking/                  # λ°μ΄ν„° λ§μ¤ν‚Ή
β”‚   β”β”€β”€ pseudonymization/              # κ°€λ…ν™”
β”‚   β”β”€β”€ generalization/                # μΌλ°ν™”
β”‚   β””β”€β”€ suppression/                   # μ–µμ 
β”β”€β”€ access-control/                    # μ ‘κ·Ό μ μ–΄
β”‚   β”β”€β”€ rbac/                          # μ—­ν•  κΈ°λ° μ ‘κ·Ό μ μ–΄
β”‚   β”β”€β”€ abac/                          # μ†μ„± κΈ°λ° μ ‘κ·Ό μ μ–΄
β”‚   β”β”€β”€ dynamic-access/                # λ™μ  μ ‘κ·Ό μ μ–΄
β”‚   β””β”€β”€ session-management/            # μ„Έμ… κ΄€λ¦¬
β”β”€β”€ data-classification/               # λ°μ΄ν„° λ¶„λ¥
β”‚   β”β”€β”€ automatic-classification/      # μλ™ λ¶„λ¥
β”‚   β”β”€β”€ sensitivity-levels/            # λ―Όκ°λ„ μμ¤€
β”‚   β”β”€β”€ classification-rules/          # λ¶„λ¥ κ·μΉ™
β”‚   β””β”€β”€ compliance-checking/           # κ·μ • μ¤€μ ν™•μΈ
β””β”€β”€ privacy-protection/                # κ°μΈμ •λ³΄ λ³΄νΈ
    β”β”€β”€ gdpr-compliance/               # GDPR μ¤€μ
    β”β”€β”€ ccpa-compliance/               # CCPA μ¤€μ
    β”β”€β”€ data-subject-rights/           # λ°μ΄ν„° μ£Όμ²΄ κ¶λ¦¬
    β””β”€β”€ consent-management/            # λ™μ κ΄€λ¦¬
```

## π”§ **μ•”νΈν™” μ‹μ¤ν…**

### π“¦ **λ€μΉ­ν‚¤ μ•”νΈν™” (AES-256)**

```python
# data-protection/encryption/symmetric_encryption.py
import asyncio
import time
import logging
from typing import Dict, List, Tuple, Optional, Any, Union
from dataclasses import dataclass
from datetime import datetime, timedelta
import os
import base64
import hashlib
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
import threading
from collections import defaultdict

logger = logging.getLogger(__name__)

@dataclass
class EncryptionKey:
    """μ•”νΈν™” ν‚¤ μ •λ³΄"""
    key_id: str
    key_type: str  # 'symmetric', 'asymmetric'
    algorithm: str  # 'AES-256', 'RSA-4096'
    key_data: bytes
    created_at: datetime
    expires_at: Optional[datetime]
    usage_count: int
    is_active: bool

@dataclass
class EncryptedData:
    """μ•”νΈν™”λ λ°μ΄ν„°"""
    data_id: str
    encrypted_data: bytes
    key_id: str
    algorithm: str
    iv: bytes
    auth_tag: Optional[bytes]
    created_at: datetime
    metadata: Dict[str, Any]

class SymmetricEncryptionManager:
    """λ€μΉ­ν‚¤ μ•”νΈν™” κ΄€λ¦¬μ"""
    
    def __init__(self):
        self.keys = {}
        self.key_cache = {}
        self.performance_metrics = EncryptionMetrics()
        self.lock = threading.Lock()
        
        # ν‚¤ μƒμ„± λ° κ΄€λ¦¬
        self._initialize_keys()
        
        logger.info("Symmetric encryption manager initialized")
    
    def _initialize_keys(self):
        """μ΄κΈ° ν‚¤ μƒμ„±"""
        # λ§μ¤ν„° ν‚¤ μƒμ„±
        master_key = self._generate_master_key()
        
        # AES-256 ν‚¤ μƒμ„±
        aes_key = self._generate_aes_key()
        
        # ν‚¤ μ €μ¥
        self.keys['master'] = EncryptionKey(
            key_id='master',
            key_type='symmetric',
            algorithm='AES-256',
            key_data=master_key,
            created_at=datetime.now(),
            expires_at=datetime.now() + timedelta(days=365),
            usage_count=0,
            is_active=True
        )
        
        self.keys['aes_256'] = EncryptionKey(
            key_id='aes_256',
            key_type='symmetric',
            algorithm='AES-256',
            key_data=aes_key,
            created_at=datetime.now(),
            expires_at=datetime.now() + timedelta(days=90),
            usage_count=0,
            is_active=True
        )
    
    def _generate_master_key(self) -> bytes:
        """λ§μ¤ν„° ν‚¤ μƒμ„±"""
        return os.urandom(32)  # 256-bit
    
    def _generate_aes_key(self) -> bytes:
        """AES ν‚¤ μƒμ„±"""
        return os.urandom(32)  # 256-bit
    
    async def encrypt_data(self, data: Union[str, bytes], 
                          key_id: str = 'aes_256') -> EncryptedData:
        """λ°μ΄ν„° μ•”νΈν™”"""
        start_time = time.time()
        
        try:
            with self.lock:
                # ν‚¤ κ²€μ¦
                if key_id not in self.keys or not self.keys[key_id].is_active:
                    raise ValueError(f"Invalid or inactive key: {key_id}")
                
                key = self.keys[key_id]
                
                # λ°μ΄ν„°λ¥Ό bytesλ΅ λ³€ν™
                if isinstance(data, str):
                    data_bytes = data.encode('utf-8')
                else:
                    data_bytes = data
                
                # IV μƒμ„±
                iv = os.urandom(16)  # 128-bit IV
                
                # AES-256-GCM μ•”νΈν™”
                cipher = Cipher(
                    algorithms.AES(key.key_data),
                    modes.GCM(iv),
                    backend=default_backend()
                )
                encryptor = cipher.encryptor()
                
                # μ•”νΈν™” μ‹¤ν–‰
                encrypted_data = encryptor.update(data_bytes) + encryptor.finalize()
                auth_tag = encryptor.tag
                
                # μ‚¬μ©λ‰ μ¦κ°€
                key.usage_count += 1
                
                # μ„±λ¥ μΈ΅μ •
                encryption_time = (time.time() - start_time) * 1000
                self.performance_metrics.record_encryption_time(encryption_time)
                
                # μ•”νΈν™”λ λ°μ΄ν„° κ°μ²΄ μƒμ„±
                encrypted_obj = EncryptedData(
                    data_id=self._generate_data_id(),
                    encrypted_data=encrypted_data,
                    key_id=key_id,
                    algorithm='AES-256-GCM',
                    iv=iv,
                    auth_tag=auth_tag,
                    created_at=datetime.now(),
                    metadata={
                        'original_size': len(data_bytes),
                        'encrypted_size': len(encrypted_data),
                        'compression_ratio': len(encrypted_data) / len(data_bytes)
                    }
                )
                
                logger.info(f"Data encrypted successfully: {encrypted_obj.data_id}")
                return encrypted_obj
                
        except Exception as e:
            logger.error(f"Encryption failed: {e}")
            raise
    
    async def decrypt_data(self, encrypted_data: EncryptedData) -> bytes:
        """λ°μ΄ν„° λ³µνΈν™”"""
        start_time = time.time()
        
        try:
            with self.lock:
                # ν‚¤ κ²€μ¦
                if encrypted_data.key_id not in self.keys:
                    raise ValueError(f"Key not found: {encrypted_data.key_id}")
                
                key = self.keys[encrypted_data.key_id]
                
                # AES-256-GCM λ³µνΈν™”
                cipher = Cipher(
                    algorithms.AES(key.key_data),
                    modes.GCM(encrypted_data.iv, encrypted_data.auth_tag),
                    backend=default_backend()
                )
                decryptor = cipher.decryptor()
                
                # λ³µνΈν™” μ‹¤ν–‰
                decrypted_data = decryptor.update(encrypted_data.encrypted_data) + decryptor.finalize()
                
                # μ„±λ¥ μΈ΅μ •
                decryption_time = (time.time() - start_time) * 1000
                self.performance_metrics.record_decryption_time(decryption_time)
                
                logger.info(f"Data decrypted successfully: {encrypted_data.data_id}")
                return decrypted_data
                
        except Exception as e:
            logger.error(f"Decryption failed: {e}")
            raise
    
    def _generate_data_id(self) -> str:
        """λ°μ΄ν„° ID μƒμ„±"""
        return hashlib.sha256(os.urandom(32)).hexdigest()[:16]
    
    def rotate_keys(self):
        """ν‚¤ μν™"""
        with self.lock:
            # μƒ ν‚¤ μƒμ„±
            new_aes_key = self._generate_aes_key()
            
            # κΈ°μ΅΄ ν‚¤ λΉ„ν™μ„±ν™”
            if 'aes_256' in self.keys:
                self.keys['aes_256'].is_active = False
                self.keys['aes_256'].expires_at = datetime.now()
            
            # μƒ ν‚¤ λ“±λ΅
            self.keys['aes_256_new'] = EncryptionKey(
                key_id='aes_256_new',
                key_type='symmetric',
                algorithm='AES-256',
                key_data=new_aes_key,
                created_at=datetime.now(),
                expires_at=datetime.now() + timedelta(days=90),
                usage_count=0,
                is_active=True
            )
            
            logger.info("Key rotation completed")
    
    def get_key_info(self, key_id: str) -> Optional[EncryptionKey]:
        """ν‚¤ μ •λ³΄ μ΅°ν"""
        return self.keys.get(key_id)
    
    def get_all_keys(self) -> List[EncryptionKey]:
        """λ¨λ“  ν‚¤ μ΅°ν"""
        return list(self.keys.values())

class EncryptionMetrics:
    """μ•”νΈν™” μ„±λ¥ λ©”νΈλ¦­"""
    
    def __init__(self):
        self.encryption_times = []
        self.decryption_times = []
        self.start_time = time.time()
    
    def record_encryption_time(self, time_ms: float):
        """μ•”νΈν™” μ‹κ°„ κΈ°λ΅"""
        self.encryption_times.append(time_ms)
        if len(self.encryption_times) > 1000:
            self.encryption_times = self.encryption_times[-1000:]
    
    def record_decryption_time(self, time_ms: float):
        """λ³µνΈν™” μ‹κ°„ κΈ°λ΅"""
        self.decryption_times.append(time_ms)
        if len(self.decryption_times) > 1000:
            self.decryption_times = self.decryption_times[-1000:]
    
    def get_metrics(self) -> Dict[str, Any]:
        """λ©”νΈλ¦­ μ΅°ν"""
        return {
            'avg_encryption_time_ms': np.mean(self.encryption_times) if self.encryption_times else 0,
            'avg_decryption_time_ms': np.mean(self.decryption_times) if self.decryption_times else 0,
            'max_encryption_time_ms': np.max(self.encryption_times) if self.encryption_times else 0,
            'max_decryption_time_ms': np.max(self.decryption_times) if self.decryption_times else 0,
            'total_encryptions': len(self.encryption_times),
            'total_decryptions': len(self.decryption_times),
            'uptime_seconds': time.time() - self.start_time
        }
```

## π”§ **λ°μ΄ν„° μµλ…ν™” μ‹μ¤ν…**

### π“¦ **λ°μ΄ν„° λ§μ¤ν‚Ή λ° κ°€λ…ν™”**

```python
# data-protection/anonymization/data_anonymizer.py
import asyncio
import time
import logging
from typing import Dict, List, Tuple, Optional, Any, Union
from dataclasses import dataclass
from datetime import datetime, timedelta
import re
import hashlib
import uuid
import random
import string
from cryptography.fernet import Fernet
import threading
from collections import defaultdict

logger = logging.getLogger(__name__)

@dataclass
class AnonymizationRule:
    """μµλ…ν™” κ·μΉ™"""
    rule_id: str
    field_name: str
    data_type: str  # 'email', 'phone', 'ssn', 'credit_card', 'name'
    anonymization_method: str  # 'masking', 'hashing', 'generalization', 'suppression'
    parameters: Dict[str, Any]
    is_active: bool

@dataclass
class AnonymizedData:
    """μµλ…ν™”λ λ°μ΄ν„°"""
    original_data: Dict[str, Any]
    anonymized_data: Dict[str, Any]
    anonymization_rules: List[str]
    created_at: datetime
    metadata: Dict[str, Any]

class DataAnonymizer:
    """λ°μ΄ν„° μµλ…ν™”κΈ°"""
    
    def __init__(self):
        self.rules = self._initialize_rules()
        self.pseudonym_mapping = {}
        self.performance_metrics = AnonymizationMetrics()
        self.lock = threading.Lock()
        
        logger.info("Data anonymizer initialized")
    
    def _initialize_rules(self) -> Dict[str, AnonymizationRule]:
        """μµλ…ν™” κ·μΉ™ μ΄κΈ°ν™”"""
        rules = {
            'email_masking': AnonymizationRule(
                rule_id='email_masking',
                field_name='email',
                data_type='email',
                anonymization_method='masking',
                parameters={'mask_char': '*', 'preserve_domain': True},
                is_active=True
            ),
            'phone_masking': AnonymizationRule(
                rule_id='phone_masking',
                field_name='phone',
                data_type='phone',
                anonymization_method='masking',
                parameters={'mask_char': '*', 'preserve_country_code': True},
                is_active=True
            ),
            'ssn_masking': AnonymizationRule(
                rule_id='ssn_masking',
                field_name='ssn',
                data_type='ssn',
                anonymization_method='masking',
                parameters={'mask_char': '*', 'preserve_last_four': True},
                is_active=True
            ),
            'credit_card_masking': AnonymizationRule(
                rule_id='credit_card_masking',
                field_name='credit_card',
                data_type='credit_card',
                anonymization_method='masking',
                parameters={'mask_char': '*', 'preserve_last_four': True},
                is_active=True
            ),
            'name_hashing': AnonymizationRule(
                rule_id='name_hashing',
                field_name='name',
                data_type='name',
                anonymization_method='hashing',
                parameters={'hash_algorithm': 'sha256', 'salt_length': 16},
                is_active=True
            ),
            'address_generalization': AnonymizationRule(
                rule_id='address_generalization',
                field_name='address',
                data_type='address',
                anonymization_method='generalization',
                parameters={'generalization_level': 'city'},
                is_active=True
            )
        }
        
        return rules
    
    async def anonymize_data(self, data: Dict[str, Any]) -> AnonymizedData:
        """λ°μ΄ν„° μµλ…ν™”"""
        start_time = time.time()
        
        try:
            with self.lock:
                anonymized_data = {}
                applied_rules = []
                
                for field_name, field_value in data.items():
                    # ν•΄λ‹Ή ν•„λ“μ— λ€ν• μµλ…ν™” κ·μΉ™ μ°ΎκΈ°
                    rule = self._find_rule_for_field(field_name)
                    
                    if rule and rule.is_active:
                        # μµλ…ν™” μ μ©
                        anonymized_value = await self._apply_anonymization(
                            field_value, rule
                        )
                        anonymized_data[field_name] = anonymized_value
                        applied_rules.append(rule.rule_id)
                    else:
                        # κ·μΉ™μ΄ μ—†μΌλ©΄ μ›λ³Έ μ μ§€
                        anonymized_data[field_name] = field_value
                
                # μ„±λ¥ μΈ΅μ •
                anonymization_time = (time.time() - start_time) * 1000
                self.performance_metrics.record_anonymization_time(anonymization_time)
                
                # μµλ…ν™”λ λ°μ΄ν„° κ°μ²΄ μƒμ„±
                result = AnonymizedData(
                    original_data=data,
                    anonymized_data=anonymized_data,
                    anonymization_rules=applied_rules,
                    created_at=datetime.now(),
                    metadata={
                        'original_size': len(str(data)),
                        'anonymized_size': len(str(anonymized_data)),
                        'fields_anonymized': len(applied_rules)
                    }
                )
                
                logger.info(f"Data anonymized successfully: {len(applied_rules)} fields")
                return result
                
        except Exception as e:
            logger.error(f"Data anonymization failed: {e}")
            raise
    
    def _find_rule_for_field(self, field_name: str) -> Optional[AnonymizationRule]:
        """ν•„λ“μ— λ€ν• μµλ…ν™” κ·μΉ™ μ°ΎκΈ°"""
        for rule in self.rules.values():
            if rule.field_name == field_name:
                return rule
        return None
    
    async def _apply_anonymization(self, value: Any, rule: AnonymizationRule) -> Any:
        """μµλ…ν™” μ μ©"""
        if rule.anonymization_method == 'masking':
            return self._apply_masking(value, rule)
        elif rule.anonymization_method == 'hashing':
            return self._apply_hashing(value, rule)
        elif rule.anonymization_method == 'generalization':
            return self._apply_generalization(value, rule)
        elif rule.anonymization_method == 'suppression':
            return self._apply_suppression(value, rule)
        else:
            return value
    
    def _apply_masking(self, value: str, rule: AnonymizationRule) -> str:
        """λ§μ¤ν‚Ή μ μ©"""
        if not isinstance(value, str):
            return value
        
        mask_char = rule.parameters.get('mask_char', '*')
        
        if rule.data_type == 'email':
            return self._mask_email(value, mask_char, rule.parameters.get('preserve_domain', True))
        elif rule.data_type == 'phone':
            return self._mask_phone(value, mask_char, rule.parameters.get('preserve_country_code', True))
        elif rule.data_type == 'ssn':
            return self._mask_ssn(value, mask_char, rule.parameters.get('preserve_last_four', True))
        elif rule.data_type == 'credit_card':
            return self._mask_credit_card(value, mask_char, rule.parameters.get('preserve_last_four', True))
        else:
            return self._mask_general(value, mask_char)
    
    def _mask_email(self, email: str, mask_char: str, preserve_domain: bool) -> str:
        """μ΄λ©”μΌ λ§μ¤ν‚Ή"""
        if '@' not in email:
            return mask_char * len(email)
        
        local_part, domain = email.split('@', 1)
        
        if len(local_part) <= 2:
            masked_local = local_part
        else:
            masked_local = local_part[0] + mask_char * (len(local_part) - 2) + local_part[-1]
        
        if preserve_domain:
            return f"{masked_local}@{domain}"
        else:
            return f"{masked_local}@{mask_char * len(domain)}"
    
    def _mask_phone(self, phone: str, mask_char: str, preserve_country_code: bool) -> str:
        """μ „ν™”λ²νΈ λ§μ¤ν‚Ή"""
        # μ«μλ§ μ¶”μ¶
        digits = re.sub(r'\D', '', phone)
        
        if len(digits) < 4:
            return mask_char * len(phone)
        
        if preserve_country_code and len(digits) > 7:
            # κµ­κ°€ μ½”λ“ λ³΄μ΅΄
            country_code = digits[:len(digits) - 7]
            masked_number = mask_char * (len(digits) - 7 - 4) + digits[-4:]
            return f"+{country_code}-{masked_number}"
        else:
            # λ§μ§€λ§‰ 4μλ¦¬λ§ λ³΄μ΅΄
            masked_number = mask_char * (len(digits) - 4) + digits[-4:]
            return masked_number
    
    def _mask_ssn(self, ssn: str, mask_char: str, preserve_last_four: bool) -> str:
        """μ£Όλ―Όλ“±λ΅λ²νΈ λ§μ¤ν‚Ή"""
        # μ«μλ§ μ¶”μ¶
        digits = re.sub(r'\D', '', ssn)
        
        if len(digits) != 13:
            return mask_char * len(ssn)
        
        if preserve_last_four:
            return f"{mask_char * 6}-{mask_char * 3}{digits[-4:]}"
        else:
            return f"{mask_char * 6}-{mask_char * 7}"
    
    def _mask_credit_card(self, card: str, mask_char: str, preserve_last_four: bool) -> str:
        """μ‹ μ©μΉ΄λ“ λ§μ¤ν‚Ή"""
        # μ«μλ§ μ¶”μ¶
        digits = re.sub(r'\D', '', card)
        
        if len(digits) < 4:
            return mask_char * len(card)
        
        if preserve_last_four:
            return f"{mask_char * (len(digits) - 4)}{digits[-4:]}"
        else:
            return mask_char * len(digits)
    
    def _mask_general(self, value: str, mask_char: str) -> str:
        """μΌλ° λ§μ¤ν‚Ή"""
        if len(value) <= 2:
            return value
        return value[0] + mask_char * (len(value) - 2) + value[-1]
    
    def _apply_hashing(self, value: str, rule: AnonymizationRule) -> str:
        """ν•΄μ‹± μ μ©"""
        if not isinstance(value, str):
            return str(value)
        
        hash_algorithm = rule.parameters.get('hash_algorithm', 'sha256')
        salt_length = rule.parameters.get('salt_length', 16)
        
        # μ†”νΈ μƒμ„±
        salt = ''.join(random.choices(string.ascii_letters + string.digits, k=salt_length))
        
        # ν•΄μ‹±
        if hash_algorithm == 'sha256':
            hash_obj = hashlib.sha256()
            hash_obj.update((value + salt).encode('utf-8'))
            return hash_obj.hexdigest()
        else:
            return hashlib.md5((value + salt).encode('utf-8')).hexdigest()
    
    def _apply_generalization(self, value: str, rule: AnonymizationRule) -> str:
        """μΌλ°ν™” μ μ©"""
        generalization_level = rule.parameters.get('generalization_level', 'city')
        
        if rule.data_type == 'address':
            return self._generalize_address(value, generalization_level)
        else:
            return value
    
    def _generalize_address(self, address: str, level: str) -> str:
        """μ£Όμ† μΌλ°ν™”"""
        # μ‹¤μ  κµ¬ν„μ—μ„λ” μ£Όμ† νμ‹± λΌμ΄λΈλ¬λ¦¬ μ‚¬μ©
        if level == 'city':
            # λ„μ‹ μμ¤€μΌλ΅ μΌλ°ν™”
            parts = address.split(',')
            if len(parts) >= 2:
                return parts[-2].strip()  # λ„μ‹ λ¶€λ¶„
            return address
        elif level == 'state':
            # μ£Ό/λ„ μμ¤€μΌλ΅ μΌλ°ν™”
            parts = address.split(',')
            if len(parts) >= 3:
                return parts[-3].strip()  # μ£Ό/λ„ λ¶€λ¶„
            return address
        else:
            return address
    
    def _apply_suppression(self, value: Any, rule: AnonymizationRule) -> None:
        """μ–µμ  μ μ©"""
        return None
    
    def add_rule(self, rule: AnonymizationRule):
        """μµλ…ν™” κ·μΉ™ μ¶”κ°€"""
        with self.lock:
            self.rules[rule.rule_id] = rule
            logger.info(f"Anonymization rule added: {rule.rule_id}")
    
    def update_rule(self, rule_id: str, updates: Dict[str, Any]):
        """μµλ…ν™” κ·μΉ™ μ—…λ°μ΄νΈ"""
        with self.lock:
            if rule_id in self.rules:
                rule = self.rules[rule_id]
                for key, value in updates.items():
                    if hasattr(rule, key):
                        setattr(rule, key, value)
                logger.info(f"Anonymization rule updated: {rule_id}")
    
    def get_rule(self, rule_id: str) -> Optional[AnonymizationRule]:
        """μµλ…ν™” κ·μΉ™ μ΅°ν"""
        return self.rules.get(rule_id)
    
    def get_all_rules(self) -> List[AnonymizationRule]:
        """λ¨λ“  μµλ…ν™” κ·μΉ™ μ΅°ν"""
        return list(self.rules.values())

class AnonymizationMetrics:
    """μµλ…ν™” μ„±λ¥ λ©”νΈλ¦­"""
    
    def __init__(self):
        self.anonymization_times = []
        self.start_time = time.time()
    
    def record_anonymization_time(self, time_ms: float):
        """μµλ…ν™” μ‹κ°„ κΈ°λ΅"""
        self.anonymization_times.append(time_ms)
        if len(self.anonymization_times) > 1000:
            self.anonymization_times = self.anonymization_times[-1000:]
    
    def get_metrics(self) -> Dict[str, Any]:
        """λ©”νΈλ¦­ μ΅°ν"""
        return {
            'avg_anonymization_time_ms': np.mean(self.anonymization_times) if self.anonymization_times else 0,
            'max_anonymization_time_ms': np.max(self.anonymization_times) if self.anonymization_times else 0,
            'total_anonymizations': len(self.anonymization_times),
            'uptime_seconds': time.time() - self.start_time
        }
```

## π― **λ‹¤μ λ‹¨κ³„**

### π“‹ **μ™„λ£λ μ‘μ—…**
- β… μ‹¤μ‹κ°„ μ„ν— ν‰κ°€ μ‹μ¤ν… μ„¤κ³„ (ν¬νΈν΄λ¦¬μ¤ μ„ν—, μ‹μ¥ μ„ν—)
- β… μ¤νΈλ μ¤ ν…μ¤νΈ μ‹μ¤ν… μ„¤κ³„ (μ‹λ‚λ¦¬μ¤ κΈ°λ°, λ³‘λ ¬ μ‹¤ν–‰)
- β… μ„ν— ν•λ„ κ΄€λ¦¬ μ‹μ¤ν… μ„¤κ³„
- β… λ€μΉ­ν‚¤ μ•”νΈν™” μ‹μ¤ν… μ„¤κ³„ (AES-256-GCM)
- β… λ°μ΄ν„° μµλ…ν™” μ‹μ¤ν… μ„¤κ³„ (λ§μ¤ν‚Ή, ν•΄μ‹±, μΌλ°ν™”)

### π”„ **μ§„ν–‰ μ¤‘μΈ μ‘μ—…**
- π”„ μ ‘κ·Ό μ μ–΄ μ‹μ¤ν… (RBAC, ABAC, λ™μ  μ ‘κ·Ό μ μ–΄)
- π”„ λ°μ΄ν„° λ¶„λ¥ μ‹μ¤ν… (μλ™ λ¶„λ¥, λ―Όκ°λ„ μμ¤€)

### β³ **λ‹¤μ λ‹¨κ³„**
1. **μ ‘κ·Ό μ μ–΄ μ‹μ¤ν…** λ¬Έμ„ μƒμ„±
2. **λ°μ΄ν„° λ¶„λ¥ μ‹μ¤ν…** λ¬Έμ„ μƒμ„±
3. **κ°μΈμ •λ³΄ λ³΄νΈ μ‹μ¤ν…** λ¬Έμ„ μƒμ„±

---

**λ§μ§€λ§‰ μ—…λ°μ΄νΈ**: 2024-01-31
**λ‹¤μ μ—…λ°μ΄νΈ**: 2024-02-01 (μ ‘κ·Ό μ μ–΄ μ‹μ¤ν…)
**λ°μ΄ν„° λ³΄νΈ λ©ν‘**: < 10ms μ•”νΈν™”, < 50ms μµλ…ν™”, 100% κ·μ • μ¤€μ
**λ°μ΄ν„° λ³΄νΈ μ„±κ³Ό**: AES-256 μ•”νΈν™”, λ°μ΄ν„° μµλ…ν™”, μ ‘κ·Ό μ μ–΄ 