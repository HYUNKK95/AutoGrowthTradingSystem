# 🔒 Phase 6.2: 데이터 보호 시스템

## 📋 **개요**

### 🎯 **목표**
- **데이터 암호화**: 저장 및 전송 시 AES-256, RSA-4096 암호화
- **데이터 익명화**: PII 데이터 익명화 및 가명화
- **접근 제어**: 세밀한 권한 관리, RBAC, ABAC
- **데이터 분류**: 민감도별 데이터 분류 및 처리
- **개인정보 보호**: GDPR, CCPA 완전 준수

### 📊 **성능 목표**
- **암호화 성능**: < 10ms 암호화/복호화
- **익명화 성능**: < 50ms 데이터 익명화
- **접근 제어**: < 5ms 권한 검증
- **데이터 분류**: < 100ms 자동 분류
- **개인정보 보호**: 100% 규정 준수

## 🏗️ **데이터 보호 시스템 아키텍처**

### 📁 **데이터 보호 시스템 구조**
```
data-protection/
├── encryption/                        # 암호화 시스템
│   ├── symmetric-encryption/          # 대칭키 암호화
│   ├── asymmetric-encryption/         # 비대칭키 암호화
│   ├── key-management/                # 키 관리
│   └── hardware-security/             # 하드웨어 보안
├── anonymization/                     # 익명화 시스템
│   ├── data-masking/                  # 데이터 마스킹
│   ├── pseudonymization/              # 가명화
│   ├── generalization/                # 일반화
│   └── suppression/                   # 억제
├── access-control/                    # 접근 제어
│   ├── rbac/                          # 역할 기반 접근 제어
│   ├── abac/                          # 속성 기반 접근 제어
│   ├── dynamic-access/                # 동적 접근 제어
│   └── session-management/            # 세션 관리
├── data-classification/               # 데이터 분류
│   ├── automatic-classification/      # 자동 분류
│   ├── sensitivity-levels/            # 민감도 수준
│   ├── classification-rules/          # 분류 규칙
│   └── compliance-checking/           # 규정 준수 확인
└── privacy-protection/                # 개인정보 보호
    ├── gdpr-compliance/               # GDPR 준수
    ├── ccpa-compliance/               # CCPA 준수
    ├── data-subject-rights/           # 데이터 주체 권리
    └── consent-management/            # 동의 관리
```

## 🔧 **암호화 시스템**

### 📦 **대칭키 암호화 (AES-256)**

```python
# data-protection/encryption/symmetric_encryption.py
import asyncio
import time
import logging
from typing import Dict, List, Tuple, Optional, Any, Union
from dataclasses import dataclass
from datetime import datetime, timedelta
import os
import base64
import hashlib
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
import threading
from collections import defaultdict

logger = logging.getLogger(__name__)

@dataclass
class EncryptionKey:
    """암호화 키 정보"""
    key_id: str
    key_type: str  # 'symmetric', 'asymmetric'
    algorithm: str  # 'AES-256', 'RSA-4096'
    key_data: bytes
    created_at: datetime
    expires_at: Optional[datetime]
    usage_count: int
    is_active: bool

@dataclass
class EncryptedData:
    """암호화된 데이터"""
    data_id: str
    encrypted_data: bytes
    key_id: str
    algorithm: str
    iv: bytes
    auth_tag: Optional[bytes]
    created_at: datetime
    metadata: Dict[str, Any]

class SymmetricEncryptionManager:
    """대칭키 암호화 관리자"""
    
    def __init__(self):
        self.keys = {}
        self.key_cache = {}
        self.performance_metrics = EncryptionMetrics()
        self.lock = threading.Lock()
        
        # 키 생성 및 관리
        self._initialize_keys()
        
        logger.info("Symmetric encryption manager initialized")
    
    def _initialize_keys(self):
        """초기 키 생성"""
        # 마스터 키 생성
        master_key = self._generate_master_key()
        
        # AES-256 키 생성
        aes_key = self._generate_aes_key()
        
        # 키 저장
        self.keys['master'] = EncryptionKey(
            key_id='master',
            key_type='symmetric',
            algorithm='AES-256',
            key_data=master_key,
            created_at=datetime.now(),
            expires_at=datetime.now() + timedelta(days=365),
            usage_count=0,
            is_active=True
        )
        
        self.keys['aes_256'] = EncryptionKey(
            key_id='aes_256',
            key_type='symmetric',
            algorithm='AES-256',
            key_data=aes_key,
            created_at=datetime.now(),
            expires_at=datetime.now() + timedelta(days=90),
            usage_count=0,
            is_active=True
        )
    
    def _generate_master_key(self) -> bytes:
        """마스터 키 생성"""
        return os.urandom(32)  # 256-bit
    
    def _generate_aes_key(self) -> bytes:
        """AES 키 생성"""
        return os.urandom(32)  # 256-bit
    
    async def encrypt_data(self, data: Union[str, bytes], 
                          key_id: str = 'aes_256') -> EncryptedData:
        """데이터 암호화"""
        start_time = time.time()
        
        try:
            with self.lock:
                # 키 검증
                if key_id not in self.keys or not self.keys[key_id].is_active:
                    raise ValueError(f"Invalid or inactive key: {key_id}")
                
                key = self.keys[key_id]
                
                # 데이터를 bytes로 변환
                if isinstance(data, str):
                    data_bytes = data.encode('utf-8')
                else:
                    data_bytes = data
                
                # IV 생성
                iv = os.urandom(16)  # 128-bit IV
                
                # AES-256-GCM 암호화
                cipher = Cipher(
                    algorithms.AES(key.key_data),
                    modes.GCM(iv),
                    backend=default_backend()
                )
                encryptor = cipher.encryptor()
                
                # 암호화 실행
                encrypted_data = encryptor.update(data_bytes) + encryptor.finalize()
                auth_tag = encryptor.tag
                
                # 사용량 증가
                key.usage_count += 1
                
                # 성능 측정
                encryption_time = (time.time() - start_time) * 1000
                self.performance_metrics.record_encryption_time(encryption_time)
                
                # 암호화된 데이터 객체 생성
                encrypted_obj = EncryptedData(
                    data_id=self._generate_data_id(),
                    encrypted_data=encrypted_data,
                    key_id=key_id,
                    algorithm='AES-256-GCM',
                    iv=iv,
                    auth_tag=auth_tag,
                    created_at=datetime.now(),
                    metadata={
                        'original_size': len(data_bytes),
                        'encrypted_size': len(encrypted_data),
                        'compression_ratio': len(encrypted_data) / len(data_bytes)
                    }
                )
                
                logger.info(f"Data encrypted successfully: {encrypted_obj.data_id}")
                return encrypted_obj
                
        except Exception as e:
            logger.error(f"Encryption failed: {e}")
            raise
    
    async def decrypt_data(self, encrypted_data: EncryptedData) -> bytes:
        """데이터 복호화"""
        start_time = time.time()
        
        try:
            with self.lock:
                # 키 검증
                if encrypted_data.key_id not in self.keys:
                    raise ValueError(f"Key not found: {encrypted_data.key_id}")
                
                key = self.keys[encrypted_data.key_id]
                
                # AES-256-GCM 복호화
                cipher = Cipher(
                    algorithms.AES(key.key_data),
                    modes.GCM(encrypted_data.iv, encrypted_data.auth_tag),
                    backend=default_backend()
                )
                decryptor = cipher.decryptor()
                
                # 복호화 실행
                decrypted_data = decryptor.update(encrypted_data.encrypted_data) + decryptor.finalize()
                
                # 성능 측정
                decryption_time = (time.time() - start_time) * 1000
                self.performance_metrics.record_decryption_time(decryption_time)
                
                logger.info(f"Data decrypted successfully: {encrypted_data.data_id}")
                return decrypted_data
                
        except Exception as e:
            logger.error(f"Decryption failed: {e}")
            raise
    
    def _generate_data_id(self) -> str:
        """데이터 ID 생성"""
        return hashlib.sha256(os.urandom(32)).hexdigest()[:16]
    
    def rotate_keys(self):
        """키 순환"""
        with self.lock:
            # 새 키 생성
            new_aes_key = self._generate_aes_key()
            
            # 기존 키 비활성화
            if 'aes_256' in self.keys:
                self.keys['aes_256'].is_active = False
                self.keys['aes_256'].expires_at = datetime.now()
            
            # 새 키 등록
            self.keys['aes_256_new'] = EncryptionKey(
                key_id='aes_256_new',
                key_type='symmetric',
                algorithm='AES-256',
                key_data=new_aes_key,
                created_at=datetime.now(),
                expires_at=datetime.now() + timedelta(days=90),
                usage_count=0,
                is_active=True
            )
            
            logger.info("Key rotation completed")
    
    def get_key_info(self, key_id: str) -> Optional[EncryptionKey]:
        """키 정보 조회"""
        return self.keys.get(key_id)
    
    def get_all_keys(self) -> List[EncryptionKey]:
        """모든 키 조회"""
        return list(self.keys.values())

class EncryptionMetrics:
    """암호화 성능 메트릭"""
    
    def __init__(self):
        self.encryption_times = []
        self.decryption_times = []
        self.start_time = time.time()
    
    def record_encryption_time(self, time_ms: float):
        """암호화 시간 기록"""
        self.encryption_times.append(time_ms)
        if len(self.encryption_times) > 1000:
            self.encryption_times = self.encryption_times[-1000:]
    
    def record_decryption_time(self, time_ms: float):
        """복호화 시간 기록"""
        self.decryption_times.append(time_ms)
        if len(self.decryption_times) > 1000:
            self.decryption_times = self.decryption_times[-1000:]
    
    def get_metrics(self) -> Dict[str, Any]:
        """메트릭 조회"""
        return {
            'avg_encryption_time_ms': np.mean(self.encryption_times) if self.encryption_times else 0,
            'avg_decryption_time_ms': np.mean(self.decryption_times) if self.decryption_times else 0,
            'max_encryption_time_ms': np.max(self.encryption_times) if self.encryption_times else 0,
            'max_decryption_time_ms': np.max(self.decryption_times) if self.decryption_times else 0,
            'total_encryptions': len(self.encryption_times),
            'total_decryptions': len(self.decryption_times),
            'uptime_seconds': time.time() - self.start_time
        }
```

## 🔧 **데이터 익명화 시스템**

### 📦 **데이터 마스킹 및 가명화**

```python
# data-protection/anonymization/data_anonymizer.py
import asyncio
import time
import logging
from typing import Dict, List, Tuple, Optional, Any, Union
from dataclasses import dataclass
from datetime import datetime, timedelta
import re
import hashlib
import uuid
import random
import string
from cryptography.fernet import Fernet
import threading
from collections import defaultdict

logger = logging.getLogger(__name__)

@dataclass
class AnonymizationRule:
    """익명화 규칙"""
    rule_id: str
    field_name: str
    data_type: str  # 'email', 'phone', 'ssn', 'credit_card', 'name'
    anonymization_method: str  # 'masking', 'hashing', 'generalization', 'suppression'
    parameters: Dict[str, Any]
    is_active: bool

@dataclass
class AnonymizedData:
    """익명화된 데이터"""
    original_data: Dict[str, Any]
    anonymized_data: Dict[str, Any]
    anonymization_rules: List[str]
    created_at: datetime
    metadata: Dict[str, Any]

class DataAnonymizer:
    """데이터 익명화기"""
    
    def __init__(self):
        self.rules = self._initialize_rules()
        self.pseudonym_mapping = {}
        self.performance_metrics = AnonymizationMetrics()
        self.lock = threading.Lock()
        
        logger.info("Data anonymizer initialized")
    
    def _initialize_rules(self) -> Dict[str, AnonymizationRule]:
        """익명화 규칙 초기화"""
        rules = {
            'email_masking': AnonymizationRule(
                rule_id='email_masking',
                field_name='email',
                data_type='email',
                anonymization_method='masking',
                parameters={'mask_char': '*', 'preserve_domain': True},
                is_active=True
            ),
            'phone_masking': AnonymizationRule(
                rule_id='phone_masking',
                field_name='phone',
                data_type='phone',
                anonymization_method='masking',
                parameters={'mask_char': '*', 'preserve_country_code': True},
                is_active=True
            ),
            'ssn_masking': AnonymizationRule(
                rule_id='ssn_masking',
                field_name='ssn',
                data_type='ssn',
                anonymization_method='masking',
                parameters={'mask_char': '*', 'preserve_last_four': True},
                is_active=True
            ),
            'credit_card_masking': AnonymizationRule(
                rule_id='credit_card_masking',
                field_name='credit_card',
                data_type='credit_card',
                anonymization_method='masking',
                parameters={'mask_char': '*', 'preserve_last_four': True},
                is_active=True
            ),
            'name_hashing': AnonymizationRule(
                rule_id='name_hashing',
                field_name='name',
                data_type='name',
                anonymization_method='hashing',
                parameters={'hash_algorithm': 'sha256', 'salt_length': 16},
                is_active=True
            ),
            'address_generalization': AnonymizationRule(
                rule_id='address_generalization',
                field_name='address',
                data_type='address',
                anonymization_method='generalization',
                parameters={'generalization_level': 'city'},
                is_active=True
            )
        }
        
        return rules
    
    async def anonymize_data(self, data: Dict[str, Any]) -> AnonymizedData:
        """데이터 익명화"""
        start_time = time.time()
        
        try:
            with self.lock:
                anonymized_data = {}
                applied_rules = []
                
                for field_name, field_value in data.items():
                    # 해당 필드에 대한 익명화 규칙 찾기
                    rule = self._find_rule_for_field(field_name)
                    
                    if rule and rule.is_active:
                        # 익명화 적용
                        anonymized_value = await self._apply_anonymization(
                            field_value, rule
                        )
                        anonymized_data[field_name] = anonymized_value
                        applied_rules.append(rule.rule_id)
                    else:
                        # 규칙이 없으면 원본 유지
                        anonymized_data[field_name] = field_value
                
                # 성능 측정
                anonymization_time = (time.time() - start_time) * 1000
                self.performance_metrics.record_anonymization_time(anonymization_time)
                
                # 익명화된 데이터 객체 생성
                result = AnonymizedData(
                    original_data=data,
                    anonymized_data=anonymized_data,
                    anonymization_rules=applied_rules,
                    created_at=datetime.now(),
                    metadata={
                        'original_size': len(str(data)),
                        'anonymized_size': len(str(anonymized_data)),
                        'fields_anonymized': len(applied_rules)
                    }
                )
                
                logger.info(f"Data anonymized successfully: {len(applied_rules)} fields")
                return result
                
        except Exception as e:
            logger.error(f"Data anonymization failed: {e}")
            raise
    
    def _find_rule_for_field(self, field_name: str) -> Optional[AnonymizationRule]:
        """필드에 대한 익명화 규칙 찾기"""
        for rule in self.rules.values():
            if rule.field_name == field_name:
                return rule
        return None
    
    async def _apply_anonymization(self, value: Any, rule: AnonymizationRule) -> Any:
        """익명화 적용"""
        if rule.anonymization_method == 'masking':
            return self._apply_masking(value, rule)
        elif rule.anonymization_method == 'hashing':
            return self._apply_hashing(value, rule)
        elif rule.anonymization_method == 'generalization':
            return self._apply_generalization(value, rule)
        elif rule.anonymization_method == 'suppression':
            return self._apply_suppression(value, rule)
        else:
            return value
    
    def _apply_masking(self, value: str, rule: AnonymizationRule) -> str:
        """마스킹 적용"""
        if not isinstance(value, str):
            return value
        
        mask_char = rule.parameters.get('mask_char', '*')
        
        if rule.data_type == 'email':
            return self._mask_email(value, mask_char, rule.parameters.get('preserve_domain', True))
        elif rule.data_type == 'phone':
            return self._mask_phone(value, mask_char, rule.parameters.get('preserve_country_code', True))
        elif rule.data_type == 'ssn':
            return self._mask_ssn(value, mask_char, rule.parameters.get('preserve_last_four', True))
        elif rule.data_type == 'credit_card':
            return self._mask_credit_card(value, mask_char, rule.parameters.get('preserve_last_four', True))
        else:
            return self._mask_general(value, mask_char)
    
    def _mask_email(self, email: str, mask_char: str, preserve_domain: bool) -> str:
        """이메일 마스킹"""
        if '@' not in email:
            return mask_char * len(email)
        
        local_part, domain = email.split('@', 1)
        
        if len(local_part) <= 2:
            masked_local = local_part
        else:
            masked_local = local_part[0] + mask_char * (len(local_part) - 2) + local_part[-1]
        
        if preserve_domain:
            return f"{masked_local}@{domain}"
        else:
            return f"{masked_local}@{mask_char * len(domain)}"
    
    def _mask_phone(self, phone: str, mask_char: str, preserve_country_code: bool) -> str:
        """전화번호 마스킹"""
        # 숫자만 추출
        digits = re.sub(r'\D', '', phone)
        
        if len(digits) < 4:
            return mask_char * len(phone)
        
        if preserve_country_code and len(digits) > 7:
            # 국가 코드 보존
            country_code = digits[:len(digits) - 7]
            masked_number = mask_char * (len(digits) - 7 - 4) + digits[-4:]
            return f"+{country_code}-{masked_number}"
        else:
            # 마지막 4자리만 보존
            masked_number = mask_char * (len(digits) - 4) + digits[-4:]
            return masked_number
    
    def _mask_ssn(self, ssn: str, mask_char: str, preserve_last_four: bool) -> str:
        """주민등록번호 마스킹"""
        # 숫자만 추출
        digits = re.sub(r'\D', '', ssn)
        
        if len(digits) != 13:
            return mask_char * len(ssn)
        
        if preserve_last_four:
            return f"{mask_char * 6}-{mask_char * 3}{digits[-4:]}"
        else:
            return f"{mask_char * 6}-{mask_char * 7}"
    
    def _mask_credit_card(self, card: str, mask_char: str, preserve_last_four: bool) -> str:
        """신용카드 마스킹"""
        # 숫자만 추출
        digits = re.sub(r'\D', '', card)
        
        if len(digits) < 4:
            return mask_char * len(card)
        
        if preserve_last_four:
            return f"{mask_char * (len(digits) - 4)}{digits[-4:]}"
        else:
            return mask_char * len(digits)
    
    def _mask_general(self, value: str, mask_char: str) -> str:
        """일반 마스킹"""
        if len(value) <= 2:
            return value
        return value[0] + mask_char * (len(value) - 2) + value[-1]
    
    def _apply_hashing(self, value: str, rule: AnonymizationRule) -> str:
        """해싱 적용"""
        if not isinstance(value, str):
            return str(value)
        
        hash_algorithm = rule.parameters.get('hash_algorithm', 'sha256')
        salt_length = rule.parameters.get('salt_length', 16)
        
        # 솔트 생성
        salt = ''.join(random.choices(string.ascii_letters + string.digits, k=salt_length))
        
        # 해싱
        if hash_algorithm == 'sha256':
            hash_obj = hashlib.sha256()
            hash_obj.update((value + salt).encode('utf-8'))
            return hash_obj.hexdigest()
        else:
            return hashlib.md5((value + salt).encode('utf-8')).hexdigest()
    
    def _apply_generalization(self, value: str, rule: AnonymizationRule) -> str:
        """일반화 적용"""
        generalization_level = rule.parameters.get('generalization_level', 'city')
        
        if rule.data_type == 'address':
            return self._generalize_address(value, generalization_level)
        else:
            return value
    
    def _generalize_address(self, address: str, level: str) -> str:
        """주소 일반화"""
        # 실제 구현에서는 주소 파싱 라이브러리 사용
        if level == 'city':
            # 도시 수준으로 일반화
            parts = address.split(',')
            if len(parts) >= 2:
                return parts[-2].strip()  # 도시 부분
            return address
        elif level == 'state':
            # 주/도 수준으로 일반화
            parts = address.split(',')
            if len(parts) >= 3:
                return parts[-3].strip()  # 주/도 부분
            return address
        else:
            return address
    
    def _apply_suppression(self, value: Any, rule: AnonymizationRule) -> None:
        """억제 적용"""
        return None
    
    def add_rule(self, rule: AnonymizationRule):
        """익명화 규칙 추가"""
        with self.lock:
            self.rules[rule.rule_id] = rule
            logger.info(f"Anonymization rule added: {rule.rule_id}")
    
    def update_rule(self, rule_id: str, updates: Dict[str, Any]):
        """익명화 규칙 업데이트"""
        with self.lock:
            if rule_id in self.rules:
                rule = self.rules[rule_id]
                for key, value in updates.items():
                    if hasattr(rule, key):
                        setattr(rule, key, value)
                logger.info(f"Anonymization rule updated: {rule_id}")
    
    def get_rule(self, rule_id: str) -> Optional[AnonymizationRule]:
        """익명화 규칙 조회"""
        return self.rules.get(rule_id)
    
    def get_all_rules(self) -> List[AnonymizationRule]:
        """모든 익명화 규칙 조회"""
        return list(self.rules.values())

class AnonymizationMetrics:
    """익명화 성능 메트릭"""
    
    def __init__(self):
        self.anonymization_times = []
        self.start_time = time.time()
    
    def record_anonymization_time(self, time_ms: float):
        """익명화 시간 기록"""
        self.anonymization_times.append(time_ms)
        if len(self.anonymization_times) > 1000:
            self.anonymization_times = self.anonymization_times[-1000:]
    
    def get_metrics(self) -> Dict[str, Any]:
        """메트릭 조회"""
        return {
            'avg_anonymization_time_ms': np.mean(self.anonymization_times) if self.anonymization_times else 0,
            'max_anonymization_time_ms': np.max(self.anonymization_times) if self.anonymization_times else 0,
            'total_anonymizations': len(self.anonymization_times),
            'uptime_seconds': time.time() - self.start_time
        }
```

## 🎯 **다음 단계**

### 📋 **완료된 작업**
- ✅ 실시간 위험 평가 시스템 설계 (포트폴리오 위험, 시장 위험)
- ✅ 스트레스 테스트 시스템 설계 (시나리오 기반, 병렬 실행)
- ✅ 위험 한도 관리 시스템 설계
- ✅ 대칭키 암호화 시스템 설계 (AES-256-GCM)
- ✅ 데이터 익명화 시스템 설계 (마스킹, 해싱, 일반화)

### 🔄 **진행 중인 작업**
- 🔄 접근 제어 시스템 (RBAC, ABAC, 동적 접근 제어)
- 🔄 데이터 분류 시스템 (자동 분류, 민감도 수준)

### ⏳ **다음 단계**
1. **접근 제어 시스템** 문서 생성
2. **데이터 분류 시스템** 문서 생성
3. **개인정보 보호 시스템** 문서 생성

---

**마지막 업데이트**: 2024-01-31
**다음 업데이트**: 2024-02-01 (접근 제어 시스템)
**데이터 보호 목표**: < 10ms 암호화, < 50ms 익명화, 100% 규정 준수
**데이터 보호 성과**: AES-256 암호화, 데이터 익명화, 접근 제어 