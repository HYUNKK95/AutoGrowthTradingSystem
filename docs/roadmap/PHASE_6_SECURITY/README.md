# ğŸ”’ Phase 6: ë³´ì•ˆ ë° ê·œì • ì¤€ìˆ˜ ì‹œìŠ¤í…œ

## ğŸ“‹ **ê°œìš”**

### ğŸ¯ **ëª©í‘œ**
- **ê¸°ë³¸ ë³´ì•ˆ ì‹œìŠ¤í…œ**: API í‚¤ ê´€ë¦¬, SSL/TLS, ì ‘ê·¼ ì œì–´
- **ê°œì¸ì •ë³´ ë³´í˜¸**: ê¸°ë³¸ ì•”í˜¸í™”, ì•ˆì „í•œ ë°ì´í„° ì €ì¥
- **ê¸°ë³¸ ëª¨ë‹ˆí„°ë§**: ë¡œê¹…, ê¸°ë³¸ ì•Œë¦¼ ì‹œìŠ¤í…œ
- **ê°œë°œì ë³´ì•ˆ**: ì½”ë“œ ë³´ì•ˆ, ì˜ì¡´ì„± ê´€ë¦¬
- **ë°ì´í„° ë³´í˜¸**: ê¸°ë³¸ ë°ì´í„° ì•”í˜¸í™”, ì ‘ê·¼ ì œì–´

### ğŸ“Š **ì„±ëŠ¥ ëª©í‘œ**
- **ê¸°ë³¸ ë³´ì•ˆ**: API í‚¤ ìœ ì¶œ ë°©ì§€, SSL/TLS ë³´ì•ˆ
- **ë°ì´í„° ë³´í˜¸**: ê¸°ë³¸ ì•”í˜¸í™”, ì•ˆì „í•œ ì €ì¥
- **ëª¨ë‹ˆí„°ë§**: ê¸°ë³¸ ë¡œê¹… ë° ì•Œë¦¼
- **ê°œë°œ ë³´ì•ˆ**: ì½”ë“œ ë³´ì•ˆ, ì˜ì¡´ì„± ì·¨ì•½ì  ê´€ë¦¬
- **ì ‘ê·¼ ì œì–´**: ê¸°ë³¸ ì¸ì¦ ë° ê¶Œí•œ ê´€ë¦¬

## ğŸ—ï¸ **ë³´ì•ˆ ë° ê·œì • ì¤€ìˆ˜ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜**

### ğŸ“ **ë³´ì•ˆ ë° ê·œì • ì¤€ìˆ˜ ì‹œìŠ¤í…œ êµ¬ì¡°**
```
security-compliance/
â”œâ”€â”€ basic-security/                     # ê¸°ë³¸ ë³´ì•ˆ
â”‚   â”œâ”€â”€ api-key-management/             # API í‚¤ ê´€ë¦¬
â”‚   â”œâ”€â”€ ssl-tls/                        # SSL/TLS ì„¤ì •
â”‚   â”œâ”€â”€ access-control/                 # ì ‘ê·¼ ì œì–´
â”‚   â””â”€â”€ authentication/                 # ì¸ì¦ ì‹œìŠ¤í…œ
â”œâ”€â”€ data-protection/                    # ë°ì´í„° ë³´í˜¸
â”‚   â”œâ”€â”€ data-encryption/                # ë°ì´í„° ì•”í˜¸í™”
â”‚   â”œâ”€â”€ secure-storage/                 # ì•ˆì „í•œ ì €ì¥
â”‚   â”œâ”€â”€ backup-security/                # ë°±ì—… ë³´ì•ˆ
â”‚   â””â”€â”€ data-retention/                 # ë°ì´í„° ë³´ê´€
â”œâ”€â”€ monitoring/                         # ëª¨ë‹ˆí„°ë§
â”‚   â”œâ”€â”€ security-logs/                  # ë³´ì•ˆ ë¡œê·¸
â”‚   â”œâ”€â”€ alert-system/                   # ì•Œë¦¼ ì‹œìŠ¤í…œ
â”‚   â”œâ”€â”€ basic-audit/                    # ê¸°ë³¸ ê°ì‚¬
â”‚   â””â”€â”€ incident-response/              # ì‚¬ê³  ëŒ€ì‘
â”œâ”€â”€ development-security/               # ê°œë°œ ë³´ì•ˆ
â”‚   â”œâ”€â”€ code-security/                  # ì½”ë“œ ë³´ì•ˆ
â”‚   â”œâ”€â”€ dependency-management/          # ì˜ì¡´ì„± ê´€ë¦¬
â”‚   â”œâ”€â”€ secret-management/              # ë¹„ë°€ ê´€ë¦¬
â”‚   â””â”€â”€ security-testing/               # ë³´ì•ˆ í…ŒìŠ¤íŠ¸
â””â”€â”€ compliance/                         # ê¸°ë³¸ ê·œì • ì¤€ìˆ˜
    â”œâ”€â”€ basic-kyc/                      # ê¸°ë³¸ KYC
    â”œâ”€â”€ data-privacy/                   # ë°ì´í„° ê°œì¸ì •ë³´
    â”œâ”€â”€ audit-trail/                    # ê°ì‚¬ ì¶”ì 
    â””â”€â”€ reporting/                      # ê¸°ë³¸ ë³´ê³ 
```

## ğŸ”§ **ê¸°ë³¸ ë³´ì•ˆ ì‹œìŠ¤í…œ**

### ğŸ“¦ **API í‚¤ ê´€ë¦¬ ì‹œìŠ¤í…œ**

```python
# security-compliance/basic-security/api_key_management.py
import asyncio
import time
import logging
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass
from datetime import datetime, timedelta
import hashlib
import secrets
from cryptography.fernet import Fernet

logger = logging.getLogger(__name__)

@dataclass
class APIKeyConfig:
    """API í‚¤ ì„¤ì •"""
    key_length: int = 64
    expiration_days: int = 90
    max_usage_per_day: int = 1000
    encryption_enabled: bool = True

@dataclass
class APIKey:
    """API í‚¤ ì •ë³´"""
    key_id: str
    key_hash: str
    user_id: str
    permissions: List[str]
    created_at: datetime
    expires_at: datetime
    last_used: Optional[datetime]
    usage_count: int

class APIKeyManager:
    """API í‚¤ ê´€ë¦¬ ì‹œìŠ¤í…œ"""
    
    def __init__(self, config: APIKeyConfig):
        self.config = config
        self.key_store = {}
        self.encryption_key = Fernet.generate_key()
        self.cipher = Fernet(self.encryption_key)
        
        logger.info("API key management system initialized")
    
    async def generate_api_key(self, user_id: str, permissions: List[str]) -> str:
        """API í‚¤ ìƒì„±"""
        try:
            # ì•ˆì „í•œ ëœë¤ í‚¤ ìƒì„±
            api_key = secrets.token_urlsafe(self.config.key_length)
            key_hash = hashlib.sha256(api_key.encode()).hexdigest()
            
            # í‚¤ ID ìƒì„±
            key_id = f"api_key_{int(time.time())}"
            
            # ë§Œë£Œ ì‹œê°„ ì„¤ì • (90ì¼)
            created_at = datetime.now()
            expires_at = created_at + timedelta(days=self.config.expiration_days)
            
            # API í‚¤ ì •ë³´ ìƒì„±
            api_key_info = APIKey(
                key_id=key_id,
                key_hash=key_hash,
                user_id=user_id,
                permissions=permissions,
                created_at=created_at,
                expires_at=expires_at,
                last_used=None,
                usage_count=0
            )
            
            # í‚¤ ì €ì¥ (í•´ì‹œë§Œ ì €ì¥)
            self.key_store[key_id] = api_key_info
            
            logger.info(f"API key generated: {key_id}")
            return api_key
            
        except Exception as e:
            logger.error(f"API key generation failed: {e}")
            raise
    
    async def validate_api_key(self, api_key: str) -> Optional[APIKey]:
        """API í‚¤ ê²€ì¦"""
        try:
            # í‚¤ í•´ì‹œ ê³„ì‚°
            key_hash = hashlib.sha256(api_key.encode()).hexdigest()
            
            # í‚¤ ì°¾ê¸°
            for key_info in self.key_store.values():
                if key_info.key_hash == key_hash:
                    # ë§Œë£Œ í™•ì¸
                    if datetime.now() > key_info.expires_at:
                        logger.warning(f"API key expired: {key_info.key_id}")
                        return None
                    
                    # ì‚¬ìš©ëŸ‰ í™•ì¸
                    if key_info.usage_count >= self.config.max_usage_per_day:
                        logger.warning(f"API key usage limit exceeded: {key_info.key_id}")
                        return None
                    
                    # ì‚¬ìš© ì •ë³´ ì—…ë°ì´íŠ¸
                    key_info.last_used = datetime.now()
                    key_info.usage_count += 1
                    
                    logger.info(f"API key validated: {key_info.key_id}")
                    return key_info
            
            logger.warning("Invalid API key")
            return None
            
        except Exception as e:
            logger.error(f"API key validation failed: {e}")
            return None
    
    async def revoke_api_key(self, key_id: str) -> bool:
        """API í‚¤ íê¸°"""
        try:
            if key_id not in self.key_store:
                logger.warning(f"API key not found: {key_id}")
                return False
            
            # í‚¤ ì‚­ì œ
            del self.key_store[key_id]
            
            logger.info(f"API key revoked: {key_id}")
            return True
            
        except Exception as e:
            logger.error(f"API key revocation failed: {e}")
            return False
            )
            
            decrypted_data = private_key.decrypt(
                encrypted_data,
                padding.OAEP(
                    mgf=padding.MGF1(algorithm=hashes.SHA256()),
                    algorithm=hashes.SHA256(),
                    label=None
                )
            )
            
            logger.info(f"Data decrypted with quantum key: {key_id}")
            return decrypted_data
            
        except Exception as e:
            logger.error(f"Quantum decryption failed: {e}")
            raise
    
    async def quantum_key_exchange(self, alice_id: str, bob_id: str) -> str:
        """ì–‘ì í‚¤ êµí™˜ (BB84 í”„ë¡œí† ì½œ)"""
        try:
            # BB84 í”„ë¡œí† ì½œ êµ¬í˜„
            # 1. Aliceê°€ ëœë¤ ë¹„íŠ¸ì™€ ë² ì´ìŠ¤ ìƒì„±
            alice_bits = np.random.randint(2, size=self.config.qubit_count)
            alice_bases = np.random.randint(2, size=self.config.qubit_count)
            
            # 2. Bobì´ ëœë¤ ë² ì´ìŠ¤ ìƒì„±
            bob_bases = np.random.randint(2, size=self.config.qubit_count)
            
            # 3. ì–‘ì íšŒë¡œ ìƒì„± ë° ì¸¡ì •
            shared_key = await self._bb84_protocol(alice_bits, alice_bases, bob_bases)
            
            # 4. ê³µìœ  í‚¤ ì €ì¥
            shared_key_id = f"shared_key_{alice_id}_{bob_id}_{int(time.time())}"
            
            # ê³µìœ  í‚¤ë¥¼ ì–‘ì í‚¤ ìŒìœ¼ë¡œ ë³€í™˜
            shared_key_pair = QuantumKeyPair(
                public_key=shared_key,
                private_key=shared_key,
                creation_time=datetime.now(),
                expiration_time=datetime.now() + timedelta(hours=1),
                key_id=shared_key_id
            )
            
            self.key_store[shared_key_id] = shared_key_pair
            
            logger.info(f"Quantum key exchange completed: {shared_key_id}")
            return shared_key_id
            
        except Exception as e:
            logger.error(f"Quantum key exchange failed: {e}")
            raise
    
    async def _bb84_protocol(self, alice_bits: np.ndarray, alice_bases: np.ndarray, 
                           bob_bases: np.ndarray) -> bytes:
        """BB84 í”„ë¡œí† ì½œ êµ¬í˜„"""
        try:
            # ì–‘ì íšŒë¡œ ìƒì„±
            qc = QuantumCircuit(self.config.qubit_count, self.config.qubit_count)
            
            # Aliceì˜ ë¹„íŠ¸ì™€ ë² ì´ìŠ¤ì— ë”°ë¼ íë¹„íŠ¸ ì¤€ë¹„
            for i in range(self.config.qubit_count):
                if alice_bits[i] == 1:
                    qc.x(i)  # NOT ê²Œì´íŠ¸
                
                if alice_bases[i] == 1:
                    qc.h(i)  # Hadamard ê²Œì´íŠ¸
            
            # Bobì˜ ë² ì´ìŠ¤ì— ë”°ë¼ ì¸¡ì •
            for i in range(self.config.qubit_count):
                if bob_bases[i] == 1:
                    qc.h(i)  # Hadamard ê²Œì´íŠ¸
                qc.measure(i, i)
            
            # ì–‘ì íšŒë¡œ ì‹¤í–‰
            job = execute(qc, self.backend, shots=1)
            result = job.result()
            counts = result.get_counts(qc)
            
            # ì¸¡ì • ê²°ê³¼ì—ì„œ ê³µìœ  í‚¤ ì¶”ì¶œ
            measured_bits = list(counts.keys())[0]
            shared_bits = []
            
            for i in range(self.config.qubit_count):
                if alice_bases[i] == bob_bases[i]:  # ê°™ì€ ë² ì´ìŠ¤ ì‚¬ìš©
                    shared_bits.append(int(measured_bits[i]))
            
            # ê³µìœ  í‚¤ë¥¼ ë°”ì´íŠ¸ë¡œ ë³€í™˜
            shared_key = bytes(shared_bits)
            
            return shared_key
            
        except Exception as e:
            logger.error(f"BB84 protocol failed: {e}")
            raise

class QuantumRandomGenerator:
    """ì–‘ì ë‚œìˆ˜ ìƒì„±ê¸°"""
    
    def __init__(self):
        self.backend = Aer.get_backend('qasm_simulator')
    
    async def generate_random_bits(self, bit_count: int) -> bytes:
        """ì–‘ì ë‚œìˆ˜ ë¹„íŠ¸ ìƒì„±"""
        try:
            # ì–‘ì íšŒë¡œ ìƒì„±
            qc = QuantumCircuit(bit_count, bit_count)
            
            # ëª¨ë“  íë¹„íŠ¸ë¥¼ ì¤‘ì²© ìƒíƒœë¡œ ì¤€ë¹„
            for i in range(bit_count):
                qc.h(i)
                qc.measure(i, i)
            
            # ì–‘ì íšŒë¡œ ì‹¤í–‰
            job = execute(qc, self.backend, shots=1)
            result = job.result()
            counts = result.get_counts(qc)
            
            # ì¸¡ì • ê²°ê³¼ë¥¼ ë°”ì´íŠ¸ë¡œ ë³€í™˜
            random_bits = list(counts.keys())[0]
            random_bytes = bytes([int(random_bits[i:i+8], 2) 
                                for i in range(0, len(random_bits), 8)])
            
            return random_bytes
            
        except Exception as e:
            logger.error(f"Quantum random generation failed: {e}")
            raise
```

## ğŸ”§ **ê·œì • ì¤€ìˆ˜ ì‹œìŠ¤í…œ**

### ğŸ“¦ **AML/KYC ì‹œìŠ¤í…œ**

```python
# security-compliance/regulatory-compliance/aml_kyc_system.py
import asyncio
import time
import logging
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass
from datetime import datetime, timedelta
import re
import hashlib
from enum import Enum

logger = logging.getLogger(__name__)

class RiskLevel(Enum):
    """ìœ„í—˜ ìˆ˜ì¤€"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"

class CustomerStatus(Enum):
    """ê³ ê° ìƒíƒœ"""
    PENDING = "pending"
    APPROVED = "approved"
    REJECTED = "rejected"
    SUSPENDED = "suspended"

@dataclass
class CustomerInfo:
    """ê³ ê° ì •ë³´"""
    customer_id: str
    name: str
    date_of_birth: str
    nationality: str
    address: str
    phone: str
    email: str
    id_document_type: str
    id_document_number: str
    risk_level: RiskLevel
    status: CustomerStatus
    created_at: datetime
    updated_at: datetime

@dataclass
class TransactionInfo:
    """ê±°ë˜ ì •ë³´"""
    transaction_id: str
    customer_id: str
    amount: float
    currency: str
    transaction_type: str
    source_account: str
    destination_account: str
    timestamp: datetime
    risk_score: float

class AMLKYCSystem:
    """AML/KYC ì‹œìŠ¤í…œ"""
    
    def __init__(self):
        self.customer_database = {}
        self.transaction_history = {}
        self.sanctions_list = self._load_sanctions_list()
        self.pep_list = self._load_pep_list()
        self.risk_scorer = RiskScorer()
        self.transaction_monitor = TransactionMonitor()
        
        logger.info("AML/KYC system initialized")
    
    async def register_customer(self, customer_data: Dict[str, Any]) -> str:
        """ê³ ê° ë“±ë¡"""
        try:
            # ê³ ê° ID ìƒì„±
            customer_id = self._generate_customer_id(customer_data)
            
            # ê¸°ë³¸ ê²€ì¦
            validation_result = await self._validate_customer_data(customer_data)
            if not validation_result['valid']:
                raise ValueError(f"Customer validation failed: {validation_result['errors']}")
            
            # ìœ„í—˜ ìˆ˜ì¤€ í‰ê°€
            risk_level = await self._assess_customer_risk(customer_data)
            
            # PEP ê²€ì‚¬
            is_pep = await self._check_pep_status(customer_data)
            if is_pep:
                risk_level = RiskLevel.HIGH
            
            # ì œì¬ ëª©ë¡ ê²€ì‚¬
            is_sanctioned = await self._check_sanctions_list(customer_data)
            if is_sanctioned:
                risk_level = RiskLevel.CRITICAL
            
            # ê³ ê° ì •ë³´ ìƒì„±
            customer_info = CustomerInfo(
                customer_id=customer_id,
                name=customer_data['name'],
                date_of_birth=customer_data['date_of_birth'],
                nationality=customer_data['nationality'],
                address=customer_data['address'],
                phone=customer_data['phone'],
                email=customer_data['email'],
                id_document_type=customer_data['id_document_type'],
                id_document_number=customer_data['id_document_number'],
                risk_level=risk_level,
                status=CustomerStatus.PENDING,
                created_at=datetime.now(),
                updated_at=datetime.now()
            )
            
            # ê³ ê° ì •ë³´ ì €ì¥
            self.customer_database[customer_id] = customer_info
            
            # ìë™ ìŠ¹ì¸ ì—¬ë¶€ ê²°ì •
            if risk_level in [RiskLevel.LOW, RiskLevel.MEDIUM]:
                customer_info.status = CustomerStatus.APPROVED
                logger.info(f"Customer auto-approved: {customer_id}")
            else:
                logger.info(f"Customer requires manual review: {customer_id}")
            
            return customer_id
            
        except Exception as e:
            logger.error(f"Customer registration failed: {e}")
            raise
    
    async def process_transaction(self, transaction_data: Dict[str, Any]) -> Dict[str, Any]:
        """ê±°ë˜ ì²˜ë¦¬"""
        try:
            customer_id = transaction_data['customer_id']
            
            # ê³ ê° ì •ë³´ í™•ì¸
            if customer_id not in self.customer_database:
                raise ValueError(f"Customer not found: {customer_id}")
            
            customer_info = self.customer_database[customer_id]
            
            # ê³ ê° ìƒíƒœ í™•ì¸
            if customer_info.status != CustomerStatus.APPROVED:
                raise ValueError(f"Customer not approved: {customer_id}")
            
            # ê±°ë˜ ì •ë³´ ìƒì„±
            transaction_info = TransactionInfo(
                transaction_id=self._generate_transaction_id(),
                customer_id=customer_id,
                amount=transaction_data['amount'],
                currency=transaction_data['currency'],
                transaction_type=transaction_data['transaction_type'],
                source_account=transaction_data['source_account'],
                destination_account=transaction_data['destination_account'],
                timestamp=datetime.now(),
                risk_score=0.0
            )
            
            # ê±°ë˜ ìœ„í—˜ í‰ê°€
            risk_score = await self._assess_transaction_risk(transaction_info, customer_info)
            transaction_info.risk_score = risk_score
            
            # ê±°ë˜ ëª¨ë‹ˆí„°ë§
            monitoring_result = await self.transaction_monitor.monitor_transaction(transaction_info)
            
            # ê±°ë˜ ê¸°ë¡
            self.transaction_history[transaction_info.transaction_id] = transaction_info
            
            # ê³ ìœ„í—˜ ê±°ë˜ ì•Œë¦¼
            if risk_score > 0.7:
                await self._send_high_risk_alert(transaction_info)
            
            return {
                'transaction_id': transaction_info.transaction_id,
                'status': 'approved' if risk_score < 0.8 else 'pending_review',
                'risk_score': risk_score,
                'monitoring_result': monitoring_result
            }
            
        except Exception as e:
            logger.error(f"Transaction processing failed: {e}")
            raise
    
    async def _validate_customer_data(self, customer_data: Dict[str, Any]) -> Dict[str, Any]:
        """ê³ ê° ë°ì´í„° ê²€ì¦"""
        errors = []
        
        # í•„ìˆ˜ í•„ë“œ í™•ì¸
        required_fields = ['name', 'date_of_birth', 'nationality', 'address', 
                          'phone', 'email', 'id_document_type', 'id_document_number']
        
        for field in required_fields:
            if field not in customer_data or not customer_data[field]:
                errors.append(f"Missing required field: {field}")
        
        # ì´ë©”ì¼ í˜•ì‹ ê²€ì¦
        if 'email' in customer_data:
            email_pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
            if not re.match(email_pattern, customer_data['email']):
                errors.append("Invalid email format")
        
        # ì „í™”ë²ˆí˜¸ í˜•ì‹ ê²€ì¦
        if 'phone' in customer_data:
            phone_pattern = r'^\+?[\d\s\-\(\)]+$'
            if not re.match(phone_pattern, customer_data['phone']):
                errors.append("Invalid phone number format")
        
        # ìƒë…„ì›”ì¼ í˜•ì‹ ê²€ì¦
        if 'date_of_birth' in customer_data:
            try:
                datetime.strptime(customer_data['date_of_birth'], '%Y-%m-%d')
            except ValueError:
                errors.append("Invalid date of birth format (YYYY-MM-DD)")
        
        return {
            'valid': len(errors) == 0,
            'errors': errors
        }
    
    async def _assess_customer_risk(self, customer_data: Dict[str, Any]) -> RiskLevel:
        """ê³ ê° ìœ„í—˜ í‰ê°€"""
        risk_score = 0.0
        
        # êµ­ì  ê¸°ë°˜ ìœ„í—˜
        high_risk_countries = ['North Korea', 'Iran', 'Syria', 'Cuba']
        if customer_data['nationality'] in high_risk_countries:
            risk_score += 0.4
        
        # ë‚˜ì´ ê¸°ë°˜ ìœ„í—˜
        try:
            birth_date = datetime.strptime(customer_data['date_of_birth'], '%Y-%m-%d')
            age = (datetime.now() - birth_date).days / 365.25
            if age < 18 or age > 80:
                risk_score += 0.2
        except:
            risk_score += 0.1
        
        # ì´ë©”ì¼ ë„ë©”ì¸ ê¸°ë°˜ ìœ„í—˜
        if 'email' in customer_data:
            email_domain = customer_data['email'].split('@')[1]
            suspicious_domains = ['temp-mail.org', '10minutemail.com', 'guerrillamail.com']
            if email_domain in suspicious_domains:
                risk_score += 0.3
        
        # ìœ„í—˜ ìˆ˜ì¤€ ê²°ì •
        if risk_score >= 0.7:
            return RiskLevel.HIGH
        elif risk_score >= 0.4:
            return RiskLevel.MEDIUM
        else:
            return RiskLevel.LOW
    
    async def _check_pep_status(self, customer_data: Dict[str, Any]) -> bool:
        """PEP ìƒíƒœ í™•ì¸"""
        # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì™¸ë¶€ PEP ë°ì´í„°ë² ì´ìŠ¤ ì¡°íšŒ
        # ì—¬ê¸°ì„œëŠ” ì‹œë®¬ë ˆì´ì…˜
        pep_names = ['John Smith', 'Jane Doe', 'Robert Johnson']
        return customer_data['name'] in pep_names
    
    async def _check_sanctions_list(self, customer_data: Dict[str, Any]) -> bool:
        """ì œì¬ ëª©ë¡ í™•ì¸"""
        # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì™¸ë¶€ ì œì¬ ë°ì´í„°ë² ì´ìŠ¤ ì¡°íšŒ
        # ì—¬ê¸°ì„œëŠ” ì‹œë®¬ë ˆì´ì…˜
        sanctioned_names = ['Sanctioned Person 1', 'Sanctioned Person 2']
        return customer_data['name'] in sanctioned_names
    
    async def _assess_transaction_risk(self, transaction: TransactionInfo, 
                                     customer: CustomerInfo) -> float:
        """ê±°ë˜ ìœ„í—˜ í‰ê°€"""
        risk_score = 0.0
        
        # ê³ ê° ìœ„í—˜ ìˆ˜ì¤€ ê¸°ë°˜
        if customer.risk_level == RiskLevel.HIGH:
            risk_score += 0.3
        elif customer.risk_level == RiskLevel.CRITICAL:
            risk_score += 0.5
        
        # ê±°ë˜ ê¸ˆì•¡ ê¸°ë°˜
        if transaction.amount > 10000:
            risk_score += 0.2
        elif transaction.amount > 50000:
            risk_score += 0.4
        
        # ê±°ë˜ ë¹ˆë„ ê¸°ë°˜
        customer_transactions = [t for t in self.transaction_history.values() 
                               if t.customer_id == customer.customer_id]
        if len(customer_transactions) > 10:
            risk_score += 0.1
        
        # ê±°ë˜ íŒ¨í„´ ê¸°ë°˜
        if transaction.transaction_type == 'international_transfer':
            risk_score += 0.2
        
        return min(risk_score, 1.0)
    
    async def _send_high_risk_alert(self, transaction: TransactionInfo):
        """ê³ ìœ„í—˜ ê±°ë˜ ì•Œë¦¼"""
        alert_message = {
            'type': 'high_risk_transaction',
            'transaction_id': transaction.transaction_id,
            'customer_id': transaction.customer_id,
            'amount': transaction.amount,
            'risk_score': transaction.risk_score,
            'timestamp': transaction.timestamp.isoformat()
        }
        
        logger.warning(f"High risk transaction alert: {alert_message}")
        # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì•Œë¦¼ ì‹œìŠ¤í…œìœ¼ë¡œ ì „ì†¡
    
    def _generate_customer_id(self, customer_data: Dict[str, Any]) -> str:
        """ê³ ê° ID ìƒì„±"""
        # ê³ ê° ì •ë³´ì˜ í•´ì‹œë¥¼ ê¸°ë°˜ìœ¼ë¡œ ID ìƒì„±
        customer_string = f"{customer_data['name']}{customer_data['date_of_birth']}{customer_data['id_document_number']}"
        return hashlib.sha256(customer_string.encode()).hexdigest()[:16]
    
    def _generate_transaction_id(self) -> str:
        """ê±°ë˜ ID ìƒì„±"""
        return f"txn_{int(time.time())}_{np.random.randint(1000, 9999)}"
    
    def _load_sanctions_list(self) -> List[str]:
        """ì œì¬ ëª©ë¡ ë¡œë“œ"""
        # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì™¸ë¶€ API ë˜ëŠ” ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ë¡œë“œ
        return ['Sanctioned Person 1', 'Sanctioned Person 2', 'Sanctioned Person 3']
    
    def _load_pep_list(self) -> List[str]:
        """PEP ëª©ë¡ ë¡œë“œ"""
        # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì™¸ë¶€ API ë˜ëŠ” ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ë¡œë“œ
        return ['John Smith', 'Jane Doe', 'Robert Johnson', 'Mary Wilson']

class RiskScorer:
    """ìœ„í—˜ ì ìˆ˜ ê³„ì‚°ê¸°"""
    
    def calculate_risk_score(self, factors: Dict[str, float]) -> float:
        """ìœ„í—˜ ì ìˆ˜ ê³„ì‚°"""
        total_score = 0.0
        weights = {
            'customer_risk': 0.3,
            'transaction_amount': 0.2,
            'transaction_frequency': 0.15,
            'geographic_risk': 0.15,
            'behavioral_risk': 0.2
        }
        
        for factor, weight in weights.items():
            if factor in factors:
                total_score += factors[factor] * weight
        
        return min(total_score, 1.0)

class TransactionMonitor:
    """ê±°ë˜ ëª¨ë‹ˆí„°"""
    
    def __init__(self):
        self.suspicious_patterns = self._load_suspicious_patterns()
    
    async def monitor_transaction(self, transaction: TransactionInfo) -> Dict[str, Any]:
        """ê±°ë˜ ëª¨ë‹ˆí„°ë§"""
        alerts = []
        
        # ì˜ì‹¬ìŠ¤ëŸ¬ìš´ íŒ¨í„´ í™•ì¸
        for pattern in self.suspicious_patterns:
            if self._matches_pattern(transaction, pattern):
                alerts.append({
                    'pattern': pattern['name'],
                    'severity': pattern['severity'],
                    'description': pattern['description']
                })
        
        return {
            'monitored': True,
            'alerts': alerts,
            'risk_level': 'high' if alerts else 'low'
        }
    
    def _matches_pattern(self, transaction: TransactionInfo, pattern: Dict[str, Any]) -> bool:
        """íŒ¨í„´ ë§¤ì¹­"""
        pattern_type = pattern['type']
        
        if pattern_type == 'large_amount':
            return transaction.amount > pattern['threshold']
        elif pattern_type == 'rapid_transfers':
            # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì‹œê°„ ê¸°ë°˜ íŒ¨í„´ ë¶„ì„
            return False
        elif pattern_type == 'unusual_frequency':
            # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ë¹ˆë„ ê¸°ë°˜ íŒ¨í„´ ë¶„ì„
            return False
        
        return False
    
    def _load_suspicious_patterns(self) -> List[Dict[str, Any]]:
        """ì˜ì‹¬ìŠ¤ëŸ¬ìš´ íŒ¨í„´ ë¡œë“œ"""
        return [
            {
                'name': 'Large Amount Transfer',
                'type': 'large_amount',
                'threshold': 50000,
                'severity': 'medium',
                'description': 'Large amount transfer detected'
            },
            {
                'name': 'Rapid Transfers',
                'type': 'rapid_transfers',
                'threshold': 5,
                'severity': 'high',
                'description': 'Multiple rapid transfers detected'
            },
            {
                'name': 'Unusual Frequency',
                'type': 'unusual_frequency',
                'threshold': 10,
                'severity': 'medium',
                'description': 'Unusual transaction frequency detected'
            }
        ]
```

## ğŸ¯ **ë‹¤ìŒ ë‹¨ê³„**

### ğŸ“‹ **ì™„ë£Œëœ ì‘ì—…**
- âœ… ê¸°ë³¸ ë³´ì•ˆ ì‹œìŠ¤í…œ ì„¤ê³„ (API í‚¤ ê´€ë¦¬, SSL/TLS)
- âœ… ê·œì • ì¤€ìˆ˜ ì‹œìŠ¤í…œ ì„¤ê³„ (AML/KYC, MiFID II, Dodd-Frank, GDPR)
- âœ… ê°ì‚¬ ë° ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ì„¤ê³„

### ğŸ”„ **ì§„í–‰ ì¤‘ì¸ ì‘ì—…**
- ğŸ”„ ìœ„í—˜ ê´€ë¦¬ ì‹œìŠ¤í…œ (ì‹¤ì‹œê°„ ìœ„í—˜ í‰ê°€, ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸)
- ğŸ”„ ë°ì´í„° ë³´í˜¸ ì‹œìŠ¤í…œ (ì•”í˜¸í™”, ìµëª…í™”, ì ‘ê·¼ ì œì–´)

### â³ **ë‹¤ìŒ ë‹¨ê³„**
1. **ìœ„í—˜ ê´€ë¦¬ ì‹œìŠ¤í…œ** ë¬¸ì„œ ìƒì„±
2. **ë°ì´í„° ë³´í˜¸ ì‹œìŠ¤í…œ** ë¬¸ì„œ ìƒì„±
3. **Phase 7 ê¸€ë¡œë²Œ í™•ì¥** ë¬¸ì„œ ìƒì„±

---

**ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸**: 2024-01-31
**ë‹¤ìŒ ì—…ë°ì´íŠ¸**: 2024-02-01 (ìœ„í—˜ ê´€ë¦¬ ì‹œìŠ¤í…œ)
**ë³´ì•ˆ ë° ê·œì • ì¤€ìˆ˜ ëª©í‘œ**: 99.999% ë³´ì•ˆ ì‚¬ê³  ë°©ì§€, 100% ê·œì • ì¤€ìˆ˜ìœ¨
**ë³´ì•ˆ ë° ê·œì • ì¤€ìˆ˜ ì„±ê³¼**: API í‚¤ ê´€ë¦¬, ê¸°ë³¸ ì•”í˜¸í™”, ë¡œê¹… ë° ëª¨ë‹ˆí„°ë§ 