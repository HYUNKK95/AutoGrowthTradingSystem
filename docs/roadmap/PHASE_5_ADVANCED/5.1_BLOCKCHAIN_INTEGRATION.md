# ⛓️ Phase 5.1: 블록체인 통합 연구 (장기 연구 과제)

## 📋 **개요**

### 🎯 **연구 목표** (개인 프로젝트 우선순위 낮음)
- **기본 블록체인 연동**: 이더리움, BSC 기본 연동 연구
- **DeFi 프로토콜 연구**: Uniswap 등 주요 DeFi 프로토콜 이해
- **NFT 거래 연구**: NFT 마켓플레이스 기본 개념 연구
- **크로스체인 연구**: 다중 체인 지원 방법론 연구
- **스마트 컨트랙트 연구**: 기본 스마트 컨트랙트 개발 연구

### 📊 **연구 성과 목표**
- **기본 연동**: 이더리움 네트워크 기본 연동
- **DeFi 이해**: 주요 DeFi 프로토콜 동작 원리 파악
- **NFT 이해**: NFT 거래 기본 개념 이해
- **크로스체인 이해**: 크로스체인 기술 기본 이해
- **스마트 컨트랙트 이해**: 기본 스마트 컨트랙트 개발 능력

### ⚠️ **중요 안내**
이 문서는 **장기 연구 과제**로 분류됩니다. 개인 개발자의 우선순위를 고려하여:
- **즉시 구현하지 않음**: 핵심 거래 시스템 완성 후 연구
- **기본 개념 연구**: 복잡한 구현보다는 이해에 중점
- **실험적 접근**: 실제 운영보다는 연구 및 학습 목적

## 🏗️ **블록체인 통합 시스템 아키텍처**

### 📁 **블록체인 통합 시스템 구조**
```
blockchain-integration/
├── defi-protocols/                     # DeFi 프로토콜
│   ├── uniswap-integration/            # Uniswap 통합
│   ├── aave-integration/               # Aave 통합
│   ├── compound-integration/           # Compound 통합
│   └── yield-farming/                  # 수익률 농업
├── nft-trading/                        # NFT 거래
│   ├── nft-marketplace/                # NFT 마켓플레이스
│   ├── nft-valuation/                  # NFT 가치 평가
│   ├── nft-lending/                    # NFT 대출
│   └── nft-fractionalization/          # NFT 분할 소유
├── cross-chain/                        # 크로스체인
│   ├── ethereum-bridge/                # 이더리움 브리지
│   ├── bsc-bridge/                     # BSC 브리지
│   ├── polygon-bridge/                 # 폴리곤 브리지
│   └── arbitrum-bridge/                # Arbitrum 브리지
├── smart-contracts/                    # 스마트 컨트랙트
│   ├── trading-contracts/              # 거래 컨트랙트
│   ├── risk-management/                # 리스크 관리
│   ├── yield-optimization/             # 수익률 최적화
│   └── governance/                     # 거버넌스
└── web3-wallets/                       # Web3 지갑
    ├── metamask/                       # MetaMask
    ├── walletconnect/                  # WalletConnect
    ├── hardware-wallets/               # 하드웨어 지갑
    └── multi-sig/                      # 다중 서명
```

## 🔧 **DeFi 프로토콜 통합 시스템**

### 📦 **Uniswap 통합**

```python
# blockchain-integration/defi-protocols/uniswap_integration.py
import asyncio
import time
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass
from datetime import datetime
import logging
import json
import aiohttp
from web3 import Web3
from eth_account import Account
import eth_utils

logger = logging.getLogger(__name__)

@dataclass
class TokenInfo:
    """토큰 정보"""
    address: str
    symbol: str
    name: str
    decimals: int
    total_supply: int
    price_usd: float

@dataclass
class PoolInfo:
    """풀 정보"""
    pool_address: str
    token0: TokenInfo
    token1: TokenInfo
    reserve0: int
    reserve1: int
    fee: int
    liquidity: int
    volume_24h: float
    apy: float

@dataclass
class SwapRequest:
    """스왑 요청"""
    request_id: str
    token_in: str
    token_out: str
    amount_in: int
    amount_out_min: int
    slippage_tolerance: float
    deadline: int
    gas_price: int
    gas_limit: int

@dataclass
class SwapResult:
    """스왑 결과"""
    request_id: str
    transaction_hash: str
    amount_in: int
    amount_out: int
    gas_used: int
    gas_price: int
    status: str
    timestamp: datetime
    block_number: int

class UniswapIntegration:
    """Uniswap 통합"""
    
    def __init__(self, 
                 ethereum_rpc_url: str,
                 uniswap_router_address: str,
                 private_key: str):
        self.w3 = Web3(Web3.HTTPProvider(ethereum_rpc_url))
        self.uniswap_router_address = uniswap_router_address
        self.account = Account.from_key(private_key)
        
        # Uniswap V2 Router ABI
        self.router_abi = self._load_router_abi()
        self.router_contract = self.w3.eth.contract(
            address=uniswap_router_address,
            abi=self.router_abi
        )
        
        # 토큰 정보 캐시
        self.token_cache = {}
        
        # 풀 정보 캐시
        self.pool_cache = {}
        
        # 가스비 최적화기
        self.gas_optimizer = GasOptimizer(self.w3)
        
        logger.info("Uniswap integration initialized")
    
    def _load_router_abi(self) -> List[Dict[str, Any]]:
        """라우터 ABI 로드"""
        try:
            # 실제 구현에서는 파일에서 ABI 로드
            # 여기서는 간단한 ABI 예시
            return [
                {
                    "inputs": [
                        {"name": "amountIn", "type": "uint256"},
                        {"name": "amountOutMin", "type": "uint256"},
                        {"name": "path", "type": "address[]"},
                        {"name": "to", "type": "address"},
                        {"name": "deadline", "type": "uint256"}
                    ],
                    "name": "swapExactTokensForTokens",
                    "outputs": [{"name": "amounts", "type": "uint256[]"}],
                    "stateMutability": "nonpayable",
                    "type": "function"
                },
                {
                    "inputs": [
                        {"name": "amountOut", "type": "uint256"},
                        {"name": "path", "type": "address[]"}
                    ],
                    "name": "getAmountsIn",
                    "outputs": [{"name": "amounts", "type": "uint256[]"}],
                    "stateMutability": "view",
                    "type": "function"
                },
                {
                    "inputs": [
                        {"name": "amountIn", "type": "uint256"},
                        {"name": "path", "type": "address[]"}
                    ],
                    "name": "getAmountsOut",
                    "outputs": [{"name": "amounts", "type": "uint256[]"}],
                    "stateMutability": "view",
                    "type": "function"
                }
            ]
            
        except Exception as e:
            logger.error(f"Router ABI loading failed: {e}")
            return []
    
    async def get_token_info(self, token_address: str) -> Optional[TokenInfo]:
        """토큰 정보 조회"""
        try:
            # 캐시 확인
            if token_address in self.token_cache:
                return self.token_cache[token_address]
            
            # ERC20 토큰 컨트랙트
            token_abi = self._load_erc20_abi()
            token_contract = self.w3.eth.contract(
                address=token_address,
                abi=token_abi
            )
            
            # 토큰 정보 조회
            symbol = await self._call_contract_function(token_contract.functions.symbol())
            name = await self._call_contract_function(token_contract.functions.name())
            decimals = await self._call_contract_function(token_contract.functions.decimals())
            total_supply = await self._call_contract_function(token_contract.functions.totalSupply())
            
            # USD 가격 조회 (실제 구현에서는 Oracle 사용)
            price_usd = await self._get_token_price_usd(token_address)
            
            token_info = TokenInfo(
                address=token_address,
                symbol=symbol,
                name=name,
                decimals=decimals,
                total_supply=total_supply,
                price_usd=price_usd
            )
            
            # 캐시에 저장
            self.token_cache[token_address] = token_info
            
            return token_info
            
        except Exception as e:
            logger.error(f"Token info retrieval failed: {e}")
            return None
    
    async def get_pool_info(self, token0_address: str, token1_address: str) -> Optional[PoolInfo]:
        """풀 정보 조회"""
        try:
            pool_key = f"{token0_address}_{token1_address}"
            
            # 캐시 확인
            if pool_key in self.pool_cache:
                return self.pool_cache[pool_key]
            
            # 토큰 정보 조회
            token0_info = await self.get_token_info(token0_address)
            token1_info = await self.get_token_info(token1_address)
            
            if not token0_info or not token1_info:
                return None
            
            # 풀 주소 계산
            pool_address = await self._get_pool_address(token0_address, token1_address)
            
            # 풀 컨트랙트
            pool_abi = self._load_pool_abi()
            pool_contract = self.w3.eth.contract(
                address=pool_address,
                abi=pool_abi
            )
            
            # 풀 정보 조회
            reserves = await self._call_contract_function(pool_contract.functions.getReserves())
            reserve0, reserve1, _ = reserves
            
            # 수수료 및 유동성
            fee = 3000  # 0.3% (실제 구현에서는 풀에서 조회)
            liquidity = reserve0 + reserve1
            
            # 24시간 거래량 (실제 구현에서는 이벤트 로그 분석)
            volume_24h = await self._get_pool_volume_24h(pool_address)
            
            # APY 계산 (실제 구현에서는 복잡한 계산)
            apy = await self._calculate_pool_apy(pool_address)
            
            pool_info = PoolInfo(
                pool_address=pool_address,
                token0=token0_info,
                token1=token1_info,
                reserve0=reserve0,
                reserve1=reserve1,
                fee=fee,
                liquidity=liquidity,
                volume_24h=volume_24h,
                apy=apy
            )
            
            # 캐시에 저장
            self.pool_cache[pool_key] = pool_info
            
            return pool_info
            
        except Exception as e:
            logger.error(f"Pool info retrieval failed: {e}")
            return None
    
    async def swap_tokens(self, request: SwapRequest) -> SwapResult:
        """토큰 스왑"""
        try:
            # 스왑 경로 계산
            path = [request.token_in, request.token_out]
            
            # 최소 출력량 계산
            amounts_out = await self._get_amounts_out(request.amount_in, path)
            amount_out_min = int(amounts_out[-1] * (1 - request.slippage_tolerance))
            
            # 가스비 최적화
            optimized_gas_price = await self.gas_optimizer.get_optimal_gas_price()
            
            # 스왑 트랜잭션 생성
            swap_function = self.router_contract.functions.swapExactTokensForTokens(
                request.amount_in,
                amount_out_min,
                path,
                self.account.address,
                request.deadline
            )
            
            # 트랜잭션 빌드
            transaction = swap_function.build_transaction({
                'from': self.account.address,
                'gas': request.gas_limit,
                'gasPrice': optimized_gas_price,
                'nonce': self.w3.eth.get_transaction_count(self.account.address)
            })
            
            # 트랜잭션 서명
            signed_transaction = self.account.sign_transaction(transaction)
            
            # 트랜잭션 전송
            tx_hash = self.w3.eth.send_raw_transaction(signed_transaction.rawTransaction)
            
            # 트랜잭션 영수증 대기
            receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash)
            
            # 스왑 결과 생성
            result = SwapResult(
                request_id=request.request_id,
                transaction_hash=tx_hash.hex(),
                amount_in=request.amount_in,
                amount_out=amount_out_min,
                gas_used=receipt['gasUsed'],
                gas_price=optimized_gas_price,
                status='success' if receipt['status'] == 1 else 'failed',
                timestamp=datetime.now(),
                block_number=receipt['blockNumber']
            )
            
            logger.info(f"Token swap completed: {result.transaction_hash}")
            return result
            
        except Exception as e:
            logger.error(f"Token swap failed: {e}")
            raise
    
    async def get_swap_quote(self, token_in: str, token_out: str, amount_in: int) -> Dict[str, Any]:
        """스왑 견적 조회"""
        try:
            path = [token_in, token_out]
            
            # 출력량 계산
            amounts_out = await self._get_amounts_out(amount_in, path)
            amount_out = amounts_out[-1]
            
            # 가스비 추정
            estimated_gas = await self._estimate_swap_gas(token_in, token_out, amount_in)
            gas_price = await self.gas_optimizer.get_optimal_gas_price()
            gas_cost = estimated_gas * gas_price
            
            # 슬리피지 계산
            slippage_impact = await self._calculate_slippage_impact(token_in, token_out, amount_in)
            
            return {
                'token_in': token_in,
                'token_out': token_out,
                'amount_in': amount_in,
                'amount_out': amount_out,
                'price_impact': slippage_impact,
                'estimated_gas': estimated_gas,
                'gas_cost': gas_cost,
                'path': path
            }
            
        except Exception as e:
            logger.error(f"Swap quote retrieval failed: {e}")
            raise
    
    async def _call_contract_function(self, function_call) -> Any:
        """컨트랙트 함수 호출"""
        try:
            return function_call.call()
        except Exception as e:
            logger.error(f"Contract function call failed: {e}")
            raise
    
    async def _get_pool_address(self, token0: str, token1: str) -> str:
        """풀 주소 계산"""
        try:
            # Uniswap V2 Factory를 통한 풀 주소 계산
            factory_address = "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f"  # Uniswap V2 Factory
            factory_abi = self._load_factory_abi()
            factory_contract = self.w3.eth.contract(
                address=factory_address,
                abi=factory_abi
            )
            
            pool_address = await self._call_contract_function(
                factory_contract.functions.getPair(token0, token1)
            )
            
            return pool_address
            
        except Exception as e:
            logger.error(f"Pool address calculation failed: {e}")
            raise
    
    async def _get_amounts_out(self, amount_in: int, path: List[str]) -> List[int]:
        """출력량 계산"""
        try:
            amounts = await self._call_contract_function(
                self.router_contract.functions.getAmountsOut(amount_in, path)
            )
            return amounts
            
        except Exception as e:
            logger.error(f"Amounts out calculation failed: {e}")
            raise
    
    async def _estimate_swap_gas(self, token_in: str, token_out: str, amount_in: int) -> int:
        """스왑 가스비 추정"""
        try:
            path = [token_in, token_out]
            
            # 가스비 추정
            gas_estimate = self.router_contract.functions.swapExactTokensForTokens(
                amount_in,
                0,  # amountOutMin
                path,
                self.account.address,
                int(time.time()) + 300  # deadline
            ).estimate_gas({
                'from': self.account.address
            })
            
            return gas_estimate
            
        except Exception as e:
            logger.error(f"Gas estimation failed: {e}")
            return 200000  # 기본 가스비
    
    async def _calculate_slippage_impact(self, token_in: str, token_out: str, amount_in: int) -> float:
        """슬리피지 영향 계산"""
        try:
            # 풀 정보 조회
            pool_info = await self.get_pool_info(token_in, token_out)
            if not pool_info:
                return 0.0
            
            # 슬리피지 계산 (간단한 공식)
            k = pool_info.reserve0 * pool_info.reserve1
            new_reserve0 = pool_info.reserve0 + amount_in
            new_reserve1 = k / new_reserve0
            amount_out = pool_info.reserve1 - new_reserve1
            
            # 가격 영향 계산
            price_impact = (amount_in / pool_info.reserve0) * 100
            
            return min(price_impact, 100.0)
            
        except Exception as e:
            logger.error(f"Slippage impact calculation failed: {e}")
            return 0.0
    
    async def _get_token_price_usd(self, token_address: str) -> float:
        """토큰 USD 가격 조회"""
        try:
            # 실제 구현에서는 Chainlink Oracle 또는 다른 가격 피드 사용
            # 여기서는 시뮬레이션
            
            # 주요 토큰들의 가격 (실제 구현에서는 실시간 조회)
            token_prices = {
                '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2': 2000.0,  # WETH
                '0xA0b86a33E6441b8C4C8C8C8C8C8C8C8C8C8C8C8': 1.0,     # USDC
                '0xdAC17F958D2ee523a2206206994597C13D831ec7': 1.0,     # USDT
            }
            
            return token_prices.get(token_address, 0.0)
            
        except Exception as e:
            logger.error(f"Token price retrieval failed: {e}")
            return 0.0
    
    async def _get_pool_volume_24h(self, pool_address: str) -> float:
        """24시간 거래량 조회"""
        try:
            # 실제 구현에서는 이벤트 로그 분석
            # 여기서는 시뮬레이션
            return 1000000.0  # 100만 달러
            
        except Exception as e:
            logger.error(f"Pool volume retrieval failed: {e}")
            return 0.0
    
    async def _calculate_pool_apy(self, pool_address: str) -> float:
        """풀 APY 계산"""
        try:
            # 실제 구현에서는 복잡한 APY 계산
            # 여기서는 시뮬레이션
            return 15.5  # 15.5% APY
            
        except Exception as e:
            logger.error(f"Pool APY calculation failed: {e}")
            return 0.0
    
    def _load_erc20_abi(self) -> List[Dict[str, Any]]:
        """ERC20 ABI 로드"""
        return [
            {"inputs": [], "name": "symbol", "outputs": [{"name": "", "type": "string"}], "stateMutability": "view", "type": "function"},
            {"inputs": [], "name": "name", "outputs": [{"name": "", "type": "string"}], "stateMutability": "view", "type": "function"},
            {"inputs": [], "name": "decimals", "outputs": [{"name": "", "type": "uint8"}], "stateMutability": "view", "type": "function"},
            {"inputs": [], "name": "totalSupply", "outputs": [{"name": "", "type": "uint256"}], "stateMutability": "view", "type": "function"}
        ]
    
    def _load_pool_abi(self) -> List[Dict[str, Any]]:
        """풀 ABI 로드"""
        return [
            {"inputs": [], "name": "getReserves", "outputs": [
                {"name": "_reserve0", "type": "uint112"},
                {"name": "_reserve1", "type": "uint112"},
                {"name": "_blockTimestampLast", "type": "uint32"}
            ], "stateMutability": "view", "type": "function"}
        ]
    
    def _load_factory_abi(self) -> List[Dict[str, Any]]:
        """팩토리 ABI 로드"""
        return [
            {"inputs": [
                {"name": "tokenA", "type": "address"},
                {"name": "tokenB", "type": "address"}
            ], "name": "getPair", "outputs": [{"name": "pair", "type": "address"}], "stateMutability": "view", "type": "function"}
        ]

class GasOptimizer:
    """가스비 최적화기"""
    
    def __init__(self, w3: Web3):
        self.w3 = w3
        self.gas_price_cache = {}
        self.cache_duration = 60  # 60초 캐시
    
    async def get_optimal_gas_price(self) -> int:
        """최적 가스비 조회"""
        try:
            current_time = time.time()
            
            # 캐시 확인
            if 'gas_price' in self.gas_price_cache:
                cached_price, cached_time = self.gas_price_cache['gas_price']
                if current_time - cached_time < self.cache_duration:
                    return cached_price
            
            # 네트워크 가스비 조회
            gas_price = self.w3.eth.gas_price
            
            # 가스비 최적화 (실제 구현에서는 더 복잡한 로직)
            optimized_price = int(gas_price * 1.1)  # 10% 증가
            
            # 캐시에 저장
            self.gas_price_cache['gas_price'] = (optimized_price, current_time)
            
            return optimized_price
            
        except Exception as e:
            logger.error(f"Gas price optimization failed: {e}")
            return 20000000000  # 20 Gwei 기본값
```

## 🔧 **NFT 거래 시스템**

### 📦 **NFT 마켓플레이스**

```python
# blockchain-integration/nft-trading/nft_marketplace.py
import asyncio
import time
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass
from datetime import datetime
import logging
import json
from web3 import Web3
from eth_account import Account
import ipfshttpclient

logger = logging.getLogger(__name__)

@dataclass
class NFTMetadata:
    """NFT 메타데이터"""
    token_id: int
    name: str
    description: str
    image_url: str
    attributes: List[Dict[str, Any]]
    creator: str
    created_at: datetime
    collection: str

@dataclass
class NFTListing:
    """NFT 리스팅"""
    listing_id: str
    token_address: str
    token_id: int
    seller: str
    price: int
    currency: str
    status: str  # 'active', 'sold', 'cancelled'
    created_at: datetime
    expires_at: datetime

@dataclass
class NFTBid:
    """NFT 입찰"""
    bid_id: str
    listing_id: str
    bidder: str
    amount: int
    currency: str
    status: str  # 'active', 'accepted', 'rejected', 'cancelled'
    created_at: datetime
    expires_at: datetime

class NFTMarketplace:
    """NFT 마켓플레이스"""
    
    def __init__(self, 
                 ethereum_rpc_url: str,
                 marketplace_address: str,
                 private_key: str):
        self.w3 = Web3(Web3.HTTPProvider(ethereum_rpc_url))
        self.marketplace_address = marketplace_address
        self.account = Account.from_key(private_key)
        
        # 마켓플레이스 컨트랙트
        self.marketplace_abi = self._load_marketplace_abi()
        self.marketplace_contract = self.w3.eth.contract(
            address=marketplace_address,
            abi=self.marketplace_abi
        )
        
        # IPFS 클라이언트
        self.ipfs_client = ipfshttpclient.connect()
        
        # NFT 메타데이터 캐시
        self.metadata_cache = {}
        
        # 가격 추정기
        self.price_estimator = NFTPriceEstimator()
        
        logger.info("NFT marketplace initialized")
    
    async def list_nft(self, token_address: str, token_id: int, price: int, 
                      currency: str = "ETH", duration_days: int = 30) -> str:
        """NFT 리스팅"""
        try:
            # NFT 소유권 확인
            if not await self._verify_nft_ownership(token_address, token_id):
                raise Exception("NFT ownership verification failed")
            
            # 마켓플레이스 승인
            await self._approve_marketplace(token_address, token_id)
            
            # 리스팅 생성
            listing_id = f"listing_{int(time.time())}_{token_id}"
            
            # 마켓플레이스 컨트랙트 호출
            list_function = self.marketplace_contract.functions.createListing(
                token_address,
                token_id,
                price,
                int(time.time()) + (duration_days * 24 * 60 * 60)  # 만료 시간
            )
            
            # 트랜잭션 빌드 및 전송
            transaction = list_function.build_transaction({
                'from': self.account.address,
                'gas': 300000,
                'gasPrice': self.w3.eth.gas_price,
                'nonce': self.w3.eth.get_transaction_count(self.account.address)
            })
            
            signed_transaction = self.account.sign_transaction(transaction)
            tx_hash = self.w3.eth.send_raw_transaction(signed_transaction.rawTransaction)
            
            # 트랜잭션 확인
            receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash)
            
            if receipt['status'] == 1:
                logger.info(f"NFT listed successfully: {listing_id}")
                return listing_id
            else:
                raise Exception("NFT listing transaction failed")
                
        except Exception as e:
            logger.error(f"NFT listing failed: {e}")
            raise
    
    async def buy_nft(self, listing_id: str, price: int) -> str:
        """NFT 구매"""
        try:
            # 리스팅 정보 조회
            listing = await self._get_listing_info(listing_id)
            if not listing:
                raise Exception("Listing not found")
            
            if listing.status != 'active':
                raise Exception("Listing is not active")
            
            if price < listing.price:
                raise Exception("Insufficient price")
            
            # 구매 트랜잭션
            buy_function = self.marketplace_contract.functions.buyNFT(listing_id)
            
            transaction = buy_function.build_transaction({
                'from': self.account.address,
                'value': price,
                'gas': 300000,
                'gasPrice': self.w3.eth.gas_price,
                'nonce': self.w3.eth.get_transaction_count(self.account.address)
            })
            
            signed_transaction = self.account.sign_transaction(transaction)
            tx_hash = self.w3.eth.send_raw_transaction(signed_transaction.rawTransaction)
            
            # 트랜잭션 확인
            receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash)
            
            if receipt['status'] == 1:
                logger.info(f"NFT purchased successfully: {listing_id}")
                return tx_hash.hex()
            else:
                raise Exception("NFT purchase transaction failed")
                
        except Exception as e:
            logger.error(f"NFT purchase failed: {e}")
            raise
    
    async def place_bid(self, listing_id: str, amount: int, 
                       currency: str = "ETH", duration_hours: int = 24) -> str:
        """입찰 생성"""
        try:
            # 리스팅 정보 조회
            listing = await self._get_listing_info(listing_id)
            if not listing:
                raise Exception("Listing not found")
            
            if listing.status != 'active':
                raise Exception("Listing is not active")
            
            # 입찰 ID 생성
            bid_id = f"bid_{int(time.time())}_{listing_id}"
            
            # 입찰 트랜잭션
            bid_function = self.marketplace_contract.functions.placeBid(
                listing_id,
                int(time.time()) + (duration_hours * 60 * 60)  # 만료 시간
            )
            
            transaction = bid_function.build_transaction({
                'from': self.account.address,
                'value': amount,
                'gas': 200000,
                'gasPrice': self.w3.eth.gas_price,
                'nonce': self.w3.eth.get_transaction_count(self.account.address)
            })
            
            signed_transaction = self.account.sign_transaction(transaction)
            tx_hash = self.w3.eth.send_raw_transaction(signed_transaction.rawTransaction)
            
            # 트랜잭션 확인
            receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash)
            
            if receipt['status'] == 1:
                logger.info(f"Bid placed successfully: {bid_id}")
                return bid_id
            else:
                raise Exception("Bid placement transaction failed")
                
        except Exception as e:
            logger.error(f"Bid placement failed: {e}")
            raise
    
    async def get_nft_metadata(self, token_address: str, token_id: int) -> Optional[NFTMetadata]:
        """NFT 메타데이터 조회"""
        try:
            cache_key = f"{token_address}_{token_id}"
            
            # 캐시 확인
            if cache_key in self.metadata_cache:
                return self.metadata_cache[cache_key]
            
            # NFT 컨트랙트
            nft_contract = self.w3.eth.contract(
                address=token_address,
                abi=self._load_erc721_abi()
            )
            
            # 토큰 URI 조회
            token_uri = await self._call_contract_function(
                nft_contract.functions.tokenURI(token_id)
            )
            
            # IPFS에서 메타데이터 조회
            if token_uri.startswith('ipfs://'):
                ipfs_hash = token_uri.replace('ipfs://', '')
                metadata_json = self.ipfs_client.cat(ipfs_hash)
                metadata = json.loads(metadata_json)
            else:
                # HTTP URL인 경우
                async with aiohttp.ClientSession() as session:
                    async with session.get(token_uri) as response:
                        metadata = await response.json()
            
            # 메타데이터 파싱
            nft_metadata = NFTMetadata(
                token_id=token_id,
                name=metadata.get('name', ''),
                description=metadata.get('description', ''),
                image_url=metadata.get('image', ''),
                attributes=metadata.get('attributes', []),
                creator=metadata.get('creator', ''),
                created_at=datetime.now(),
                collection=metadata.get('collection', '')
            )
            
            # 캐시에 저장
            self.metadata_cache[cache_key] = nft_metadata
            
            return nft_metadata
            
        except Exception as e:
            logger.error(f"NFT metadata retrieval failed: {e}")
            return None
    
    async def get_nft_price_estimate(self, token_address: str, token_id: int) -> float:
        """NFT 가격 추정"""
        try:
            # 메타데이터 조회
            metadata = await self.get_nft_metadata(token_address, token_id)
            if not metadata:
                return 0.0
            
            # 가격 추정
            estimated_price = await self.price_estimator.estimate_price(metadata)
            
            return estimated_price
            
        except Exception as e:
            logger.error(f"NFT price estimation failed: {e}")
            return 0.0
    
    async def _verify_nft_ownership(self, token_address: str, token_id: int) -> bool:
        """NFT 소유권 확인"""
        try:
            nft_contract = self.w3.eth.contract(
                address=token_address,
                abi=self._load_erc721_abi()
            )
            
            owner = await self._call_contract_function(
                nft_contract.functions.ownerOf(token_id)
            )
            
            return owner.lower() == self.account.address.lower()
            
        except Exception as e:
            logger.error(f"NFT ownership verification failed: {e}")
            return False
    
    async def _approve_marketplace(self, token_address: str, token_id: int):
        """마켓플레이스 승인"""
        try:
            nft_contract = self.w3.eth.contract(
                address=token_address,
                abi=self._load_erc721_abi()
            )
            
            approve_function = nft_contract.functions.approve(
                self.marketplace_address,
                token_id
            )
            
            transaction = approve_function.build_transaction({
                'from': self.account.address,
                'gas': 100000,
                'gasPrice': self.w3.eth.gas_price,
                'nonce': self.w3.eth.get_transaction_count(self.account.address)
            })
            
            signed_transaction = self.account.sign_transaction(transaction)
            tx_hash = self.w3.eth.send_raw_transaction(signed_transaction.rawTransaction)
            
            # 트랜잭션 확인
            receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash)
            
            if receipt['status'] != 1:
                raise Exception("Marketplace approval failed")
                
        except Exception as e:
            logger.error(f"Marketplace approval failed: {e}")
            raise
    
    async def _get_listing_info(self, listing_id: str) -> Optional[NFTListing]:
        """리스팅 정보 조회"""
        try:
            # 실제 구현에서는 컨트랙트에서 리스팅 정보 조회
            # 여기서는 시뮬레이션
            return NFTListing(
                listing_id=listing_id,
                token_address="0x1234567890123456789012345678901234567890",
                token_id=1,
                seller="0xabcdefabcdefabcdefabcdefabcdefabcdefabcd",
                price=1000000000000000000,  # 1 ETH
                currency="ETH",
                status="active",
                created_at=datetime.now(),
                expires_at=datetime.now()
            )
            
        except Exception as e:
            logger.error(f"Listing info retrieval failed: {e}")
            return None
    
    async def _call_contract_function(self, function_call) -> Any:
        """컨트랙트 함수 호출"""
        try:
            return function_call.call()
        except Exception as e:
            logger.error(f"Contract function call failed: {e}")
            raise
    
    def _load_marketplace_abi(self) -> List[Dict[str, Any]]:
        """마켓플레이스 ABI 로드"""
        return [
            {"inputs": [
                {"name": "tokenAddress", "type": "address"},
                {"name": "tokenId", "type": "uint256"},
                {"name": "price", "type": "uint256"},
                {"name": "expiresAt", "type": "uint256"}
            ], "name": "createListing", "outputs": [], "stateMutability": "nonpayable", "type": "function"},
            {"inputs": [{"name": "listingId", "type": "string"}], "name": "buyNFT", "outputs": [], "stateMutability": "payable", "type": "function"},
            {"inputs": [
                {"name": "listingId", "type": "string"},
                {"name": "expiresAt", "type": "uint256"}
            ], "name": "placeBid", "outputs": [], "stateMutability": "payable", "type": "function"}
        ]
    
    def _load_erc721_abi(self) -> List[Dict[str, Any]]:
        """ERC721 ABI 로드"""
        return [
            {"inputs": [{"name": "tokenId", "type": "uint256"}], "name": "ownerOf", "outputs": [{"name": "", "type": "address"}], "stateMutability": "view", "type": "function"},
            {"inputs": [{"name": "tokenId", "type": "uint256"}], "name": "tokenURI", "outputs": [{"name": "", "type": "string"}], "stateMutability": "view", "type": "function"},
            {"inputs": [
                {"name": "to", "type": "address"},
                {"name": "tokenId", "type": "uint256"}
            ], "name": "approve", "outputs": [], "stateMutability": "nonpayable", "type": "function"}
        ]

class NFTPriceEstimator:
    """NFT 가격 추정기"""
    
    async def estimate_price(self, metadata: NFTMetadata) -> float:
        """NFT 가격 추정"""
        try:
            base_price = 0.1  # 기본 가격 0.1 ETH
            
            # 속성 기반 가격 조정
            rarity_score = self._calculate_rarity_score(metadata.attributes)
            base_price *= (1 + rarity_score * 0.5)
            
            # 컬렉션 인기도 기반 조정
            collection_popularity = await self._get_collection_popularity(metadata.collection)
            base_price *= (1 + collection_popularity * 0.3)
            
            # 시장 동향 기반 조정
            market_trend = await self._get_market_trend()
            base_price *= (1 + market_trend * 0.2)
            
            return max(base_price, 0.01)  # 최소 0.01 ETH
            
        except Exception as e:
            logger.error(f"Price estimation failed: {e}")
            return 0.1
    
    def _calculate_rarity_score(self, attributes: List[Dict[str, Any]]) -> float:
        """희귀도 점수 계산"""
        try:
            if not attributes:
                return 0.0
            
            total_score = 0.0
            for attr in attributes:
                trait_type = attr.get('trait_type', '')
                value = attr.get('value', '')
                
                # 특성별 희귀도 점수 (실제 구현에서는 데이터베이스 기반)
                rarity_scores = {
                    'Background': {'Common': 0.1, 'Rare': 0.3, 'Legendary': 0.8},
                    'Eyes': {'Normal': 0.1, 'Laser': 0.5, 'Rainbow': 0.9},
                    'Mouth': {'Smile': 0.1, 'Frown': 0.2, 'Gold': 0.7}
                }
                
                trait_scores = rarity_scores.get(trait_type, {})
                score = trait_scores.get(str(value), 0.1)
                total_score += score
            
            return total_score / len(attributes)
            
        except Exception as e:
            logger.error(f"Rarity score calculation failed: {e}")
            return 0.0
    
    async def _get_collection_popularity(self, collection: str) -> float:
        """컬렉션 인기도 조회"""
        try:
            # 실제 구현에서는 컬렉션 통계 데이터베이스 조회
            # 여기서는 시뮬레이션
            popularity_scores = {
                'Bored Ape Yacht Club': 0.9,
                'CryptoPunks': 0.8,
                'Doodles': 0.7,
                'Azuki': 0.6
            }
            
            return popularity_scores.get(collection, 0.3)
            
        except Exception as e:
            logger.error(f"Collection popularity retrieval failed: {e}")
            return 0.3
    
    async def _get_market_trend(self) -> float:
        """시장 동향 조회"""
        try:
            # 실제 구현에서는 시장 데이터 분석
            # 여기서는 시뮬레이션
            return 0.1  # 10% 상승 추세
            
        except Exception as e:
            logger.error(f"Market trend retrieval failed: {e}")
            return 0.0
```

## 🎯 **다음 단계**

### 📋 **완료된 작업**
- ✅ DeFi 프로토콜 통합 시스템 설계
- ✅ Uniswap 통합 구현
- ✅ NFT 마켓플레이스 구현
- ✅ 가스비 최적화 시스템

### 🔄 **진행 중인 작업**
- 🔄 크로스체인 브리지 시스템
- 🔄 스마트 컨트랙트 시스템
- 🔄 Web3 지갑 통합 시스템

### ⏳ **다음 단계**
1. **크로스체인 브리지** 문서 생성
2. **스마트 컨트랙트** 문서 생성
3. **Web3 지갑 통합** 문서 생성

---

**마지막 업데이트**: 2024-01-31
**다음 업데이트**: 2024-02-01 (크로스체인 브리지)
**블록체인 목표**: < 5초 DeFi 거래, < 30초 크로스체인 전송, < 10초 NFT 거래
**블록체인 성과**: Uniswap 통합, NFT 마켓플레이스, 가스비 최적화, 메타데이터 관리 