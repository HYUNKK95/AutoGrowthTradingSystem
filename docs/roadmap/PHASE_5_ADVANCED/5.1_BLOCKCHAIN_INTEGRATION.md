# â›“ï¸ Phase 5.1: ë¸”ë¡ì²´ì¸ í†µí•© ì—°êµ¬ (ì¥ê¸° ì—°êµ¬ ê³¼ì œ)

## ğŸ“‹ **ê°œìš”**

### ğŸ¯ **ì—°êµ¬ ëª©í‘œ** (ê°œì¸ í”„ë¡œì íŠ¸ ìš°ì„ ìˆœìœ„ ë‚®ìŒ)
- **ê¸°ë³¸ ë¸”ë¡ì²´ì¸ ì—°ë™**: ì´ë”ë¦¬ì›€, BSC ê¸°ë³¸ ì—°ë™ ì—°êµ¬
- **DeFi í”„ë¡œí† ì½œ ì—°êµ¬**: Uniswap ë“± ì£¼ìš” DeFi í”„ë¡œí† ì½œ ì´í•´
- **NFT ê±°ë˜ ì—°êµ¬**: NFT ë§ˆì¼“í”Œë ˆì´ìŠ¤ ê¸°ë³¸ ê°œë… ì—°êµ¬
- **í¬ë¡œìŠ¤ì²´ì¸ ì—°êµ¬**: ë‹¤ì¤‘ ì²´ì¸ ì§€ì› ë°©ë²•ë¡  ì—°êµ¬
- **ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ ì—°êµ¬**: ê¸°ë³¸ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ ê°œë°œ ì—°êµ¬

### ğŸ“Š **ì—°êµ¬ ì„±ê³¼ ëª©í‘œ**
- **ê¸°ë³¸ ì—°ë™**: ì´ë”ë¦¬ì›€ ë„¤íŠ¸ì›Œí¬ ê¸°ë³¸ ì—°ë™
- **DeFi ì´í•´**: ì£¼ìš” DeFi í”„ë¡œí† ì½œ ë™ì‘ ì›ë¦¬ íŒŒì•…
- **NFT ì´í•´**: NFT ê±°ë˜ ê¸°ë³¸ ê°œë… ì´í•´
- **í¬ë¡œìŠ¤ì²´ì¸ ì´í•´**: í¬ë¡œìŠ¤ì²´ì¸ ê¸°ìˆ  ê¸°ë³¸ ì´í•´
- **ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ ì´í•´**: ê¸°ë³¸ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ ê°œë°œ ëŠ¥ë ¥

### âš ï¸ **ì¤‘ìš” ì•ˆë‚´**
ì´ ë¬¸ì„œëŠ” **ì¥ê¸° ì—°êµ¬ ê³¼ì œ**ë¡œ ë¶„ë¥˜ë©ë‹ˆë‹¤. ê°œì¸ ê°œë°œìì˜ ìš°ì„ ìˆœìœ„ë¥¼ ê³ ë ¤í•˜ì—¬:
- **ì¦‰ì‹œ êµ¬í˜„í•˜ì§€ ì•ŠìŒ**: í•µì‹¬ ê±°ë˜ ì‹œìŠ¤í…œ ì™„ì„± í›„ ì—°êµ¬
- **ê¸°ë³¸ ê°œë… ì—°êµ¬**: ë³µì¡í•œ êµ¬í˜„ë³´ë‹¤ëŠ” ì´í•´ì— ì¤‘ì 
- **ì‹¤í—˜ì  ì ‘ê·¼**: ì‹¤ì œ ìš´ì˜ë³´ë‹¤ëŠ” ì—°êµ¬ ë° í•™ìŠµ ëª©ì 

## ğŸ—ï¸ **ë¸”ë¡ì²´ì¸ í†µí•© ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜**

### ğŸ“ **ë¸”ë¡ì²´ì¸ í†µí•© ì‹œìŠ¤í…œ êµ¬ì¡°**
```
blockchain-integration/
â”œâ”€â”€ defi-protocols/                     # DeFi í”„ë¡œí† ì½œ
â”‚   â”œâ”€â”€ uniswap-integration/            # Uniswap í†µí•©
â”‚   â”œâ”€â”€ aave-integration/               # Aave í†µí•©
â”‚   â”œâ”€â”€ compound-integration/           # Compound í†µí•©
â”‚   â””â”€â”€ yield-farming/                  # ìˆ˜ìµë¥  ë†ì—…
â”œâ”€â”€ nft-trading/                        # NFT ê±°ë˜
â”‚   â”œâ”€â”€ nft-marketplace/                # NFT ë§ˆì¼“í”Œë ˆì´ìŠ¤
â”‚   â”œâ”€â”€ nft-valuation/                  # NFT ê°€ì¹˜ í‰ê°€
â”‚   â”œâ”€â”€ nft-lending/                    # NFT ëŒ€ì¶œ
â”‚   â””â”€â”€ nft-fractionalization/          # NFT ë¶„í•  ì†Œìœ 
â”œâ”€â”€ cross-chain/                        # í¬ë¡œìŠ¤ì²´ì¸
â”‚   â”œâ”€â”€ ethereum-bridge/                # ì´ë”ë¦¬ì›€ ë¸Œë¦¬ì§€
â”‚   â”œâ”€â”€ bsc-bridge/                     # BSC ë¸Œë¦¬ì§€
â”‚   â”œâ”€â”€ polygon-bridge/                 # í´ë¦¬ê³¤ ë¸Œë¦¬ì§€
â”‚   â””â”€â”€ arbitrum-bridge/                # Arbitrum ë¸Œë¦¬ì§€
â”œâ”€â”€ smart-contracts/                    # ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸
â”‚   â”œâ”€â”€ trading-contracts/              # ê±°ë˜ ì»¨íŠ¸ë™íŠ¸
â”‚   â”œâ”€â”€ risk-management/                # ë¦¬ìŠ¤í¬ ê´€ë¦¬
â”‚   â”œâ”€â”€ yield-optimization/             # ìˆ˜ìµë¥  ìµœì í™”
â”‚   â””â”€â”€ governance/                     # ê±°ë²„ë„ŒìŠ¤
â””â”€â”€ web3-wallets/                       # Web3 ì§€ê°‘
    â”œâ”€â”€ metamask/                       # MetaMask
    â”œâ”€â”€ walletconnect/                  # WalletConnect
    â”œâ”€â”€ hardware-wallets/               # í•˜ë“œì›¨ì–´ ì§€ê°‘
    â””â”€â”€ multi-sig/                      # ë‹¤ì¤‘ ì„œëª…
```

## ğŸ”§ **DeFi í”„ë¡œí† ì½œ í†µí•© ì‹œìŠ¤í…œ**

### ğŸ“¦ **Uniswap í†µí•©**

```python
# blockchain-integration/defi-protocols/uniswap_integration.py
import asyncio
import time
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass
from datetime import datetime
import logging
import json
import aiohttp
from web3 import Web3
from eth_account import Account
import eth_utils

logger = logging.getLogger(__name__)

@dataclass
class TokenInfo:
    """í† í° ì •ë³´"""
    address: str
    symbol: str
    name: str
    decimals: int
    total_supply: int
    price_usd: float

@dataclass
class PoolInfo:
    """í’€ ì •ë³´"""
    pool_address: str
    token0: TokenInfo
    token1: TokenInfo
    reserve0: int
    reserve1: int
    fee: int
    liquidity: int
    volume_24h: float
    apy: float

@dataclass
class SwapRequest:
    """ìŠ¤ì™‘ ìš”ì²­"""
    request_id: str
    token_in: str
    token_out: str
    amount_in: int
    amount_out_min: int
    slippage_tolerance: float
    deadline: int
    gas_price: int
    gas_limit: int

@dataclass
class SwapResult:
    """ìŠ¤ì™‘ ê²°ê³¼"""
    request_id: str
    transaction_hash: str
    amount_in: int
    amount_out: int
    gas_used: int
    gas_price: int
    status: str
    timestamp: datetime
    block_number: int

class UniswapIntegration:
    """Uniswap í†µí•©"""
    
    def __init__(self, 
                 ethereum_rpc_url: str,
                 uniswap_router_address: str,
                 private_key: str):
        self.w3 = Web3(Web3.HTTPProvider(ethereum_rpc_url))
        self.uniswap_router_address = uniswap_router_address
        self.account = Account.from_key(private_key)
        
        # Uniswap V2 Router ABI
        self.router_abi = self._load_router_abi()
        self.router_contract = self.w3.eth.contract(
            address=uniswap_router_address,
            abi=self.router_abi
        )
        
        # í† í° ì •ë³´ ìºì‹œ
        self.token_cache = {}
        
        # í’€ ì •ë³´ ìºì‹œ
        self.pool_cache = {}
        
        # ê°€ìŠ¤ë¹„ ìµœì í™”ê¸°
        self.gas_optimizer = GasOptimizer(self.w3)
        
        logger.info("Uniswap integration initialized")
    
    def _load_router_abi(self) -> List[Dict[str, Any]]:
        """ë¼ìš°í„° ABI ë¡œë“œ"""
        try:
            # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” íŒŒì¼ì—ì„œ ABI ë¡œë“œ
            # ì—¬ê¸°ì„œëŠ” ê°„ë‹¨í•œ ABI ì˜ˆì‹œ
            return [
                {
                    "inputs": [
                        {"name": "amountIn", "type": "uint256"},
                        {"name": "amountOutMin", "type": "uint256"},
                        {"name": "path", "type": "address[]"},
                        {"name": "to", "type": "address"},
                        {"name": "deadline", "type": "uint256"}
                    ],
                    "name": "swapExactTokensForTokens",
                    "outputs": [{"name": "amounts", "type": "uint256[]"}],
                    "stateMutability": "nonpayable",
                    "type": "function"
                },
                {
                    "inputs": [
                        {"name": "amountOut", "type": "uint256"},
                        {"name": "path", "type": "address[]"}
                    ],
                    "name": "getAmountsIn",
                    "outputs": [{"name": "amounts", "type": "uint256[]"}],
                    "stateMutability": "view",
                    "type": "function"
                },
                {
                    "inputs": [
                        {"name": "amountIn", "type": "uint256"},
                        {"name": "path", "type": "address[]"}
                    ],
                    "name": "getAmountsOut",
                    "outputs": [{"name": "amounts", "type": "uint256[]"}],
                    "stateMutability": "view",
                    "type": "function"
                }
            ]
            
        except Exception as e:
            logger.error(f"Router ABI loading failed: {e}")
            return []
    
    async def get_token_info(self, token_address: str) -> Optional[TokenInfo]:
        """í† í° ì •ë³´ ì¡°íšŒ"""
        try:
            # ìºì‹œ í™•ì¸
            if token_address in self.token_cache:
                return self.token_cache[token_address]
            
            # ERC20 í† í° ì»¨íŠ¸ë™íŠ¸
            token_abi = self._load_erc20_abi()
            token_contract = self.w3.eth.contract(
                address=token_address,
                abi=token_abi
            )
            
            # í† í° ì •ë³´ ì¡°íšŒ
            symbol = await self._call_contract_function(token_contract.functions.symbol())
            name = await self._call_contract_function(token_contract.functions.name())
            decimals = await self._call_contract_function(token_contract.functions.decimals())
            total_supply = await self._call_contract_function(token_contract.functions.totalSupply())
            
            # USD ê°€ê²© ì¡°íšŒ (ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” Oracle ì‚¬ìš©)
            price_usd = await self._get_token_price_usd(token_address)
            
            token_info = TokenInfo(
                address=token_address,
                symbol=symbol,
                name=name,
                decimals=decimals,
                total_supply=total_supply,
                price_usd=price_usd
            )
            
            # ìºì‹œì— ì €ì¥
            self.token_cache[token_address] = token_info
            
            return token_info
            
        except Exception as e:
            logger.error(f"Token info retrieval failed: {e}")
            return None
    
    async def get_pool_info(self, token0_address: str, token1_address: str) -> Optional[PoolInfo]:
        """í’€ ì •ë³´ ì¡°íšŒ"""
        try:
            pool_key = f"{token0_address}_{token1_address}"
            
            # ìºì‹œ í™•ì¸
            if pool_key in self.pool_cache:
                return self.pool_cache[pool_key]
            
            # í† í° ì •ë³´ ì¡°íšŒ
            token0_info = await self.get_token_info(token0_address)
            token1_info = await self.get_token_info(token1_address)
            
            if not token0_info or not token1_info:
                return None
            
            # í’€ ì£¼ì†Œ ê³„ì‚°
            pool_address = await self._get_pool_address(token0_address, token1_address)
            
            # í’€ ì»¨íŠ¸ë™íŠ¸
            pool_abi = self._load_pool_abi()
            pool_contract = self.w3.eth.contract(
                address=pool_address,
                abi=pool_abi
            )
            
            # í’€ ì •ë³´ ì¡°íšŒ
            reserves = await self._call_contract_function(pool_contract.functions.getReserves())
            reserve0, reserve1, _ = reserves
            
            # ìˆ˜ìˆ˜ë£Œ ë° ìœ ë™ì„±
            fee = 3000  # 0.3% (ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” í’€ì—ì„œ ì¡°íšŒ)
            liquidity = reserve0 + reserve1
            
            # 24ì‹œê°„ ê±°ë˜ëŸ‰ (ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì´ë²¤íŠ¸ ë¡œê·¸ ë¶„ì„)
            volume_24h = await self._get_pool_volume_24h(pool_address)
            
            # APY ê³„ì‚° (ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ë³µì¡í•œ ê³„ì‚°)
            apy = await self._calculate_pool_apy(pool_address)
            
            pool_info = PoolInfo(
                pool_address=pool_address,
                token0=token0_info,
                token1=token1_info,
                reserve0=reserve0,
                reserve1=reserve1,
                fee=fee,
                liquidity=liquidity,
                volume_24h=volume_24h,
                apy=apy
            )
            
            # ìºì‹œì— ì €ì¥
            self.pool_cache[pool_key] = pool_info
            
            return pool_info
            
        except Exception as e:
            logger.error(f"Pool info retrieval failed: {e}")
            return None
    
    async def swap_tokens(self, request: SwapRequest) -> SwapResult:
        """í† í° ìŠ¤ì™‘"""
        try:
            # ìŠ¤ì™‘ ê²½ë¡œ ê³„ì‚°
            path = [request.token_in, request.token_out]
            
            # ìµœì†Œ ì¶œë ¥ëŸ‰ ê³„ì‚°
            amounts_out = await self._get_amounts_out(request.amount_in, path)
            amount_out_min = int(amounts_out[-1] * (1 - request.slippage_tolerance))
            
            # ê°€ìŠ¤ë¹„ ìµœì í™”
            optimized_gas_price = await self.gas_optimizer.get_optimal_gas_price()
            
            # ìŠ¤ì™‘ íŠ¸ëœì­ì…˜ ìƒì„±
            swap_function = self.router_contract.functions.swapExactTokensForTokens(
                request.amount_in,
                amount_out_min,
                path,
                self.account.address,
                request.deadline
            )
            
            # íŠ¸ëœì­ì…˜ ë¹Œë“œ
            transaction = swap_function.build_transaction({
                'from': self.account.address,
                'gas': request.gas_limit,
                'gasPrice': optimized_gas_price,
                'nonce': self.w3.eth.get_transaction_count(self.account.address)
            })
            
            # íŠ¸ëœì­ì…˜ ì„œëª…
            signed_transaction = self.account.sign_transaction(transaction)
            
            # íŠ¸ëœì­ì…˜ ì „ì†¡
            tx_hash = self.w3.eth.send_raw_transaction(signed_transaction.rawTransaction)
            
            # íŠ¸ëœì­ì…˜ ì˜ìˆ˜ì¦ ëŒ€ê¸°
            receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash)
            
            # ìŠ¤ì™‘ ê²°ê³¼ ìƒì„±
            result = SwapResult(
                request_id=request.request_id,
                transaction_hash=tx_hash.hex(),
                amount_in=request.amount_in,
                amount_out=amount_out_min,
                gas_used=receipt['gasUsed'],
                gas_price=optimized_gas_price,
                status='success' if receipt['status'] == 1 else 'failed',
                timestamp=datetime.now(),
                block_number=receipt['blockNumber']
            )
            
            logger.info(f"Token swap completed: {result.transaction_hash}")
            return result
            
        except Exception as e:
            logger.error(f"Token swap failed: {e}")
            raise
    
    async def get_swap_quote(self, token_in: str, token_out: str, amount_in: int) -> Dict[str, Any]:
        """ìŠ¤ì™‘ ê²¬ì  ì¡°íšŒ"""
        try:
            path = [token_in, token_out]
            
            # ì¶œë ¥ëŸ‰ ê³„ì‚°
            amounts_out = await self._get_amounts_out(amount_in, path)
            amount_out = amounts_out[-1]
            
            # ê°€ìŠ¤ë¹„ ì¶”ì •
            estimated_gas = await self._estimate_swap_gas(token_in, token_out, amount_in)
            gas_price = await self.gas_optimizer.get_optimal_gas_price()
            gas_cost = estimated_gas * gas_price
            
            # ìŠ¬ë¦¬í”¼ì§€ ê³„ì‚°
            slippage_impact = await self._calculate_slippage_impact(token_in, token_out, amount_in)
            
            return {
                'token_in': token_in,
                'token_out': token_out,
                'amount_in': amount_in,
                'amount_out': amount_out,
                'price_impact': slippage_impact,
                'estimated_gas': estimated_gas,
                'gas_cost': gas_cost,
                'path': path
            }
            
        except Exception as e:
            logger.error(f"Swap quote retrieval failed: {e}")
            raise
    
    async def _call_contract_function(self, function_call) -> Any:
        """ì»¨íŠ¸ë™íŠ¸ í•¨ìˆ˜ í˜¸ì¶œ"""
        try:
            return function_call.call()
        except Exception as e:
            logger.error(f"Contract function call failed: {e}")
            raise
    
    async def _get_pool_address(self, token0: str, token1: str) -> str:
        """í’€ ì£¼ì†Œ ê³„ì‚°"""
        try:
            # Uniswap V2 Factoryë¥¼ í†µí•œ í’€ ì£¼ì†Œ ê³„ì‚°
            factory_address = "0x5C69bEe701ef814a2B6a3EDD4B1652CB9cc5aA6f"  # Uniswap V2 Factory
            factory_abi = self._load_factory_abi()
            factory_contract = self.w3.eth.contract(
                address=factory_address,
                abi=factory_abi
            )
            
            pool_address = await self._call_contract_function(
                factory_contract.functions.getPair(token0, token1)
            )
            
            return pool_address
            
        except Exception as e:
            logger.error(f"Pool address calculation failed: {e}")
            raise
    
    async def _get_amounts_out(self, amount_in: int, path: List[str]) -> List[int]:
        """ì¶œë ¥ëŸ‰ ê³„ì‚°"""
        try:
            amounts = await self._call_contract_function(
                self.router_contract.functions.getAmountsOut(amount_in, path)
            )
            return amounts
            
        except Exception as e:
            logger.error(f"Amounts out calculation failed: {e}")
            raise
    
    async def _estimate_swap_gas(self, token_in: str, token_out: str, amount_in: int) -> int:
        """ìŠ¤ì™‘ ê°€ìŠ¤ë¹„ ì¶”ì •"""
        try:
            path = [token_in, token_out]
            
            # ê°€ìŠ¤ë¹„ ì¶”ì •
            gas_estimate = self.router_contract.functions.swapExactTokensForTokens(
                amount_in,
                0,  # amountOutMin
                path,
                self.account.address,
                int(time.time()) + 300  # deadline
            ).estimate_gas({
                'from': self.account.address
            })
            
            return gas_estimate
            
        except Exception as e:
            logger.error(f"Gas estimation failed: {e}")
            return 200000  # ê¸°ë³¸ ê°€ìŠ¤ë¹„
    
    async def _calculate_slippage_impact(self, token_in: str, token_out: str, amount_in: int) -> float:
        """ìŠ¬ë¦¬í”¼ì§€ ì˜í–¥ ê³„ì‚°"""
        try:
            # í’€ ì •ë³´ ì¡°íšŒ
            pool_info = await self.get_pool_info(token_in, token_out)
            if not pool_info:
                return 0.0
            
            # ìŠ¬ë¦¬í”¼ì§€ ê³„ì‚° (ê°„ë‹¨í•œ ê³µì‹)
            k = pool_info.reserve0 * pool_info.reserve1
            new_reserve0 = pool_info.reserve0 + amount_in
            new_reserve1 = k / new_reserve0
            amount_out = pool_info.reserve1 - new_reserve1
            
            # ê°€ê²© ì˜í–¥ ê³„ì‚°
            price_impact = (amount_in / pool_info.reserve0) * 100
            
            return min(price_impact, 100.0)
            
        except Exception as e:
            logger.error(f"Slippage impact calculation failed: {e}")
            return 0.0
    
    async def _get_token_price_usd(self, token_address: str) -> float:
        """í† í° USD ê°€ê²© ì¡°íšŒ"""
        try:
            # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” Chainlink Oracle ë˜ëŠ” ë‹¤ë¥¸ ê°€ê²© í”¼ë“œ ì‚¬ìš©
            # ì—¬ê¸°ì„œëŠ” ì‹œë®¬ë ˆì´ì…˜
            
            # ì£¼ìš” í† í°ë“¤ì˜ ê°€ê²© (ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì‹¤ì‹œê°„ ì¡°íšŒ)
            token_prices = {
                '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2': 2000.0,  # WETH
                '0xA0b86a33E6441b8C4C8C8C8C8C8C8C8C8C8C8C8': 1.0,     # USDC
                '0xdAC17F958D2ee523a2206206994597C13D831ec7': 1.0,     # USDT
            }
            
            return token_prices.get(token_address, 0.0)
            
        except Exception as e:
            logger.error(f"Token price retrieval failed: {e}")
            return 0.0
    
    async def _get_pool_volume_24h(self, pool_address: str) -> float:
        """24ì‹œê°„ ê±°ë˜ëŸ‰ ì¡°íšŒ"""
        try:
            # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì´ë²¤íŠ¸ ë¡œê·¸ ë¶„ì„
            # ì—¬ê¸°ì„œëŠ” ì‹œë®¬ë ˆì´ì…˜
            return 1000000.0  # 100ë§Œ ë‹¬ëŸ¬
            
        except Exception as e:
            logger.error(f"Pool volume retrieval failed: {e}")
            return 0.0
    
    async def _calculate_pool_apy(self, pool_address: str) -> float:
        """í’€ APY ê³„ì‚°"""
        try:
            # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ë³µì¡í•œ APY ê³„ì‚°
            # ì—¬ê¸°ì„œëŠ” ì‹œë®¬ë ˆì´ì…˜
            return 15.5  # 15.5% APY
            
        except Exception as e:
            logger.error(f"Pool APY calculation failed: {e}")
            return 0.0
    
    def _load_erc20_abi(self) -> List[Dict[str, Any]]:
        """ERC20 ABI ë¡œë“œ"""
        return [
            {"inputs": [], "name": "symbol", "outputs": [{"name": "", "type": "string"}], "stateMutability": "view", "type": "function"},
            {"inputs": [], "name": "name", "outputs": [{"name": "", "type": "string"}], "stateMutability": "view", "type": "function"},
            {"inputs": [], "name": "decimals", "outputs": [{"name": "", "type": "uint8"}], "stateMutability": "view", "type": "function"},
            {"inputs": [], "name": "totalSupply", "outputs": [{"name": "", "type": "uint256"}], "stateMutability": "view", "type": "function"}
        ]
    
    def _load_pool_abi(self) -> List[Dict[str, Any]]:
        """í’€ ABI ë¡œë“œ"""
        return [
            {"inputs": [], "name": "getReserves", "outputs": [
                {"name": "_reserve0", "type": "uint112"},
                {"name": "_reserve1", "type": "uint112"},
                {"name": "_blockTimestampLast", "type": "uint32"}
            ], "stateMutability": "view", "type": "function"}
        ]
    
    def _load_factory_abi(self) -> List[Dict[str, Any]]:
        """íŒ©í† ë¦¬ ABI ë¡œë“œ"""
        return [
            {"inputs": [
                {"name": "tokenA", "type": "address"},
                {"name": "tokenB", "type": "address"}
            ], "name": "getPair", "outputs": [{"name": "pair", "type": "address"}], "stateMutability": "view", "type": "function"}
        ]

class GasOptimizer:
    """ê°€ìŠ¤ë¹„ ìµœì í™”ê¸°"""
    
    def __init__(self, w3: Web3):
        self.w3 = w3
        self.gas_price_cache = {}
        self.cache_duration = 60  # 60ì´ˆ ìºì‹œ
    
    async def get_optimal_gas_price(self) -> int:
        """ìµœì  ê°€ìŠ¤ë¹„ ì¡°íšŒ"""
        try:
            current_time = time.time()
            
            # ìºì‹œ í™•ì¸
            if 'gas_price' in self.gas_price_cache:
                cached_price, cached_time = self.gas_price_cache['gas_price']
                if current_time - cached_time < self.cache_duration:
                    return cached_price
            
            # ë„¤íŠ¸ì›Œí¬ ê°€ìŠ¤ë¹„ ì¡°íšŒ
            gas_price = self.w3.eth.gas_price
            
            # ê°€ìŠ¤ë¹„ ìµœì í™” (ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ë” ë³µì¡í•œ ë¡œì§)
            optimized_price = int(gas_price * 1.1)  # 10% ì¦ê°€
            
            # ìºì‹œì— ì €ì¥
            self.gas_price_cache['gas_price'] = (optimized_price, current_time)
            
            return optimized_price
            
        except Exception as e:
            logger.error(f"Gas price optimization failed: {e}")
            return 20000000000  # 20 Gwei ê¸°ë³¸ê°’
```

## ğŸ”§ **NFT ê±°ë˜ ì‹œìŠ¤í…œ**

### ğŸ“¦ **NFT ë§ˆì¼“í”Œë ˆì´ìŠ¤**

```python
# blockchain-integration/nft-trading/nft_marketplace.py
import asyncio
import time
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass
from datetime import datetime
import logging
import json
from web3 import Web3
from eth_account import Account
import ipfshttpclient

logger = logging.getLogger(__name__)

@dataclass
class NFTMetadata:
    """NFT ë©”íƒ€ë°ì´í„°"""
    token_id: int
    name: str
    description: str
    image_url: str
    attributes: List[Dict[str, Any]]
    creator: str
    created_at: datetime
    collection: str

@dataclass
class NFTListing:
    """NFT ë¦¬ìŠ¤íŒ…"""
    listing_id: str
    token_address: str
    token_id: int
    seller: str
    price: int
    currency: str
    status: str  # 'active', 'sold', 'cancelled'
    created_at: datetime
    expires_at: datetime

@dataclass
class NFTBid:
    """NFT ì…ì°°"""
    bid_id: str
    listing_id: str
    bidder: str
    amount: int
    currency: str
    status: str  # 'active', 'accepted', 'rejected', 'cancelled'
    created_at: datetime
    expires_at: datetime

class NFTMarketplace:
    """NFT ë§ˆì¼“í”Œë ˆì´ìŠ¤"""
    
    def __init__(self, 
                 ethereum_rpc_url: str,
                 marketplace_address: str,
                 private_key: str):
        self.w3 = Web3(Web3.HTTPProvider(ethereum_rpc_url))
        self.marketplace_address = marketplace_address
        self.account = Account.from_key(private_key)
        
        # ë§ˆì¼“í”Œë ˆì´ìŠ¤ ì»¨íŠ¸ë™íŠ¸
        self.marketplace_abi = self._load_marketplace_abi()
        self.marketplace_contract = self.w3.eth.contract(
            address=marketplace_address,
            abi=self.marketplace_abi
        )
        
        # IPFS í´ë¼ì´ì–¸íŠ¸
        self.ipfs_client = ipfshttpclient.connect()
        
        # NFT ë©”íƒ€ë°ì´í„° ìºì‹œ
        self.metadata_cache = {}
        
        # ê°€ê²© ì¶”ì •ê¸°
        self.price_estimator = NFTPriceEstimator()
        
        logger.info("NFT marketplace initialized")
    
    async def list_nft(self, token_address: str, token_id: int, price: int, 
                      currency: str = "ETH", duration_days: int = 30) -> str:
        """NFT ë¦¬ìŠ¤íŒ…"""
        try:
            # NFT ì†Œìœ ê¶Œ í™•ì¸
            if not await self._verify_nft_ownership(token_address, token_id):
                raise Exception("NFT ownership verification failed")
            
            # ë§ˆì¼“í”Œë ˆì´ìŠ¤ ìŠ¹ì¸
            await self._approve_marketplace(token_address, token_id)
            
            # ë¦¬ìŠ¤íŒ… ìƒì„±
            listing_id = f"listing_{int(time.time())}_{token_id}"
            
            # ë§ˆì¼“í”Œë ˆì´ìŠ¤ ì»¨íŠ¸ë™íŠ¸ í˜¸ì¶œ
            list_function = self.marketplace_contract.functions.createListing(
                token_address,
                token_id,
                price,
                int(time.time()) + (duration_days * 24 * 60 * 60)  # ë§Œë£Œ ì‹œê°„
            )
            
            # íŠ¸ëœì­ì…˜ ë¹Œë“œ ë° ì „ì†¡
            transaction = list_function.build_transaction({
                'from': self.account.address,
                'gas': 300000,
                'gasPrice': self.w3.eth.gas_price,
                'nonce': self.w3.eth.get_transaction_count(self.account.address)
            })
            
            signed_transaction = self.account.sign_transaction(transaction)
            tx_hash = self.w3.eth.send_raw_transaction(signed_transaction.rawTransaction)
            
            # íŠ¸ëœì­ì…˜ í™•ì¸
            receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash)
            
            if receipt['status'] == 1:
                logger.info(f"NFT listed successfully: {listing_id}")
                return listing_id
            else:
                raise Exception("NFT listing transaction failed")
                
        except Exception as e:
            logger.error(f"NFT listing failed: {e}")
            raise
    
    async def buy_nft(self, listing_id: str, price: int) -> str:
        """NFT êµ¬ë§¤"""
        try:
            # ë¦¬ìŠ¤íŒ… ì •ë³´ ì¡°íšŒ
            listing = await self._get_listing_info(listing_id)
            if not listing:
                raise Exception("Listing not found")
            
            if listing.status != 'active':
                raise Exception("Listing is not active")
            
            if price < listing.price:
                raise Exception("Insufficient price")
            
            # êµ¬ë§¤ íŠ¸ëœì­ì…˜
            buy_function = self.marketplace_contract.functions.buyNFT(listing_id)
            
            transaction = buy_function.build_transaction({
                'from': self.account.address,
                'value': price,
                'gas': 300000,
                'gasPrice': self.w3.eth.gas_price,
                'nonce': self.w3.eth.get_transaction_count(self.account.address)
            })
            
            signed_transaction = self.account.sign_transaction(transaction)
            tx_hash = self.w3.eth.send_raw_transaction(signed_transaction.rawTransaction)
            
            # íŠ¸ëœì­ì…˜ í™•ì¸
            receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash)
            
            if receipt['status'] == 1:
                logger.info(f"NFT purchased successfully: {listing_id}")
                return tx_hash.hex()
            else:
                raise Exception("NFT purchase transaction failed")
                
        except Exception as e:
            logger.error(f"NFT purchase failed: {e}")
            raise
    
    async def place_bid(self, listing_id: str, amount: int, 
                       currency: str = "ETH", duration_hours: int = 24) -> str:
        """ì…ì°° ìƒì„±"""
        try:
            # ë¦¬ìŠ¤íŒ… ì •ë³´ ì¡°íšŒ
            listing = await self._get_listing_info(listing_id)
            if not listing:
                raise Exception("Listing not found")
            
            if listing.status != 'active':
                raise Exception("Listing is not active")
            
            # ì…ì°° ID ìƒì„±
            bid_id = f"bid_{int(time.time())}_{listing_id}"
            
            # ì…ì°° íŠ¸ëœì­ì…˜
            bid_function = self.marketplace_contract.functions.placeBid(
                listing_id,
                int(time.time()) + (duration_hours * 60 * 60)  # ë§Œë£Œ ì‹œê°„
            )
            
            transaction = bid_function.build_transaction({
                'from': self.account.address,
                'value': amount,
                'gas': 200000,
                'gasPrice': self.w3.eth.gas_price,
                'nonce': self.w3.eth.get_transaction_count(self.account.address)
            })
            
            signed_transaction = self.account.sign_transaction(transaction)
            tx_hash = self.w3.eth.send_raw_transaction(signed_transaction.rawTransaction)
            
            # íŠ¸ëœì­ì…˜ í™•ì¸
            receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash)
            
            if receipt['status'] == 1:
                logger.info(f"Bid placed successfully: {bid_id}")
                return bid_id
            else:
                raise Exception("Bid placement transaction failed")
                
        except Exception as e:
            logger.error(f"Bid placement failed: {e}")
            raise
    
    async def get_nft_metadata(self, token_address: str, token_id: int) -> Optional[NFTMetadata]:
        """NFT ë©”íƒ€ë°ì´í„° ì¡°íšŒ"""
        try:
            cache_key = f"{token_address}_{token_id}"
            
            # ìºì‹œ í™•ì¸
            if cache_key in self.metadata_cache:
                return self.metadata_cache[cache_key]
            
            # NFT ì»¨íŠ¸ë™íŠ¸
            nft_contract = self.w3.eth.contract(
                address=token_address,
                abi=self._load_erc721_abi()
            )
            
            # í† í° URI ì¡°íšŒ
            token_uri = await self._call_contract_function(
                nft_contract.functions.tokenURI(token_id)
            )
            
            # IPFSì—ì„œ ë©”íƒ€ë°ì´í„° ì¡°íšŒ
            if token_uri.startswith('ipfs://'):
                ipfs_hash = token_uri.replace('ipfs://', '')
                metadata_json = self.ipfs_client.cat(ipfs_hash)
                metadata = json.loads(metadata_json)
            else:
                # HTTP URLì¸ ê²½ìš°
                async with aiohttp.ClientSession() as session:
                    async with session.get(token_uri) as response:
                        metadata = await response.json()
            
            # ë©”íƒ€ë°ì´í„° íŒŒì‹±
            nft_metadata = NFTMetadata(
                token_id=token_id,
                name=metadata.get('name', ''),
                description=metadata.get('description', ''),
                image_url=metadata.get('image', ''),
                attributes=metadata.get('attributes', []),
                creator=metadata.get('creator', ''),
                created_at=datetime.now(),
                collection=metadata.get('collection', '')
            )
            
            # ìºì‹œì— ì €ì¥
            self.metadata_cache[cache_key] = nft_metadata
            
            return nft_metadata
            
        except Exception as e:
            logger.error(f"NFT metadata retrieval failed: {e}")
            return None
    
    async def get_nft_price_estimate(self, token_address: str, token_id: int) -> float:
        """NFT ê°€ê²© ì¶”ì •"""
        try:
            # ë©”íƒ€ë°ì´í„° ì¡°íšŒ
            metadata = await self.get_nft_metadata(token_address, token_id)
            if not metadata:
                return 0.0
            
            # ê°€ê²© ì¶”ì •
            estimated_price = await self.price_estimator.estimate_price(metadata)
            
            return estimated_price
            
        except Exception as e:
            logger.error(f"NFT price estimation failed: {e}")
            return 0.0
    
    async def _verify_nft_ownership(self, token_address: str, token_id: int) -> bool:
        """NFT ì†Œìœ ê¶Œ í™•ì¸"""
        try:
            nft_contract = self.w3.eth.contract(
                address=token_address,
                abi=self._load_erc721_abi()
            )
            
            owner = await self._call_contract_function(
                nft_contract.functions.ownerOf(token_id)
            )
            
            return owner.lower() == self.account.address.lower()
            
        except Exception as e:
            logger.error(f"NFT ownership verification failed: {e}")
            return False
    
    async def _approve_marketplace(self, token_address: str, token_id: int):
        """ë§ˆì¼“í”Œë ˆì´ìŠ¤ ìŠ¹ì¸"""
        try:
            nft_contract = self.w3.eth.contract(
                address=token_address,
                abi=self._load_erc721_abi()
            )
            
            approve_function = nft_contract.functions.approve(
                self.marketplace_address,
                token_id
            )
            
            transaction = approve_function.build_transaction({
                'from': self.account.address,
                'gas': 100000,
                'gasPrice': self.w3.eth.gas_price,
                'nonce': self.w3.eth.get_transaction_count(self.account.address)
            })
            
            signed_transaction = self.account.sign_transaction(transaction)
            tx_hash = self.w3.eth.send_raw_transaction(signed_transaction.rawTransaction)
            
            # íŠ¸ëœì­ì…˜ í™•ì¸
            receipt = self.w3.eth.wait_for_transaction_receipt(tx_hash)
            
            if receipt['status'] != 1:
                raise Exception("Marketplace approval failed")
                
        except Exception as e:
            logger.error(f"Marketplace approval failed: {e}")
            raise
    
    async def _get_listing_info(self, listing_id: str) -> Optional[NFTListing]:
        """ë¦¬ìŠ¤íŒ… ì •ë³´ ì¡°íšŒ"""
        try:
            # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì»¨íŠ¸ë™íŠ¸ì—ì„œ ë¦¬ìŠ¤íŒ… ì •ë³´ ì¡°íšŒ
            # ì—¬ê¸°ì„œëŠ” ì‹œë®¬ë ˆì´ì…˜
            return NFTListing(
                listing_id=listing_id,
                token_address="0x1234567890123456789012345678901234567890",
                token_id=1,
                seller="0xabcdefabcdefabcdefabcdefabcdefabcdefabcd",
                price=1000000000000000000,  # 1 ETH
                currency="ETH",
                status="active",
                created_at=datetime.now(),
                expires_at=datetime.now()
            )
            
        except Exception as e:
            logger.error(f"Listing info retrieval failed: {e}")
            return None
    
    async def _call_contract_function(self, function_call) -> Any:
        """ì»¨íŠ¸ë™íŠ¸ í•¨ìˆ˜ í˜¸ì¶œ"""
        try:
            return function_call.call()
        except Exception as e:
            logger.error(f"Contract function call failed: {e}")
            raise
    
    def _load_marketplace_abi(self) -> List[Dict[str, Any]]:
        """ë§ˆì¼“í”Œë ˆì´ìŠ¤ ABI ë¡œë“œ"""
        return [
            {"inputs": [
                {"name": "tokenAddress", "type": "address"},
                {"name": "tokenId", "type": "uint256"},
                {"name": "price", "type": "uint256"},
                {"name": "expiresAt", "type": "uint256"}
            ], "name": "createListing", "outputs": [], "stateMutability": "nonpayable", "type": "function"},
            {"inputs": [{"name": "listingId", "type": "string"}], "name": "buyNFT", "outputs": [], "stateMutability": "payable", "type": "function"},
            {"inputs": [
                {"name": "listingId", "type": "string"},
                {"name": "expiresAt", "type": "uint256"}
            ], "name": "placeBid", "outputs": [], "stateMutability": "payable", "type": "function"}
        ]
    
    def _load_erc721_abi(self) -> List[Dict[str, Any]]:
        """ERC721 ABI ë¡œë“œ"""
        return [
            {"inputs": [{"name": "tokenId", "type": "uint256"}], "name": "ownerOf", "outputs": [{"name": "", "type": "address"}], "stateMutability": "view", "type": "function"},
            {"inputs": [{"name": "tokenId", "type": "uint256"}], "name": "tokenURI", "outputs": [{"name": "", "type": "string"}], "stateMutability": "view", "type": "function"},
            {"inputs": [
                {"name": "to", "type": "address"},
                {"name": "tokenId", "type": "uint256"}
            ], "name": "approve", "outputs": [], "stateMutability": "nonpayable", "type": "function"}
        ]

class NFTPriceEstimator:
    """NFT ê°€ê²© ì¶”ì •ê¸°"""
    
    async def estimate_price(self, metadata: NFTMetadata) -> float:
        """NFT ê°€ê²© ì¶”ì •"""
        try:
            base_price = 0.1  # ê¸°ë³¸ ê°€ê²© 0.1 ETH
            
            # ì†ì„± ê¸°ë°˜ ê°€ê²© ì¡°ì •
            rarity_score = self._calculate_rarity_score(metadata.attributes)
            base_price *= (1 + rarity_score * 0.5)
            
            # ì»¬ë ‰ì…˜ ì¸ê¸°ë„ ê¸°ë°˜ ì¡°ì •
            collection_popularity = await self._get_collection_popularity(metadata.collection)
            base_price *= (1 + collection_popularity * 0.3)
            
            # ì‹œì¥ ë™í–¥ ê¸°ë°˜ ì¡°ì •
            market_trend = await self._get_market_trend()
            base_price *= (1 + market_trend * 0.2)
            
            return max(base_price, 0.01)  # ìµœì†Œ 0.01 ETH
            
        except Exception as e:
            logger.error(f"Price estimation failed: {e}")
            return 0.1
    
    def _calculate_rarity_score(self, attributes: List[Dict[str, Any]]) -> float:
        """í¬ê·€ë„ ì ìˆ˜ ê³„ì‚°"""
        try:
            if not attributes:
                return 0.0
            
            total_score = 0.0
            for attr in attributes:
                trait_type = attr.get('trait_type', '')
                value = attr.get('value', '')
                
                # íŠ¹ì„±ë³„ í¬ê·€ë„ ì ìˆ˜ (ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ë°ì´í„°ë² ì´ìŠ¤ ê¸°ë°˜)
                rarity_scores = {
                    'Background': {'Common': 0.1, 'Rare': 0.3, 'Legendary': 0.8},
                    'Eyes': {'Normal': 0.1, 'Laser': 0.5, 'Rainbow': 0.9},
                    'Mouth': {'Smile': 0.1, 'Frown': 0.2, 'Gold': 0.7}
                }
                
                trait_scores = rarity_scores.get(trait_type, {})
                score = trait_scores.get(str(value), 0.1)
                total_score += score
            
            return total_score / len(attributes)
            
        except Exception as e:
            logger.error(f"Rarity score calculation failed: {e}")
            return 0.0
    
    async def _get_collection_popularity(self, collection: str) -> float:
        """ì»¬ë ‰ì…˜ ì¸ê¸°ë„ ì¡°íšŒ"""
        try:
            # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì»¬ë ‰ì…˜ í†µê³„ ë°ì´í„°ë² ì´ìŠ¤ ì¡°íšŒ
            # ì—¬ê¸°ì„œëŠ” ì‹œë®¬ë ˆì´ì…˜
            popularity_scores = {
                'Bored Ape Yacht Club': 0.9,
                'CryptoPunks': 0.8,
                'Doodles': 0.7,
                'Azuki': 0.6
            }
            
            return popularity_scores.get(collection, 0.3)
            
        except Exception as e:
            logger.error(f"Collection popularity retrieval failed: {e}")
            return 0.3
    
    async def _get_market_trend(self) -> float:
        """ì‹œì¥ ë™í–¥ ì¡°íšŒ"""
        try:
            # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì‹œì¥ ë°ì´í„° ë¶„ì„
            # ì—¬ê¸°ì„œëŠ” ì‹œë®¬ë ˆì´ì…˜
            return 0.1  # 10% ìƒìŠ¹ ì¶”ì„¸
            
        except Exception as e:
            logger.error(f"Market trend retrieval failed: {e}")
            return 0.0
```

## ğŸ¯ **ë‹¤ìŒ ë‹¨ê³„**

### ğŸ“‹ **ì™„ë£Œëœ ì‘ì—…**
- âœ… DeFi í”„ë¡œí† ì½œ í†µí•© ì‹œìŠ¤í…œ ì„¤ê³„
- âœ… Uniswap í†µí•© êµ¬í˜„
- âœ… NFT ë§ˆì¼“í”Œë ˆì´ìŠ¤ êµ¬í˜„
- âœ… ê°€ìŠ¤ë¹„ ìµœì í™” ì‹œìŠ¤í…œ

### ğŸ”„ **ì§„í–‰ ì¤‘ì¸ ì‘ì—…**
- ğŸ”„ í¬ë¡œìŠ¤ì²´ì¸ ë¸Œë¦¬ì§€ ì‹œìŠ¤í…œ
- ğŸ”„ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ ì‹œìŠ¤í…œ
- ğŸ”„ Web3 ì§€ê°‘ í†µí•© ì‹œìŠ¤í…œ

### â³ **ë‹¤ìŒ ë‹¨ê³„**
1. **í¬ë¡œìŠ¤ì²´ì¸ ë¸Œë¦¬ì§€** ë¬¸ì„œ ìƒì„±
2. **ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸** ë¬¸ì„œ ìƒì„±
3. **Web3 ì§€ê°‘ í†µí•©** ë¬¸ì„œ ìƒì„±

---

**ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸**: 2024-01-31
**ë‹¤ìŒ ì—…ë°ì´íŠ¸**: 2024-02-01 (í¬ë¡œìŠ¤ì²´ì¸ ë¸Œë¦¬ì§€)
**ë¸”ë¡ì²´ì¸ ëª©í‘œ**: < 5ì´ˆ DeFi ê±°ë˜, < 30ì´ˆ í¬ë¡œìŠ¤ì²´ì¸ ì „ì†¡, < 10ì´ˆ NFT ê±°ë˜
**ë¸”ë¡ì²´ì¸ ì„±ê³¼**: Uniswap í†µí•©, NFT ë§ˆì¼“í”Œë ˆì´ìŠ¤, ê°€ìŠ¤ë¹„ ìµœì í™”, ë©”íƒ€ë°ì´í„° ê´€ë¦¬ 