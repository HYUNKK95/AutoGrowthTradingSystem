# 🚀 Phase 1.2: 고급 거래 기능

## 📋 **개요**

### 🎯 **목표**
- **고급 주문 타입**: OCO, 트레일링 스탑, 브래킷 주문
- **포트폴리오 관리**: 자동 리밸런싱, 리스크 관리
- **알고리즘 트레이딩**: 기본적인 자동화 전략
- **백테스팅 시스템**: 전략 성능 검증

### 📊 **성능 목표**
- **주문 실행 시간**: < 50ms
- **포트폴리오 계산**: < 100ms
- **백테스팅 속도**: 1000 거래/초
- **전략 응답 시간**: < 200ms

## 🏗️ **고급 주문 시스템**

### 📁 **고급 주문 구조**
```
src/trading/advanced_orders/
├── __init__.py
├── order_types/                    # 고급 주문 타입
│   ├── __init__.py
│   ├── oco_order.py               # OCO 주문
│   ├── trailing_stop.py           # 트레일링 스탑
│   ├── bracket_order.py           # 브래킷 주문
│   └── conditional_order.py       # 조건부 주문
├── order_manager.py               # 주문 관리자
├── order_executor.py              # 주문 실행기
└── order_monitor.py               # 주문 모니터
```

### 🔧 **OCO (One-Cancels-Other) 주문**

```python
# src/trading/advanced_orders/order_types/oco_order.py
from typing import Optional, Dict, Any
from decimal import Decimal
from datetime import datetime
from dataclasses import dataclass
import asyncio

from ...models.order import Order, OrderType, OrderSide, OrderStatus

@dataclass
class OCOOrder:
    """OCO 주문 클래스"""
    id: str
    symbol: str
    side: OrderSide
    quantity: Decimal
    price: Decimal  # 메인 주문 가격
    stop_price: Decimal  # 스탑 주문 가격
    stop_limit_price: Decimal  # 스탑 리미트 가격
    status: str = 'PENDING'
    created_at: datetime = None
    updated_at: datetime = None
    
    def __post_init__(self):
        if self.created_at is None:
            self.created_at = datetime.now()
        self.updated_at = datetime.now()

class OCOOrderManager:
    """OCO 주문 관리자"""
    
    def __init__(self, exchange_manager):
        self.exchange_manager = exchange_manager
        self.active_oco_orders = {}
        self.oco_history = []
        
        logger.info("Initialized OCO order manager")
    
    async def place_oco_order(self, oco_order: OCOOrder) -> Dict[str, Any]:
        """OCO 주문 실행"""
        try:
            # 1. 메인 리미트 주문 생성
            main_order = Order(
                id=f"{oco_order.id}_main",
                symbol=oco_order.symbol,
                side=oco_order.side,
                type=OrderType.LIMIT,
                quantity=oco_order.quantity,
                price=oco_order.price,
                status=OrderStatus.PENDING
            )
            
            # 2. 스탑 리미트 주문 생성
            stop_order = Order(
                id=f"{oco_order.id}_stop",
                symbol=oco_order.symbol,
                side=oco_order.side,
                type=OrderType.STOP_LIMIT,
                quantity=oco_order.quantity,
                price=oco_order.stop_limit_price,
                stop_price=oco_order.stop_price,
                status=OrderStatus.PENDING
            )
            
            # 3. 두 주문을 동시에 실행
            main_result = await self.exchange_manager.place_order(main_order)
            stop_result = await self.exchange_manager.place_order(stop_order)
            
            if main_result['success'] and stop_result['success']:
                oco_order.status = 'ACTIVE'
                self.active_oco_orders[oco_order.id] = {
                    'oco_order': oco_order,
                    'main_order': main_order,
                    'stop_order': stop_order,
                    'main_result': main_result,
                    'stop_result': stop_result
                }
                
                return {
                    'success': True,
                    'oco_order_id': oco_order.id,
                    'main_order_id': main_result['order_id'],
                    'stop_order_id': stop_result['order_id'],
                    'message': 'OCO order placed successfully'
                }
            else:
                # 실패한 주문 취소
                if main_result['success']:
                    await self.exchange_manager.cancel_order(main_result['order_id'], oco_order.symbol)
                if stop_result['success']:
                    await self.exchange_manager.cancel_order(stop_result['order_id'], oco_order.symbol)
                
                return {
                    'success': False,
                    'error': 'Failed to place OCO order',
                    'main_error': main_result.get('error'),
                    'stop_error': stop_result.get('error')
                }
                
        except Exception as e:
            logger.error(f"Failed to place OCO order: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def cancel_oco_order(self, oco_order_id: str) -> Dict[str, Any]:
        """OCO 주문 취소"""
        if oco_order_id not in self.active_oco_orders:
            return {
                'success': False,
                'error': 'OCO order not found'
            }
        
        try:
            oco_data = self.active_oco_orders[oco_order_id]
            main_order = oco_data['main_order']
            stop_order = oco_data['stop_order']
            
            # 두 주문 모두 취소
            main_cancel = await self.exchange_manager.cancel_order(
                main_order.id, main_order.symbol
            )
            stop_cancel = await self.exchange_manager.cancel_order(
                stop_order.id, stop_order.symbol
            )
            
            if main_cancel and stop_cancel:
                oco_data['oco_order'].status = 'CANCELLED'
                self.oco_history.append(oco_data)
                del self.active_oco_orders[oco_order_id]
                
                return {
                    'success': True,
                    'message': 'OCO order cancelled successfully'
                }
            else:
                return {
                    'success': False,
                    'error': 'Failed to cancel OCO order',
                    'main_cancel': main_cancel,
                    'stop_cancel': stop_cancel
                }
                
        except Exception as e:
            logger.error(f"Failed to cancel OCO order: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def monitor_oco_orders(self):
        """OCO 주문 모니터링"""
        while True:
            try:
                for oco_id, oco_data in list(self.active_oco_orders.items()):
                    main_order = oco_data['main_order']
                    stop_order = oco_data['stop_order']
                    
                    # 주문 상태 확인
                    main_status = await self.exchange_manager.get_order_status(
                        main_order.id, main_order.symbol
                    )
                    stop_status = await self.exchange_manager.get_order_status(
                        stop_order.id, stop_order.symbol
                    )
                    
                    # 하나라도 체결되면 다른 하나 취소
                    if main_status and main_status.status == OrderStatus.FILLED:
                        await self.exchange_manager.cancel_order(
                            stop_order.id, stop_order.symbol
                        )
                        oco_data['oco_order'].status = 'FILLED'
                        self.oco_history.append(oco_data)
                        del self.active_oco_orders[oco_id]
                        
                    elif stop_status and stop_status.status == OrderStatus.FILLED:
                        await self.exchange_manager.cancel_order(
                            main_order.id, main_order.symbol
                        )
                        oco_data['oco_order'].status = 'STOPPED'
                        self.oco_history.append(oco_data)
                        del self.active_oco_orders[oco_id]
                
                await asyncio.sleep(1)  # 1초마다 확인
                
            except Exception as e:
                logger.error(f"Error monitoring OCO orders: {e}")
                await asyncio.sleep(5)
```

### 🔧 **트레일링 스탑 주문**

```python
# src/trading/advanced_orders/order_types/trailing_stop.py
from typing import Optional, Dict, Any
from decimal import Decimal
from datetime import datetime
from dataclasses import dataclass
import asyncio

@dataclass
class TrailingStopOrder:
    """트레일링 스탑 주문 클래스"""
    id: str
    symbol: str
    side: OrderSide
    quantity: Decimal
    activation_price: Decimal  # 활성화 가격
    callback_rate: Decimal  # 콜백 비율 (예: 0.02 = 2%)
    status: str = 'PENDING'
    current_stop_price: Optional[Decimal] = None
    highest_price: Optional[Decimal] = None
    lowest_price: Optional[Decimal] = None
    created_at: datetime = None
    updated_at: datetime = None
    
    def __post_init__(self):
        if self.created_at is None:
            self.created_at = datetime.now()
        self.updated_at = datetime.now()

class TrailingStopManager:
    """트레일링 스탑 관리자"""
    
    def __init__(self, exchange_manager):
        self.exchange_manager = exchange_manager
        self.active_trailing_stops = {}
        self.trailing_stop_history = []
        
        logger.info("Initialized trailing stop manager")
    
    async def place_trailing_stop(self, trailing_stop: TrailingStopOrder) -> Dict[str, Any]:
        """트레일링 스탑 주문 실행"""
        try:
            # 초기 스탑 가격 설정
            if trailing_stop.side == OrderSide.BUY:
                # 매수 트레일링 스탑: 가격이 하락할 때 매수
                trailing_stop.current_stop_price = trailing_stop.activation_price * (1 - trailing_stop.callback_rate)
                trailing_stop.lowest_price = trailing_stop.activation_price
            else:
                # 매도 트레일링 스탑: 가격이 상승할 때 매도
                trailing_stop.current_stop_price = trailing_stop.activation_price * (1 + trailing_stop.callback_rate)
                trailing_stop.highest_price = trailing_stop.activation_price
            
            trailing_stop.status = 'ACTIVE'
            self.active_trailing_stops[trailing_stop.id] = trailing_stop
            
            return {
                'success': True,
                'trailing_stop_id': trailing_stop.id,
                'current_stop_price': trailing_stop.current_stop_price,
                'message': 'Trailing stop order placed successfully'
            }
            
        except Exception as e:
            logger.error(f"Failed to place trailing stop: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def update_trailing_stop(self, trailing_stop_id: str, current_price: Decimal):
        """트레일링 스탑 업데이트"""
        if trailing_stop_id not in self.active_trailing_stops:
            return
        
        trailing_stop = self.active_trailing_stops[trailing_stop_id]
        
        try:
            if trailing_stop.side == OrderSide.BUY:
                # 매수 트레일링 스탑: 가격이 더 낮아지면 스탑 가격도 낮춤
                if current_price < trailing_stop.lowest_price:
                    trailing_stop.lowest_price = current_price
                    new_stop_price = current_price * (1 - trailing_stop.callback_rate)
                    
                    if new_stop_price < trailing_stop.current_stop_price:
                        trailing_stop.current_stop_price = new_stop_price
                        logger.info(f"Updated trailing stop price: {new_stop_price}")
                
                # 스탑 가격에 도달하면 매수 주문 실행
                if current_price <= trailing_stop.current_stop_price:
                    await self._execute_trailing_stop(trailing_stop, current_price)
                    
            else:
                # 매도 트레일링 스탑: 가격이 더 높아지면 스탑 가격도 높임
                if current_price > trailing_stop.highest_price:
                    trailing_stop.highest_price = current_price
                    new_stop_price = current_price * (1 + trailing_stop.callback_rate)
                    
                    if new_stop_price > trailing_stop.current_stop_price:
                        trailing_stop.current_stop_price = new_stop_price
                        logger.info(f"Updated trailing stop price: {new_stop_price}")
                
                # 스탑 가격에 도달하면 매도 주문 실행
                if current_price >= trailing_stop.current_stop_price:
                    await self._execute_trailing_stop(trailing_stop, current_price)
                    
        except Exception as e:
            logger.error(f"Failed to update trailing stop: {e}")
    
    async def _execute_trailing_stop(self, trailing_stop: TrailingStopOrder, current_price: Decimal):
        """트레일링 스탑 실행"""
        try:
            # 시장가 주문 실행
            order = Order(
                id=f"{trailing_stop.id}_execution",
                symbol=trailing_stop.symbol,
                side=trailing_stop.side,
                type=OrderType.MARKET,
                quantity=trailing_stop.quantity,
                status=OrderStatus.PENDING
            )
            
            result = await self.exchange_manager.place_order(order)
            
            if result['success']:
                trailing_stop.status = 'EXECUTED'
                trailing_stop.updated_at = datetime.now()
                self.trailing_stop_history.append(trailing_stop)
                del self.active_trailing_stops[trailing_stop.id]
                
                logger.info(f"Trailing stop executed: {trailing_stop.id} at {current_price}")
            else:
                logger.error(f"Failed to execute trailing stop: {result.get('error')}")
                
        except Exception as e:
            logger.error(f"Failed to execute trailing stop: {e}")
    
    async def cancel_trailing_stop(self, trailing_stop_id: str) -> Dict[str, Any]:
        """트레일링 스탑 취소"""
        if trailing_stop_id not in self.active_trailing_stops:
            return {
                'success': False,
                'error': 'Trailing stop order not found'
            }
        
        try:
            trailing_stop = self.active_trailing_stops[trailing_stop_id]
            trailing_stop.status = 'CANCELLED'
            trailing_stop.updated_at = datetime.now()
            
            self.trailing_stop_history.append(trailing_stop)
            del self.active_trailing_stops[trailing_stop_id]
            
            return {
                'success': True,
                'message': 'Trailing stop order cancelled successfully'
            }
            
        except Exception as e:
            logger.error(f"Failed to cancel trailing stop: {e}")
            return {
                'success': False,
                'error': str(e)
            }
```

## 📊 **포트폴리오 관리 시스템**

### 📁 **포트폴리오 관리 구조**
```
src/portfolio/
├── __init__.py
├── portfolio_manager.py            # 포트폴리오 관리자
├── rebalancer.py                   # 자동 리밸런싱
├── risk_manager.py                 # 리스크 관리
├── performance_tracker.py          # 성과 추적
└── allocation_strategies.py        # 자산 배분 전략
```

### 🔧 **포트폴리오 관리자**

```python
# src/portfolio/portfolio_manager.py
from typing import Dict, List, Optional, Any
from decimal import Decimal
from datetime import datetime
from dataclasses import dataclass
import asyncio

@dataclass
class Asset:
    """자산 정보"""
    symbol: str
    quantity: Decimal
    current_price: Decimal
    target_allocation: Decimal
    current_allocation: Decimal
    pnl: Decimal = Decimal('0')
    pnl_percentage: Decimal = Decimal('0')

@dataclass
class Portfolio:
    """포트폴리오 정보"""
    id: str
    name: str
    total_value: Decimal
    cash_balance: Decimal
    assets: Dict[str, Asset]
    target_allocations: Dict[str, Decimal]
    risk_level: str = 'MODERATE'
    created_at: datetime = None
    updated_at: datetime = None
    
    def __post_init__(self):
        if self.created_at is None:
            self.created_at = datetime.now()
        self.updated_at = datetime.now()

class PortfolioManager:
    """포트폴리오 관리자"""
    
    def __init__(self, exchange_manager, rebalancer, risk_manager):
        self.exchange_manager = exchange_manager
        self.rebalancer = rebalancer
        self.risk_manager = risk_manager
        self.portfolios = {}
        self.portfolio_history = []
        
        logger.info("Initialized portfolio manager")
    
    async def create_portfolio(self, portfolio_id: str, name: str, 
                             initial_cash: Decimal, target_allocations: Dict[str, Decimal]) -> Portfolio:
        """포트폴리오 생성"""
        try:
            portfolio = Portfolio(
                id=portfolio_id,
                name=name,
                total_value=initial_cash,
                cash_balance=initial_cash,
                assets={},
                target_allocations=target_allocations
            )
            
            self.portfolios[portfolio_id] = portfolio
            
            logger.info(f"Created portfolio: {portfolio_id}")
            return portfolio
            
        except Exception as e:
            logger.error(f"Failed to create portfolio: {e}")
            raise
    
    async def update_portfolio(self, portfolio_id: str) -> Dict[str, Any]:
        """포트폴리오 업데이트"""
        if portfolio_id not in self.portfolios:
            return {'success': False, 'error': 'Portfolio not found'}
        
        try:
            portfolio = self.portfolios[portfolio_id]
            
            # 각 자산의 현재 가격 조회
            total_value = portfolio.cash_balance
            
            for symbol in portfolio.target_allocations.keys():
                ticker = await self.exchange_manager.get_ticker(symbol)
                if ticker:
                    if symbol in portfolio.assets:
                        asset = portfolio.assets[symbol]
                        old_value = asset.quantity * asset.current_price
                        asset.current_price = ticker.last_price
                        new_value = asset.quantity * asset.current_price
                        
                        # PnL 계산
                        asset.pnl = new_value - old_value
                        asset.pnl_percentage = (asset.pnl / old_value * 100) if old_value > 0 else Decimal('0')
                        
                        total_value += new_value
                        asset.current_allocation = (new_value / total_value * 100) if total_value > 0 else Decimal('0')
                    else:
                        # 새로운 자산 추가
                        asset = Asset(
                            symbol=symbol,
                            quantity=Decimal('0'),
                            current_price=ticker.last_price,
                            target_allocation=portfolio.target_allocations[symbol],
                            current_allocation=Decimal('0')
                        )
                        portfolio.assets[symbol] = asset
            
            portfolio.total_value = total_value
            portfolio.updated_at = datetime.now()
            
            # 포트폴리오 히스토리 저장
            self.portfolio_history.append({
                'timestamp': datetime.now(),
                'portfolio_id': portfolio_id,
                'total_value': total_value,
                'assets': {symbol: asset.__dict__ for symbol, asset in portfolio.assets.items()}
            })
            
            return {
                'success': True,
                'portfolio': portfolio,
                'total_value': total_value,
                'cash_balance': portfolio.cash_balance
            }
            
        except Exception as e:
            logger.error(f"Failed to update portfolio: {e}")
            return {'success': False, 'error': str(e)}
    
    async def rebalance_portfolio(self, portfolio_id: str, 
                                rebalance_threshold: Decimal = Decimal('0.05')) -> Dict[str, Any]:
        """포트폴리오 리밸런싱"""
        if portfolio_id not in self.portfolios:
            return {'success': False, 'error': 'Portfolio not found'}
        
        try:
            portfolio = self.portfolios[portfolio_id]
            
            # 리밸런싱 필요성 확인
            rebalance_needed = await self.rebalancer.check_rebalance_needed(
                portfolio, rebalance_threshold
            )
            
            if not rebalance_needed['needed']:
                return {
                    'success': True,
                    'message': 'Rebalancing not needed',
                    'drift': rebalance_needed['drift']
                }
            
            # 리밸런싱 실행
            rebalance_orders = await self.rebalancer.generate_rebalance_orders(portfolio)
            
            # 주문 실행
            executed_orders = []
            for order in rebalance_orders:
                result = await self.exchange_manager.place_order(order)
                if result['success']:
                    executed_orders.append(result)
            
            # 포트폴리오 업데이트
            await self.update_portfolio(portfolio_id)
            
            return {
                'success': True,
                'message': 'Portfolio rebalanced successfully',
                'executed_orders': executed_orders,
                'drift_before': rebalance_needed['drift'],
                'drift_after': await self.rebalancer.calculate_drift(portfolio)
            }
            
        except Exception as e:
            logger.error(f"Failed to rebalance portfolio: {e}")
            return {'success': False, 'error': str(e)}
    
    async def get_portfolio_performance(self, portfolio_id: str, 
                                      period: str = '1d') -> Dict[str, Any]:
        """포트폴리오 성과 조회"""
        if portfolio_id not in self.portfolios:
            return {'success': False, 'error': 'Portfolio not found'}
        
        try:
            portfolio = self.portfolios[portfolio_id]
            
            # 성과 계산
            performance = {
                'total_return': Decimal('0'),
                'total_return_percentage': Decimal('0'),
                'daily_return': Decimal('0'),
                'daily_return_percentage': Decimal('0'),
                'volatility': Decimal('0'),
                'sharpe_ratio': Decimal('0'),
                'max_drawdown': Decimal('0'),
                'asset_performance': {}
            }
            
            # 각 자산별 성과 계산
            for symbol, asset in portfolio.assets.items():
                if asset.quantity > 0:
                    performance['asset_performance'][symbol] = {
                        'pnl': asset.pnl,
                        'pnl_percentage': asset.pnl_percentage,
                        'allocation': asset.current_allocation,
                        'target_allocation': asset.target_allocation,
                        'drift': asset.current_allocation - asset.target_allocation
                    }
            
            # 전체 성과 계산
            total_pnl = sum(asset.pnl for asset in portfolio.assets.values())
            performance['total_return'] = total_pnl
            performance['total_return_percentage'] = (
                (total_pnl / portfolio.total_value * 100) 
                if portfolio.total_value > 0 else Decimal('0')
            )
            
            return {
                'success': True,
                'performance': performance,
                'portfolio': portfolio
            }
            
        except Exception as e:
            logger.error(f"Failed to get portfolio performance: {e}")
            return {'success': False, 'error': str(e)}
```

### 🔧 **자동 리밸런서**

```python
# src/portfolio/rebalancer.py
from typing import Dict, List, Optional, Any
from decimal import Decimal
import asyncio

class PortfolioRebalancer:
    """포트폴리오 리밸런서"""
    
    def __init__(self, exchange_manager):
        self.exchange_manager = exchange_manager
        
        logger.info("Initialized portfolio rebalancer")
    
    async def check_rebalance_needed(self, portfolio: Portfolio, 
                                   threshold: Decimal) -> Dict[str, Any]:
        """리밸런싱 필요성 확인"""
        try:
            max_drift = Decimal('0')
            total_drift = Decimal('0')
            drift_details = {}
            
            for symbol, target_allocation in portfolio.target_allocations.items():
                if symbol in portfolio.assets:
                    current_allocation = portfolio.assets[symbol].current_allocation
                    drift = abs(current_allocation - target_allocation)
                    
                    drift_details[symbol] = {
                        'current': current_allocation,
                        'target': target_allocation,
                        'drift': drift
                    }
                    
                    max_drift = max(max_drift, drift)
                    total_drift += drift
                else:
                    # 자산이 없으면 100% 드리프트
                    drift_details[symbol] = {
                        'current': Decimal('0'),
                        'target': target_allocation,
                        'drift': target_allocation
                    }
                    max_drift = max(max_drift, target_allocation)
                    total_drift += target_allocation
            
            needed = max_drift > threshold
            
            return {
                'needed': needed,
                'max_drift': max_drift,
                'total_drift': total_drift,
                'threshold': threshold,
                'drift_details': drift_details
            }
            
        except Exception as e:
            logger.error(f"Failed to check rebalance needed: {e}")
            return {
                'needed': False,
                'error': str(e)
            }
    
    async def generate_rebalance_orders(self, portfolio: Portfolio) -> List[Order]:
        """리밸런싱 주문 생성"""
        try:
            orders = []
            total_value = portfolio.total_value
            
            for symbol, target_allocation in portfolio.target_allocations.items():
                target_value = total_value * target_allocation / 100
                
                if symbol in portfolio.assets:
                    current_asset = portfolio.assets[symbol]
                    current_value = current_asset.quantity * current_asset.current_price
                    value_difference = target_value - current_value
                    
                    if abs(value_difference) > total_value * Decimal('0.01'):  # 1% 이상 차이
                        quantity = value_difference / current_asset.current_price
                        
                        if quantity > 0:
                            # 매수 주문
                            order = Order(
                                id=f"rebalance_buy_{symbol}_{datetime.now().timestamp()}",
                                symbol=symbol,
                                side=OrderSide.BUY,
                                type=OrderType.MARKET,
                                quantity=abs(quantity),
                                status=OrderStatus.PENDING
                            )
                            orders.append(order)
                        elif quantity < 0:
                            # 매도 주문
                            order = Order(
                                id=f"rebalance_sell_{symbol}_{datetime.now().timestamp()}",
                                symbol=symbol,
                                side=OrderSide.SELL,
                                type=OrderType.MARKET,
                                quantity=abs(quantity),
                                status=OrderStatus.PENDING
                            )
                            orders.append(order)
                else:
                    # 새로운 자산 매수
                    ticker = await self.exchange_manager.get_ticker(symbol)
                    if ticker:
                        quantity = target_value / ticker.last_price
                        
                        order = Order(
                            id=f"rebalance_buy_{symbol}_{datetime.now().timestamp()}",
                            symbol=symbol,
                            side=OrderSide.BUY,
                            type=OrderType.MARKET,
                            quantity=quantity,
                            status=OrderStatus.PENDING
                        )
                        orders.append(order)
            
            return orders
            
        except Exception as e:
            logger.error(f"Failed to generate rebalance orders: {e}")
            return []
    
    async def calculate_drift(self, portfolio: Portfolio) -> Decimal:
        """포트폴리오 드리프트 계산"""
        try:
            total_drift = Decimal('0')
            
            for symbol, target_allocation in portfolio.target_allocations.items():
                if symbol in portfolio.assets:
                    current_allocation = portfolio.assets[symbol].current_allocation
                    drift = abs(current_allocation - target_allocation)
                    total_drift += drift
                else:
                    total_drift += target_allocation
            
            return total_drift
            
        except Exception as e:
            logger.error(f"Failed to calculate drift: {e}")
            return Decimal('0')
```

## 🤖 **알고리즘 트레이딩 시스템**

### 📁 **알고리즘 트레이딩 구조**
```
src/algorithmic_trading/
├── __init__.py
├── strategy_base.py                # 전략 기본 클래스
├── strategies/                     # 전략 구현
│   ├── __init__.py
│   ├── moving_average.py          # 이동평균 전략
│   ├── rsi_strategy.py            # RSI 전략
│   ├── mean_reversion.py          # 평균회귀 전략
│   └── momentum_strategy.py       # 모멘텀 전략
├── signal_generator.py            # 신호 생성기
├── position_manager.py            # 포지션 관리자
└── strategy_runner.py             # 전략 실행기
```

### 🔧 **전략 기본 클래스**

```python
# src/algorithmic_trading/strategy_base.py
from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Any
from decimal import Decimal
from datetime import datetime
from dataclasses import dataclass
import asyncio

@dataclass
class Signal:
    """거래 신호"""
    symbol: str
    signal_type: str  # 'BUY', 'SELL', 'HOLD'
    strength: Decimal  # 0.0 ~ 1.0
    price: Decimal
    timestamp: datetime
    strategy_name: str
    metadata: Dict[str, Any] = None

@dataclass
class Position:
    """포지션 정보"""
    symbol: str
    side: str  # 'LONG', 'SHORT'
    quantity: Decimal
    entry_price: Decimal
    current_price: Decimal
    pnl: Decimal
    pnl_percentage: Decimal
    timestamp: datetime

class StrategyBase(ABC):
    """전략 기본 클래스"""
    
    def __init__(self, name: str, symbols: List[str], parameters: Dict[str, Any]):
        self.name = name
        self.symbols = symbols
        self.parameters = parameters
        self.positions = {}
        self.signals = []
        self.is_running = False
        
        logger.info(f"Initialized strategy: {name}")
    
    @abstractmethod
    async def generate_signals(self, market_data: Dict[str, Any]) -> List[Signal]:
        """신호 생성 (구현 필요)"""
        pass
    
    @abstractmethod
    async def should_exit_position(self, position: Position, 
                                 market_data: Dict[str, Any]) -> bool:
        """포지션 청산 여부 확인 (구현 필요)"""
        pass
    
    async def run(self, market_data_provider, order_manager):
        """전략 실행"""
        self.is_running = True
        
        while self.is_running:
            try:
                # 시장 데이터 수집
                market_data = await market_data_provider.get_data(self.symbols)
                
                # 신호 생성
                signals = await self.generate_signals(market_data)
                
                # 신호 처리
                for signal in signals:
                    await self._process_signal(signal, order_manager)
                
                # 포지션 관리
                await self._manage_positions(market_data, order_manager)
                
                # 대기
                await asyncio.sleep(self.parameters.get('interval', 60))
                
            except Exception as e:
                logger.error(f"Error running strategy {self.name}: {e}")
                await asyncio.sleep(10)
    
    async def _process_signal(self, signal: Signal, order_manager):
        """신호 처리"""
        try:
            if signal.signal_type == 'BUY' and signal.symbol not in self.positions:
                # 매수 신호
                quantity = self._calculate_position_size(signal)
                
                order = Order(
                    id=f"{self.name}_{signal.symbol}_{datetime.now().timestamp()}",
                    symbol=signal.symbol,
                    side=OrderSide.BUY,
                    type=OrderType.MARKET,
                    quantity=quantity,
                    status=OrderStatus.PENDING
                )
                
                result = await order_manager.place_order(order)
                
                if result['success']:
                    # 포지션 생성
                    position = Position(
                        symbol=signal.symbol,
                        side='LONG',
                        quantity=quantity,
                        entry_price=signal.price,
                        current_price=signal.price,
                        pnl=Decimal('0'),
                        pnl_percentage=Decimal('0'),
                        timestamp=datetime.now()
                    )
                    
                    self.positions[signal.symbol] = position
                    logger.info(f"Opened LONG position: {signal.symbol}")
                
            elif signal.signal_type == 'SELL' and signal.symbol in self.positions:
                # 매도 신호
                position = self.positions[signal.symbol]
                
                order = Order(
                    id=f"{self.name}_{signal.symbol}_{datetime.now().timestamp()}",
                    symbol=signal.symbol,
                    side=OrderSide.SELL,
                    type=OrderType.MARKET,
                    quantity=position.quantity,
                    status=OrderStatus.PENDING
                )
                
                result = await order_manager.place_order(order)
                
                if result['success']:
                    # 포지션 청산
                    del self.positions[signal.symbol]
                    logger.info(f"Closed position: {signal.symbol}")
            
            # 신호 기록
            self.signals.append(signal)
            
        except Exception as e:
            logger.error(f"Failed to process signal: {e}")
    
    async def _manage_positions(self, market_data: Dict[str, Any], order_manager):
        """포지션 관리"""
        try:
            for symbol, position in list(self.positions.items()):
                # 현재 가격 업데이트
                if symbol in market_data:
                    current_price = market_data[symbol]['price']
                    position.current_price = current_price
                    
                    # PnL 계산
                    if position.side == 'LONG':
                        position.pnl = (current_price - position.entry_price) * position.quantity
                        position.pnl_percentage = (
                            (current_price - position.entry_price) / position.entry_price * 100
                        )
                    
                    # 청산 조건 확인
                    if await self.should_exit_position(position, market_data):
                        order = Order(
                            id=f"{self.name}_{symbol}_{datetime.now().timestamp()}",
                            symbol=symbol,
                            side=OrderSide.SELL,
                            type=OrderType.MARKET,
                            quantity=position.quantity,
                            status=OrderStatus.PENDING
                        )
                        
                        result = await order_manager.place_order(order)
                        
                        if result['success']:
                            del self.positions[symbol]
                            logger.info(f"Exited position: {symbol}")
                
        except Exception as e:
            logger.error(f"Failed to manage positions: {e}")
    
    def _calculate_position_size(self, signal: Signal) -> Decimal:
        """포지션 크기 계산"""
        # 기본 포지션 크기 (파라미터에서 설정)
        base_size = self.parameters.get('base_position_size', Decimal('0.1'))
        
        # 신호 강도에 따른 조정
        adjusted_size = base_size * signal.strength
        
        # 최소/최대 크기 제한
        min_size = self.parameters.get('min_position_size', Decimal('0.01'))
        max_size = self.parameters.get('max_position_size', Decimal('1.0'))
        
        return max(min_size, min(adjusted_size, max_size))
    
    def stop(self):
        """전략 중지"""
        self.is_running = False
        logger.info(f"Stopped strategy: {self.name}")
    
    def get_performance(self) -> Dict[str, Any]:
        """전략 성과 조회"""
        total_pnl = sum(position.pnl for position in self.positions.values())
        total_positions = len(self.positions)
        
        return {
            'strategy_name': self.name,
            'total_pnl': total_pnl,
            'total_positions': total_positions,
            'positions': [
                {
                    'symbol': pos.symbol,
                    'side': pos.side,
                    'quantity': pos.quantity,
                    'entry_price': pos.entry_price,
                    'current_price': pos.current_price,
                    'pnl': pos.pnl,
                    'pnl_percentage': pos.pnl_percentage
                }
                for pos in self.positions.values()
            ],
            'signals_count': len(self.signals)
        }
```

## 🎯 **다음 단계**

### 📋 **완료된 작업**
- ✅ 고급 주문 타입 구현 (OCO, 트레일링 스탑)
- ✅ 포트폴리오 관리 시스템
- ✅ 자동 리밸런싱 시스템
- ✅ 알고리즘 트레이딩 기본 프레임워크

### 🔄 **진행 중인 작업**
- 🔄 구체적인 전략 구현 (이동평균, RSI 등)
- 🔄 백테스팅 시스템
- 🔄 리스크 관리 시스템

### ⏳ **다음 단계**
1. **Phase 1.3 모니터링** 문서 생성
2. **Phase 1.4 인프라 확장** 문서 생성
3. **Phase 2 마이크로서비스** 시작

---

**마지막 업데이트**: 2024-01-31
**다음 업데이트**: 2024-02-01 (Phase 1.3 모니터링)
**고급 기능**: OCO, 트레일링 스탑, 포트폴리오 관리, 알고리즘 트레이딩
**성능 목표**: 주문 실행 < 50ms, 포트폴리오 계산 < 100ms 