# ğŸš€ Phase 1.2: ê³ ê¸‰ ê±°ë˜ ê¸°ëŠ¥

## ğŸ“‹ **ê°œìš”**

### ğŸ¯ **ëª©í‘œ**
- **ê³ ê¸‰ ì£¼ë¬¸ íƒ€ì…**: OCO, íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘, ë¸Œë˜í‚· ì£¼ë¬¸
- **í¬íŠ¸í´ë¦¬ì˜¤ ê´€ë¦¬**: ìë™ ë¦¬ë°¸ëŸ°ì‹±, ë¦¬ìŠ¤í¬ ê´€ë¦¬
- **ì•Œê³ ë¦¬ì¦˜ íŠ¸ë ˆì´ë”©**: ê¸°ë³¸ì ì¸ ìë™í™” ì „ëµ
- **ë°±í…ŒìŠ¤íŒ… ì‹œìŠ¤í…œ**: ì „ëµ ì„±ëŠ¥ ê²€ì¦

### ğŸ“Š **ì„±ëŠ¥ ëª©í‘œ**
- **ì£¼ë¬¸ ì‹¤í–‰ ì‹œê°„**: < 50ms
- **í¬íŠ¸í´ë¦¬ì˜¤ ê³„ì‚°**: < 100ms
- **ë°±í…ŒìŠ¤íŒ… ì†ë„**: 1000 ê±°ë˜/ì´ˆ
- **ì „ëµ ì‘ë‹µ ì‹œê°„**: < 200ms

## ğŸ—ï¸ **ê³ ê¸‰ ì£¼ë¬¸ ì‹œìŠ¤í…œ**

### ğŸ“ **ê³ ê¸‰ ì£¼ë¬¸ êµ¬ì¡°**
```
src/trading/advanced_orders/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ order_types/                    # ê³ ê¸‰ ì£¼ë¬¸ íƒ€ì…
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ oco_order.py               # OCO ì£¼ë¬¸
â”‚   â”œâ”€â”€ trailing_stop.py           # íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘
â”‚   â”œâ”€â”€ bracket_order.py           # ë¸Œë˜í‚· ì£¼ë¬¸
â”‚   â””â”€â”€ conditional_order.py       # ì¡°ê±´ë¶€ ì£¼ë¬¸
â”œâ”€â”€ order_manager.py               # ì£¼ë¬¸ ê´€ë¦¬ì
â”œâ”€â”€ order_executor.py              # ì£¼ë¬¸ ì‹¤í–‰ê¸°
â””â”€â”€ order_monitor.py               # ì£¼ë¬¸ ëª¨ë‹ˆí„°
```

### ğŸ”§ **OCO (One-Cancels-Other) ì£¼ë¬¸**

```python
# src/trading/advanced_orders/order_types/oco_order.py
from typing import Optional, Dict, Any
from decimal import Decimal
from datetime import datetime
from dataclasses import dataclass
import asyncio

from ...models.order import Order, OrderType, OrderSide, OrderStatus

@dataclass
class OCOOrder:
    """OCO ì£¼ë¬¸ í´ë˜ìŠ¤"""
    id: str
    symbol: str
    side: OrderSide
    quantity: Decimal
    price: Decimal  # ë©”ì¸ ì£¼ë¬¸ ê°€ê²©
    stop_price: Decimal  # ìŠ¤íƒ‘ ì£¼ë¬¸ ê°€ê²©
    stop_limit_price: Decimal  # ìŠ¤íƒ‘ ë¦¬ë¯¸íŠ¸ ê°€ê²©
    status: str = 'PENDING'
    created_at: datetime = None
    updated_at: datetime = None
    
    def __post_init__(self):
        if self.created_at is None:
            self.created_at = datetime.now()
        self.updated_at = datetime.now()

class OCOOrderManager:
    """OCO ì£¼ë¬¸ ê´€ë¦¬ì"""
    
    def __init__(self, exchange_manager):
        self.exchange_manager = exchange_manager
        self.active_oco_orders = {}
        self.oco_history = []
        
        logger.info("Initialized OCO order manager")
    
    async def place_oco_order(self, oco_order: OCOOrder) -> Dict[str, Any]:
        """OCO ì£¼ë¬¸ ì‹¤í–‰"""
        try:
            # 1. ë©”ì¸ ë¦¬ë¯¸íŠ¸ ì£¼ë¬¸ ìƒì„±
            main_order = Order(
                id=f"{oco_order.id}_main",
                symbol=oco_order.symbol,
                side=oco_order.side,
                type=OrderType.LIMIT,
                quantity=oco_order.quantity,
                price=oco_order.price,
                status=OrderStatus.PENDING
            )
            
            # 2. ìŠ¤íƒ‘ ë¦¬ë¯¸íŠ¸ ì£¼ë¬¸ ìƒì„±
            stop_order = Order(
                id=f"{oco_order.id}_stop",
                symbol=oco_order.symbol,
                side=oco_order.side,
                type=OrderType.STOP_LIMIT,
                quantity=oco_order.quantity,
                price=oco_order.stop_limit_price,
                stop_price=oco_order.stop_price,
                status=OrderStatus.PENDING
            )
            
            # 3. ë‘ ì£¼ë¬¸ì„ ë™ì‹œì— ì‹¤í–‰
            main_result = await self.exchange_manager.place_order(main_order)
            stop_result = await self.exchange_manager.place_order(stop_order)
            
            if main_result['success'] and stop_result['success']:
                oco_order.status = 'ACTIVE'
                self.active_oco_orders[oco_order.id] = {
                    'oco_order': oco_order,
                    'main_order': main_order,
                    'stop_order': stop_order,
                    'main_result': main_result,
                    'stop_result': stop_result
                }
                
                return {
                    'success': True,
                    'oco_order_id': oco_order.id,
                    'main_order_id': main_result['order_id'],
                    'stop_order_id': stop_result['order_id'],
                    'message': 'OCO order placed successfully'
                }
            else:
                # ì‹¤íŒ¨í•œ ì£¼ë¬¸ ì·¨ì†Œ
                if main_result['success']:
                    await self.exchange_manager.cancel_order(main_result['order_id'], oco_order.symbol)
                if stop_result['success']:
                    await self.exchange_manager.cancel_order(stop_result['order_id'], oco_order.symbol)
                
                return {
                    'success': False,
                    'error': 'Failed to place OCO order',
                    'main_error': main_result.get('error'),
                    'stop_error': stop_result.get('error')
                }
                
        except Exception as e:
            logger.error(f"Failed to place OCO order: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def cancel_oco_order(self, oco_order_id: str) -> Dict[str, Any]:
        """OCO ì£¼ë¬¸ ì·¨ì†Œ"""
        if oco_order_id not in self.active_oco_orders:
            return {
                'success': False,
                'error': 'OCO order not found'
            }
        
        try:
            oco_data = self.active_oco_orders[oco_order_id]
            main_order = oco_data['main_order']
            stop_order = oco_data['stop_order']
            
            # ë‘ ì£¼ë¬¸ ëª¨ë‘ ì·¨ì†Œ
            main_cancel = await self.exchange_manager.cancel_order(
                main_order.id, main_order.symbol
            )
            stop_cancel = await self.exchange_manager.cancel_order(
                stop_order.id, stop_order.symbol
            )
            
            if main_cancel and stop_cancel:
                oco_data['oco_order'].status = 'CANCELLED'
                self.oco_history.append(oco_data)
                del self.active_oco_orders[oco_order_id]
                
                return {
                    'success': True,
                    'message': 'OCO order cancelled successfully'
                }
            else:
                return {
                    'success': False,
                    'error': 'Failed to cancel OCO order',
                    'main_cancel': main_cancel,
                    'stop_cancel': stop_cancel
                }
                
        except Exception as e:
            logger.error(f"Failed to cancel OCO order: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def monitor_oco_orders(self):
        """OCO ì£¼ë¬¸ ëª¨ë‹ˆí„°ë§"""
        while True:
            try:
                for oco_id, oco_data in list(self.active_oco_orders.items()):
                    main_order = oco_data['main_order']
                    stop_order = oco_data['stop_order']
                    
                    # ì£¼ë¬¸ ìƒíƒœ í™•ì¸
                    main_status = await self.exchange_manager.get_order_status(
                        main_order.id, main_order.symbol
                    )
                    stop_status = await self.exchange_manager.get_order_status(
                        stop_order.id, stop_order.symbol
                    )
                    
                    # í•˜ë‚˜ë¼ë„ ì²´ê²°ë˜ë©´ ë‹¤ë¥¸ í•˜ë‚˜ ì·¨ì†Œ
                    if main_status and main_status.status == OrderStatus.FILLED:
                        await self.exchange_manager.cancel_order(
                            stop_order.id, stop_order.symbol
                        )
                        oco_data['oco_order'].status = 'FILLED'
                        self.oco_history.append(oco_data)
                        del self.active_oco_orders[oco_id]
                        
                    elif stop_status and stop_status.status == OrderStatus.FILLED:
                        await self.exchange_manager.cancel_order(
                            main_order.id, main_order.symbol
                        )
                        oco_data['oco_order'].status = 'STOPPED'
                        self.oco_history.append(oco_data)
                        del self.active_oco_orders[oco_id]
                
                await asyncio.sleep(1)  # 1ì´ˆë§ˆë‹¤ í™•ì¸
                
            except Exception as e:
                logger.error(f"Error monitoring OCO orders: {e}")
                await asyncio.sleep(5)
```

### ğŸ”§ **íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ì£¼ë¬¸**

```python
# src/trading/advanced_orders/order_types/trailing_stop.py
from typing import Optional, Dict, Any
from decimal import Decimal
from datetime import datetime
from dataclasses import dataclass
import asyncio

@dataclass
class TrailingStopOrder:
    """íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ì£¼ë¬¸ í´ë˜ìŠ¤"""
    id: str
    symbol: str
    side: OrderSide
    quantity: Decimal
    activation_price: Decimal  # í™œì„±í™” ê°€ê²©
    callback_rate: Decimal  # ì½œë°± ë¹„ìœ¨ (ì˜ˆ: 0.02 = 2%)
    status: str = 'PENDING'
    current_stop_price: Optional[Decimal] = None
    highest_price: Optional[Decimal] = None
    lowest_price: Optional[Decimal] = None
    created_at: datetime = None
    updated_at: datetime = None
    
    def __post_init__(self):
        if self.created_at is None:
            self.created_at = datetime.now()
        self.updated_at = datetime.now()

class TrailingStopManager:
    """íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ê´€ë¦¬ì"""
    
    def __init__(self, exchange_manager):
        self.exchange_manager = exchange_manager
        self.active_trailing_stops = {}
        self.trailing_stop_history = []
        
        logger.info("Initialized trailing stop manager")
    
    async def place_trailing_stop(self, trailing_stop: TrailingStopOrder) -> Dict[str, Any]:
        """íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ì£¼ë¬¸ ì‹¤í–‰"""
        try:
            # ì´ˆê¸° ìŠ¤íƒ‘ ê°€ê²© ì„¤ì •
            if trailing_stop.side == OrderSide.BUY:
                # ë§¤ìˆ˜ íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘: ê°€ê²©ì´ í•˜ë½í•  ë•Œ ë§¤ìˆ˜
                trailing_stop.current_stop_price = trailing_stop.activation_price * (1 - trailing_stop.callback_rate)
                trailing_stop.lowest_price = trailing_stop.activation_price
            else:
                # ë§¤ë„ íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘: ê°€ê²©ì´ ìƒìŠ¹í•  ë•Œ ë§¤ë„
                trailing_stop.current_stop_price = trailing_stop.activation_price * (1 + trailing_stop.callback_rate)
                trailing_stop.highest_price = trailing_stop.activation_price
            
            trailing_stop.status = 'ACTIVE'
            self.active_trailing_stops[trailing_stop.id] = trailing_stop
            
            return {
                'success': True,
                'trailing_stop_id': trailing_stop.id,
                'current_stop_price': trailing_stop.current_stop_price,
                'message': 'Trailing stop order placed successfully'
            }
            
        except Exception as e:
            logger.error(f"Failed to place trailing stop: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    async def update_trailing_stop(self, trailing_stop_id: str, current_price: Decimal):
        """íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ì—…ë°ì´íŠ¸"""
        if trailing_stop_id not in self.active_trailing_stops:
            return
        
        trailing_stop = self.active_trailing_stops[trailing_stop_id]
        
        try:
            if trailing_stop.side == OrderSide.BUY:
                # ë§¤ìˆ˜ íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘: ê°€ê²©ì´ ë” ë‚®ì•„ì§€ë©´ ìŠ¤íƒ‘ ê°€ê²©ë„ ë‚®ì¶¤
                if current_price < trailing_stop.lowest_price:
                    trailing_stop.lowest_price = current_price
                    new_stop_price = current_price * (1 - trailing_stop.callback_rate)
                    
                    if new_stop_price < trailing_stop.current_stop_price:
                        trailing_stop.current_stop_price = new_stop_price
                        logger.info(f"Updated trailing stop price: {new_stop_price}")
                
                # ìŠ¤íƒ‘ ê°€ê²©ì— ë„ë‹¬í•˜ë©´ ë§¤ìˆ˜ ì£¼ë¬¸ ì‹¤í–‰
                if current_price <= trailing_stop.current_stop_price:
                    await self._execute_trailing_stop(trailing_stop, current_price)
                    
            else:
                # ë§¤ë„ íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘: ê°€ê²©ì´ ë” ë†’ì•„ì§€ë©´ ìŠ¤íƒ‘ ê°€ê²©ë„ ë†’ì„
                if current_price > trailing_stop.highest_price:
                    trailing_stop.highest_price = current_price
                    new_stop_price = current_price * (1 + trailing_stop.callback_rate)
                    
                    if new_stop_price > trailing_stop.current_stop_price:
                        trailing_stop.current_stop_price = new_stop_price
                        logger.info(f"Updated trailing stop price: {new_stop_price}")
                
                # ìŠ¤íƒ‘ ê°€ê²©ì— ë„ë‹¬í•˜ë©´ ë§¤ë„ ì£¼ë¬¸ ì‹¤í–‰
                if current_price >= trailing_stop.current_stop_price:
                    await self._execute_trailing_stop(trailing_stop, current_price)
                    
        except Exception as e:
            logger.error(f"Failed to update trailing stop: {e}")
    
    async def _execute_trailing_stop(self, trailing_stop: TrailingStopOrder, current_price: Decimal):
        """íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ì‹¤í–‰"""
        try:
            # ì‹œì¥ê°€ ì£¼ë¬¸ ì‹¤í–‰
            order = Order(
                id=f"{trailing_stop.id}_execution",
                symbol=trailing_stop.symbol,
                side=trailing_stop.side,
                type=OrderType.MARKET,
                quantity=trailing_stop.quantity,
                status=OrderStatus.PENDING
            )
            
            result = await self.exchange_manager.place_order(order)
            
            if result['success']:
                trailing_stop.status = 'EXECUTED'
                trailing_stop.updated_at = datetime.now()
                self.trailing_stop_history.append(trailing_stop)
                del self.active_trailing_stops[trailing_stop.id]
                
                logger.info(f"Trailing stop executed: {trailing_stop.id} at {current_price}")
            else:
                logger.error(f"Failed to execute trailing stop: {result.get('error')}")
                
        except Exception as e:
            logger.error(f"Failed to execute trailing stop: {e}")
    
    async def cancel_trailing_stop(self, trailing_stop_id: str) -> Dict[str, Any]:
        """íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘ ì·¨ì†Œ"""
        if trailing_stop_id not in self.active_trailing_stops:
            return {
                'success': False,
                'error': 'Trailing stop order not found'
            }
        
        try:
            trailing_stop = self.active_trailing_stops[trailing_stop_id]
            trailing_stop.status = 'CANCELLED'
            trailing_stop.updated_at = datetime.now()
            
            self.trailing_stop_history.append(trailing_stop)
            del self.active_trailing_stops[trailing_stop_id]
            
            return {
                'success': True,
                'message': 'Trailing stop order cancelled successfully'
            }
            
        except Exception as e:
            logger.error(f"Failed to cancel trailing stop: {e}")
            return {
                'success': False,
                'error': str(e)
            }
```

## ğŸ“Š **í¬íŠ¸í´ë¦¬ì˜¤ ê´€ë¦¬ ì‹œìŠ¤í…œ**

### ğŸ“ **í¬íŠ¸í´ë¦¬ì˜¤ ê´€ë¦¬ êµ¬ì¡°**
```
src/portfolio/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ portfolio_manager.py            # í¬íŠ¸í´ë¦¬ì˜¤ ê´€ë¦¬ì
â”œâ”€â”€ rebalancer.py                   # ìë™ ë¦¬ë°¸ëŸ°ì‹±
â”œâ”€â”€ risk_manager.py                 # ë¦¬ìŠ¤í¬ ê´€ë¦¬
â”œâ”€â”€ performance_tracker.py          # ì„±ê³¼ ì¶”ì 
â””â”€â”€ allocation_strategies.py        # ìì‚° ë°°ë¶„ ì „ëµ
```

### ğŸ”§ **í¬íŠ¸í´ë¦¬ì˜¤ ê´€ë¦¬ì**

```python
# src/portfolio/portfolio_manager.py
from typing import Dict, List, Optional, Any
from decimal import Decimal
from datetime import datetime
from dataclasses import dataclass
import asyncio

@dataclass
class Asset:
    """ìì‚° ì •ë³´"""
    symbol: str
    quantity: Decimal
    current_price: Decimal
    target_allocation: Decimal
    current_allocation: Decimal
    pnl: Decimal = Decimal('0')
    pnl_percentage: Decimal = Decimal('0')

@dataclass
class Portfolio:
    """í¬íŠ¸í´ë¦¬ì˜¤ ì •ë³´"""
    id: str
    name: str
    total_value: Decimal
    cash_balance: Decimal
    assets: Dict[str, Asset]
    target_allocations: Dict[str, Decimal]
    risk_level: str = 'MODERATE'
    created_at: datetime = None
    updated_at: datetime = None
    
    def __post_init__(self):
        if self.created_at is None:
            self.created_at = datetime.now()
        self.updated_at = datetime.now()

class PortfolioManager:
    """í¬íŠ¸í´ë¦¬ì˜¤ ê´€ë¦¬ì"""
    
    def __init__(self, exchange_manager, rebalancer, risk_manager):
        self.exchange_manager = exchange_manager
        self.rebalancer = rebalancer
        self.risk_manager = risk_manager
        self.portfolios = {}
        self.portfolio_history = []
        
        logger.info("Initialized portfolio manager")
    
    async def create_portfolio(self, portfolio_id: str, name: str, 
                             initial_cash: Decimal, target_allocations: Dict[str, Decimal]) -> Portfolio:
        """í¬íŠ¸í´ë¦¬ì˜¤ ìƒì„±"""
        try:
            portfolio = Portfolio(
                id=portfolio_id,
                name=name,
                total_value=initial_cash,
                cash_balance=initial_cash,
                assets={},
                target_allocations=target_allocations
            )
            
            self.portfolios[portfolio_id] = portfolio
            
            logger.info(f"Created portfolio: {portfolio_id}")
            return portfolio
            
        except Exception as e:
            logger.error(f"Failed to create portfolio: {e}")
            raise
    
    async def update_portfolio(self, portfolio_id: str) -> Dict[str, Any]:
        """í¬íŠ¸í´ë¦¬ì˜¤ ì—…ë°ì´íŠ¸"""
        if portfolio_id not in self.portfolios:
            return {'success': False, 'error': 'Portfolio not found'}
        
        try:
            portfolio = self.portfolios[portfolio_id]
            
            # ê° ìì‚°ì˜ í˜„ì¬ ê°€ê²© ì¡°íšŒ
            total_value = portfolio.cash_balance
            
            for symbol in portfolio.target_allocations.keys():
                ticker = await self.exchange_manager.get_ticker(symbol)
                if ticker:
                    if symbol in portfolio.assets:
                        asset = portfolio.assets[symbol]
                        old_value = asset.quantity * asset.current_price
                        asset.current_price = ticker.last_price
                        new_value = asset.quantity * asset.current_price
                        
                        # PnL ê³„ì‚°
                        asset.pnl = new_value - old_value
                        asset.pnl_percentage = (asset.pnl / old_value * 100) if old_value > 0 else Decimal('0')
                        
                        total_value += new_value
                        asset.current_allocation = (new_value / total_value * 100) if total_value > 0 else Decimal('0')
                    else:
                        # ìƒˆë¡œìš´ ìì‚° ì¶”ê°€
                        asset = Asset(
                            symbol=symbol,
                            quantity=Decimal('0'),
                            current_price=ticker.last_price,
                            target_allocation=portfolio.target_allocations[symbol],
                            current_allocation=Decimal('0')
                        )
                        portfolio.assets[symbol] = asset
            
            portfolio.total_value = total_value
            portfolio.updated_at = datetime.now()
            
            # í¬íŠ¸í´ë¦¬ì˜¤ íˆìŠ¤í† ë¦¬ ì €ì¥
            self.portfolio_history.append({
                'timestamp': datetime.now(),
                'portfolio_id': portfolio_id,
                'total_value': total_value,
                'assets': {symbol: asset.__dict__ for symbol, asset in portfolio.assets.items()}
            })
            
            return {
                'success': True,
                'portfolio': portfolio,
                'total_value': total_value,
                'cash_balance': portfolio.cash_balance
            }
            
        except Exception as e:
            logger.error(f"Failed to update portfolio: {e}")
            return {'success': False, 'error': str(e)}
    
    async def rebalance_portfolio(self, portfolio_id: str, 
                                rebalance_threshold: Decimal = Decimal('0.05')) -> Dict[str, Any]:
        """í¬íŠ¸í´ë¦¬ì˜¤ ë¦¬ë°¸ëŸ°ì‹±"""
        if portfolio_id not in self.portfolios:
            return {'success': False, 'error': 'Portfolio not found'}
        
        try:
            portfolio = self.portfolios[portfolio_id]
            
            # ë¦¬ë°¸ëŸ°ì‹± í•„ìš”ì„± í™•ì¸
            rebalance_needed = await self.rebalancer.check_rebalance_needed(
                portfolio, rebalance_threshold
            )
            
            if not rebalance_needed['needed']:
                return {
                    'success': True,
                    'message': 'Rebalancing not needed',
                    'drift': rebalance_needed['drift']
                }
            
            # ë¦¬ë°¸ëŸ°ì‹± ì‹¤í–‰
            rebalance_orders = await self.rebalancer.generate_rebalance_orders(portfolio)
            
            # ì£¼ë¬¸ ì‹¤í–‰
            executed_orders = []
            for order in rebalance_orders:
                result = await self.exchange_manager.place_order(order)
                if result['success']:
                    executed_orders.append(result)
            
            # í¬íŠ¸í´ë¦¬ì˜¤ ì—…ë°ì´íŠ¸
            await self.update_portfolio(portfolio_id)
            
            return {
                'success': True,
                'message': 'Portfolio rebalanced successfully',
                'executed_orders': executed_orders,
                'drift_before': rebalance_needed['drift'],
                'drift_after': await self.rebalancer.calculate_drift(portfolio)
            }
            
        except Exception as e:
            logger.error(f"Failed to rebalance portfolio: {e}")
            return {'success': False, 'error': str(e)}
    
    async def get_portfolio_performance(self, portfolio_id: str, 
                                      period: str = '1d') -> Dict[str, Any]:
        """í¬íŠ¸í´ë¦¬ì˜¤ ì„±ê³¼ ì¡°íšŒ"""
        if portfolio_id not in self.portfolios:
            return {'success': False, 'error': 'Portfolio not found'}
        
        try:
            portfolio = self.portfolios[portfolio_id]
            
            # ì„±ê³¼ ê³„ì‚°
            performance = {
                'total_return': Decimal('0'),
                'total_return_percentage': Decimal('0'),
                'daily_return': Decimal('0'),
                'daily_return_percentage': Decimal('0'),
                'volatility': Decimal('0'),
                'sharpe_ratio': Decimal('0'),
                'max_drawdown': Decimal('0'),
                'asset_performance': {}
            }
            
            # ê° ìì‚°ë³„ ì„±ê³¼ ê³„ì‚°
            for symbol, asset in portfolio.assets.items():
                if asset.quantity > 0:
                    performance['asset_performance'][symbol] = {
                        'pnl': asset.pnl,
                        'pnl_percentage': asset.pnl_percentage,
                        'allocation': asset.current_allocation,
                        'target_allocation': asset.target_allocation,
                        'drift': asset.current_allocation - asset.target_allocation
                    }
            
            # ì „ì²´ ì„±ê³¼ ê³„ì‚°
            total_pnl = sum(asset.pnl for asset in portfolio.assets.values())
            performance['total_return'] = total_pnl
            performance['total_return_percentage'] = (
                (total_pnl / portfolio.total_value * 100) 
                if portfolio.total_value > 0 else Decimal('0')
            )
            
            return {
                'success': True,
                'performance': performance,
                'portfolio': portfolio
            }
            
        except Exception as e:
            logger.error(f"Failed to get portfolio performance: {e}")
            return {'success': False, 'error': str(e)}
```

### ğŸ”§ **ìë™ ë¦¬ë°¸ëŸ°ì„œ**

```python
# src/portfolio/rebalancer.py
from typing import Dict, List, Optional, Any
from decimal import Decimal
import asyncio

class PortfolioRebalancer:
    """í¬íŠ¸í´ë¦¬ì˜¤ ë¦¬ë°¸ëŸ°ì„œ"""
    
    def __init__(self, exchange_manager):
        self.exchange_manager = exchange_manager
        
        logger.info("Initialized portfolio rebalancer")
    
    async def check_rebalance_needed(self, portfolio: Portfolio, 
                                   threshold: Decimal) -> Dict[str, Any]:
        """ë¦¬ë°¸ëŸ°ì‹± í•„ìš”ì„± í™•ì¸"""
        try:
            max_drift = Decimal('0')
            total_drift = Decimal('0')
            drift_details = {}
            
            for symbol, target_allocation in portfolio.target_allocations.items():
                if symbol in portfolio.assets:
                    current_allocation = portfolio.assets[symbol].current_allocation
                    drift = abs(current_allocation - target_allocation)
                    
                    drift_details[symbol] = {
                        'current': current_allocation,
                        'target': target_allocation,
                        'drift': drift
                    }
                    
                    max_drift = max(max_drift, drift)
                    total_drift += drift
                else:
                    # ìì‚°ì´ ì—†ìœ¼ë©´ 100% ë“œë¦¬í”„íŠ¸
                    drift_details[symbol] = {
                        'current': Decimal('0'),
                        'target': target_allocation,
                        'drift': target_allocation
                    }
                    max_drift = max(max_drift, target_allocation)
                    total_drift += target_allocation
            
            needed = max_drift > threshold
            
            return {
                'needed': needed,
                'max_drift': max_drift,
                'total_drift': total_drift,
                'threshold': threshold,
                'drift_details': drift_details
            }
            
        except Exception as e:
            logger.error(f"Failed to check rebalance needed: {e}")
            return {
                'needed': False,
                'error': str(e)
            }
    
    async def generate_rebalance_orders(self, portfolio: Portfolio) -> List[Order]:
        """ë¦¬ë°¸ëŸ°ì‹± ì£¼ë¬¸ ìƒì„±"""
        try:
            orders = []
            total_value = portfolio.total_value
            
            for symbol, target_allocation in portfolio.target_allocations.items():
                target_value = total_value * target_allocation / 100
                
                if symbol in portfolio.assets:
                    current_asset = portfolio.assets[symbol]
                    current_value = current_asset.quantity * current_asset.current_price
                    value_difference = target_value - current_value
                    
                    if abs(value_difference) > total_value * Decimal('0.01'):  # 1% ì´ìƒ ì°¨ì´
                        quantity = value_difference / current_asset.current_price
                        
                        if quantity > 0:
                            # ë§¤ìˆ˜ ì£¼ë¬¸
                            order = Order(
                                id=f"rebalance_buy_{symbol}_{datetime.now().timestamp()}",
                                symbol=symbol,
                                side=OrderSide.BUY,
                                type=OrderType.MARKET,
                                quantity=abs(quantity),
                                status=OrderStatus.PENDING
                            )
                            orders.append(order)
                        elif quantity < 0:
                            # ë§¤ë„ ì£¼ë¬¸
                            order = Order(
                                id=f"rebalance_sell_{symbol}_{datetime.now().timestamp()}",
                                symbol=symbol,
                                side=OrderSide.SELL,
                                type=OrderType.MARKET,
                                quantity=abs(quantity),
                                status=OrderStatus.PENDING
                            )
                            orders.append(order)
                else:
                    # ìƒˆë¡œìš´ ìì‚° ë§¤ìˆ˜
                    ticker = await self.exchange_manager.get_ticker(symbol)
                    if ticker:
                        quantity = target_value / ticker.last_price
                        
                        order = Order(
                            id=f"rebalance_buy_{symbol}_{datetime.now().timestamp()}",
                            symbol=symbol,
                            side=OrderSide.BUY,
                            type=OrderType.MARKET,
                            quantity=quantity,
                            status=OrderStatus.PENDING
                        )
                        orders.append(order)
            
            return orders
            
        except Exception as e:
            logger.error(f"Failed to generate rebalance orders: {e}")
            return []
    
    async def calculate_drift(self, portfolio: Portfolio) -> Decimal:
        """í¬íŠ¸í´ë¦¬ì˜¤ ë“œë¦¬í”„íŠ¸ ê³„ì‚°"""
        try:
            total_drift = Decimal('0')
            
            for symbol, target_allocation in portfolio.target_allocations.items():
                if symbol in portfolio.assets:
                    current_allocation = portfolio.assets[symbol].current_allocation
                    drift = abs(current_allocation - target_allocation)
                    total_drift += drift
                else:
                    total_drift += target_allocation
            
            return total_drift
            
        except Exception as e:
            logger.error(f"Failed to calculate drift: {e}")
            return Decimal('0')
```

## ğŸ¤– **ì•Œê³ ë¦¬ì¦˜ íŠ¸ë ˆì´ë”© ì‹œìŠ¤í…œ**

### ğŸ“ **ì•Œê³ ë¦¬ì¦˜ íŠ¸ë ˆì´ë”© êµ¬ì¡°**
```
src/algorithmic_trading/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ strategy_base.py                # ì „ëµ ê¸°ë³¸ í´ë˜ìŠ¤
â”œâ”€â”€ strategies/                     # ì „ëµ êµ¬í˜„
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ moving_average.py          # ì´ë™í‰ê·  ì „ëµ
â”‚   â”œâ”€â”€ rsi_strategy.py            # RSI ì „ëµ
â”‚   â”œâ”€â”€ mean_reversion.py          # í‰ê· íšŒê·€ ì „ëµ
â”‚   â””â”€â”€ momentum_strategy.py       # ëª¨ë©˜í…€ ì „ëµ
â”œâ”€â”€ signal_generator.py            # ì‹ í˜¸ ìƒì„±ê¸°
â”œâ”€â”€ position_manager.py            # í¬ì§€ì…˜ ê´€ë¦¬ì
â””â”€â”€ strategy_runner.py             # ì „ëµ ì‹¤í–‰ê¸°
```

### ğŸ”§ **ì „ëµ ê¸°ë³¸ í´ë˜ìŠ¤**

```python
# src/algorithmic_trading/strategy_base.py
from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Any
from decimal import Decimal
from datetime import datetime
from dataclasses import dataclass
import asyncio

@dataclass
class Signal:
    """ê±°ë˜ ì‹ í˜¸"""
    symbol: str
    signal_type: str  # 'BUY', 'SELL', 'HOLD'
    strength: Decimal  # 0.0 ~ 1.0
    price: Decimal
    timestamp: datetime
    strategy_name: str
    metadata: Dict[str, Any] = None

@dataclass
class Position:
    """í¬ì§€ì…˜ ì •ë³´"""
    symbol: str
    side: str  # 'LONG', 'SHORT'
    quantity: Decimal
    entry_price: Decimal
    current_price: Decimal
    pnl: Decimal
    pnl_percentage: Decimal
    timestamp: datetime

class StrategyBase(ABC):
    """ì „ëµ ê¸°ë³¸ í´ë˜ìŠ¤"""
    
    def __init__(self, name: str, symbols: List[str], parameters: Dict[str, Any]):
        self.name = name
        self.symbols = symbols
        self.parameters = parameters
        self.positions = {}
        self.signals = []
        self.is_running = False
        
        logger.info(f"Initialized strategy: {name}")
    
    @abstractmethod
    async def generate_signals(self, market_data: Dict[str, Any]) -> List[Signal]:
        """ì‹ í˜¸ ìƒì„± (êµ¬í˜„ í•„ìš”)"""
        pass
    
    @abstractmethod
    async def should_exit_position(self, position: Position, 
                                 market_data: Dict[str, Any]) -> bool:
        """í¬ì§€ì…˜ ì²­ì‚° ì—¬ë¶€ í™•ì¸ (êµ¬í˜„ í•„ìš”)"""
        pass
    
    async def run(self, market_data_provider, order_manager):
        """ì „ëµ ì‹¤í–‰"""
        self.is_running = True
        
        while self.is_running:
            try:
                # ì‹œì¥ ë°ì´í„° ìˆ˜ì§‘
                market_data = await market_data_provider.get_data(self.symbols)
                
                # ì‹ í˜¸ ìƒì„±
                signals = await self.generate_signals(market_data)
                
                # ì‹ í˜¸ ì²˜ë¦¬
                for signal in signals:
                    await self._process_signal(signal, order_manager)
                
                # í¬ì§€ì…˜ ê´€ë¦¬
                await self._manage_positions(market_data, order_manager)
                
                # ëŒ€ê¸°
                await asyncio.sleep(self.parameters.get('interval', 60))
                
            except Exception as e:
                logger.error(f"Error running strategy {self.name}: {e}")
                await asyncio.sleep(10)
    
    async def _process_signal(self, signal: Signal, order_manager):
        """ì‹ í˜¸ ì²˜ë¦¬"""
        try:
            if signal.signal_type == 'BUY' and signal.symbol not in self.positions:
                # ë§¤ìˆ˜ ì‹ í˜¸
                quantity = self._calculate_position_size(signal)
                
                order = Order(
                    id=f"{self.name}_{signal.symbol}_{datetime.now().timestamp()}",
                    symbol=signal.symbol,
                    side=OrderSide.BUY,
                    type=OrderType.MARKET,
                    quantity=quantity,
                    status=OrderStatus.PENDING
                )
                
                result = await order_manager.place_order(order)
                
                if result['success']:
                    # í¬ì§€ì…˜ ìƒì„±
                    position = Position(
                        symbol=signal.symbol,
                        side='LONG',
                        quantity=quantity,
                        entry_price=signal.price,
                        current_price=signal.price,
                        pnl=Decimal('0'),
                        pnl_percentage=Decimal('0'),
                        timestamp=datetime.now()
                    )
                    
                    self.positions[signal.symbol] = position
                    logger.info(f"Opened LONG position: {signal.symbol}")
                
            elif signal.signal_type == 'SELL' and signal.symbol in self.positions:
                # ë§¤ë„ ì‹ í˜¸
                position = self.positions[signal.symbol]
                
                order = Order(
                    id=f"{self.name}_{signal.symbol}_{datetime.now().timestamp()}",
                    symbol=signal.symbol,
                    side=OrderSide.SELL,
                    type=OrderType.MARKET,
                    quantity=position.quantity,
                    status=OrderStatus.PENDING
                )
                
                result = await order_manager.place_order(order)
                
                if result['success']:
                    # í¬ì§€ì…˜ ì²­ì‚°
                    del self.positions[signal.symbol]
                    logger.info(f"Closed position: {signal.symbol}")
            
            # ì‹ í˜¸ ê¸°ë¡
            self.signals.append(signal)
            
        except Exception as e:
            logger.error(f"Failed to process signal: {e}")
    
    async def _manage_positions(self, market_data: Dict[str, Any], order_manager):
        """í¬ì§€ì…˜ ê´€ë¦¬"""
        try:
            for symbol, position in list(self.positions.items()):
                # í˜„ì¬ ê°€ê²© ì—…ë°ì´íŠ¸
                if symbol in market_data:
                    current_price = market_data[symbol]['price']
                    position.current_price = current_price
                    
                    # PnL ê³„ì‚°
                    if position.side == 'LONG':
                        position.pnl = (current_price - position.entry_price) * position.quantity
                        position.pnl_percentage = (
                            (current_price - position.entry_price) / position.entry_price * 100
                        )
                    
                    # ì²­ì‚° ì¡°ê±´ í™•ì¸
                    if await self.should_exit_position(position, market_data):
                        order = Order(
                            id=f"{self.name}_{symbol}_{datetime.now().timestamp()}",
                            symbol=symbol,
                            side=OrderSide.SELL,
                            type=OrderType.MARKET,
                            quantity=position.quantity,
                            status=OrderStatus.PENDING
                        )
                        
                        result = await order_manager.place_order(order)
                        
                        if result['success']:
                            del self.positions[symbol]
                            logger.info(f"Exited position: {symbol}")
                
        except Exception as e:
            logger.error(f"Failed to manage positions: {e}")
    
    def _calculate_position_size(self, signal: Signal) -> Decimal:
        """í¬ì§€ì…˜ í¬ê¸° ê³„ì‚°"""
        # ê¸°ë³¸ í¬ì§€ì…˜ í¬ê¸° (íŒŒë¼ë¯¸í„°ì—ì„œ ì„¤ì •)
        base_size = self.parameters.get('base_position_size', Decimal('0.1'))
        
        # ì‹ í˜¸ ê°•ë„ì— ë”°ë¥¸ ì¡°ì •
        adjusted_size = base_size * signal.strength
        
        # ìµœì†Œ/ìµœëŒ€ í¬ê¸° ì œí•œ
        min_size = self.parameters.get('min_position_size', Decimal('0.01'))
        max_size = self.parameters.get('max_position_size', Decimal('1.0'))
        
        return max(min_size, min(adjusted_size, max_size))
    
    def stop(self):
        """ì „ëµ ì¤‘ì§€"""
        self.is_running = False
        logger.info(f"Stopped strategy: {self.name}")
    
    def get_performance(self) -> Dict[str, Any]:
        """ì „ëµ ì„±ê³¼ ì¡°íšŒ"""
        total_pnl = sum(position.pnl for position in self.positions.values())
        total_positions = len(self.positions)
        
        return {
            'strategy_name': self.name,
            'total_pnl': total_pnl,
            'total_positions': total_positions,
            'positions': [
                {
                    'symbol': pos.symbol,
                    'side': pos.side,
                    'quantity': pos.quantity,
                    'entry_price': pos.entry_price,
                    'current_price': pos.current_price,
                    'pnl': pos.pnl,
                    'pnl_percentage': pos.pnl_percentage
                }
                for pos in self.positions.values()
            ],
            'signals_count': len(self.signals)
        }
```

## ğŸ¯ **ë‹¤ìŒ ë‹¨ê³„**

### ğŸ“‹ **ì™„ë£Œëœ ì‘ì—…**
- âœ… ê³ ê¸‰ ì£¼ë¬¸ íƒ€ì… êµ¬í˜„ (OCO, íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘)
- âœ… í¬íŠ¸í´ë¦¬ì˜¤ ê´€ë¦¬ ì‹œìŠ¤í…œ
- âœ… ìë™ ë¦¬ë°¸ëŸ°ì‹± ì‹œìŠ¤í…œ
- âœ… ì•Œê³ ë¦¬ì¦˜ íŠ¸ë ˆì´ë”© ê¸°ë³¸ í”„ë ˆì„ì›Œí¬

### ğŸ”„ **ì§„í–‰ ì¤‘ì¸ ì‘ì—…**
- ğŸ”„ êµ¬ì²´ì ì¸ ì „ëµ êµ¬í˜„ (ì´ë™í‰ê· , RSI ë“±)
- ğŸ”„ ë°±í…ŒìŠ¤íŒ… ì‹œìŠ¤í…œ
- ğŸ”„ ë¦¬ìŠ¤í¬ ê´€ë¦¬ ì‹œìŠ¤í…œ

### â³ **ë‹¤ìŒ ë‹¨ê³„**
1. **Phase 1.3 ëª¨ë‹ˆí„°ë§** ë¬¸ì„œ ìƒì„±
2. **Phase 1.4 ì¸í”„ë¼ í™•ì¥** ë¬¸ì„œ ìƒì„±
3. **Phase 2 ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤** ì‹œì‘

---

**ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸**: 2024-01-31
**ë‹¤ìŒ ì—…ë°ì´íŠ¸**: 2024-02-01 (Phase 1.3 ëª¨ë‹ˆí„°ë§)
**ê³ ê¸‰ ê¸°ëŠ¥**: OCO, íŠ¸ë ˆì¼ë§ ìŠ¤íƒ‘, í¬íŠ¸í´ë¦¬ì˜¤ ê´€ë¦¬, ì•Œê³ ë¦¬ì¦˜ íŠ¸ë ˆì´ë”©
**ì„±ëŠ¥ ëª©í‘œ**: ì£¼ë¬¸ ì‹¤í–‰ < 50ms, í¬íŠ¸í´ë¦¬ì˜¤ ê³„ì‚° < 100ms 