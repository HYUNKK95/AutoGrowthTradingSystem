# 📊 Phase 1.3: 모니터링 및 알림 시스템

## 📋 **개요**

### 🎯 **목표**
- **실시간 모니터링**: 24/7 시스템 상태 감시
- **성능 메트릭 수집**: 모든 거래 및 시스템 성능 추적
- **자동 알림**: 임계값 기반 자동 알림 시스템
- **대시보드**: 실시간 거래 및 시스템 대시보드

### 📊 **성능 목표**
- **모니터링 지연**: < 30초
- **알림 전송 시간**: < 10초
- **데이터 수집 빈도**: 1초 간격
- **대시보드 업데이트**: 실시간

## 🏗️ **모니터링 아키텍처**

### 📁 **모니터링 시스템 구조**
```
src/monitoring/
├── __init__.py
├── core/                           # 핵심 모니터링
│   ├── __init__.py
│   ├── metrics_collector.py        # 메트릭 수집기
│   ├── health_checker.py           # 헬스 체커
│   ├── performance_monitor.py      # 성능 모니터
│   └── alert_manager.py            # 알림 관리자
├── dashboards/                     # 대시보드
│   ├── __init__.py
│   ├── trading_dashboard.py        # 거래 대시보드
│   ├── system_dashboard.py         # 시스템 대시보드
│   └── portfolio_dashboard.py      # 포트폴리오 대시보드
├── alerts/                         # 알림 시스템
│   ├── __init__.py
│   ├── alert_rules.py              # 알림 규칙
│   ├── notification_channels.py    # 알림 채널
│   └── alert_history.py            # 알림 히스토리
└── reporting/                      # 리포팅
    ├── __init__.py
    ├── daily_report.py             # 일일 리포트
    ├── performance_report.py       # 성과 리포트
    └── risk_report.py              # 리스크 리포트
```

## 📊 **메트릭 수집 시스템**

### 🔧 **메트릭 수집기**

```python
# src/monitoring/core/metrics_collector.py
import asyncio
import time
from typing import Dict, List, Optional, Any
from decimal import Decimal
from datetime import datetime, timedelta
from dataclasses import dataclass
from collections import defaultdict, deque
import psutil
import json

@dataclass
class Metric:
    """메트릭 데이터"""
    name: str
    value: float
    timestamp: datetime
    tags: Dict[str, str]
    metadata: Dict[str, Any] = None

@dataclass
class TradingMetric:
    """거래 메트릭"""
    symbol: str
    price: Decimal
    volume: Decimal
    timestamp: datetime
    exchange: str
    bid: Decimal
    ask: Decimal
    spread: Decimal

class MetricsCollector:
    """메트릭 수집기"""
    
    def __init__(self, storage_backend=None):
        self.storage_backend = storage_backend
        self.metrics_buffer = deque(maxlen=10000)
        self.trading_metrics = defaultdict(list)
        self.system_metrics = {}
        self.collection_interval = 1  # 1초
        self.is_running = False
        
        # 메트릭 카운터
        self.metrics_count = 0
        self.last_collection_time = datetime.now()
        
        logger.info("Initialized metrics collector")
    
    async def start_collection(self):
        """메트릭 수집 시작"""
        self.is_running = True
        
        while self.is_running:
            try:
                # 시스템 메트릭 수집
                await self._collect_system_metrics()
                
                # 거래 메트릭 수집
                await self._collect_trading_metrics()
                
                # 메트릭 저장
                await self._store_metrics()
                
                # 버퍼 정리
                await self._cleanup_old_metrics()
                
                await asyncio.sleep(self.collection_interval)
                
            except Exception as e:
                logger.error(f"Error collecting metrics: {e}")
                await asyncio.sleep(5)
    
    async def _collect_system_metrics(self):
        """시스템 메트릭 수집"""
        try:
            # CPU 사용률
            cpu_percent = psutil.cpu_percent(interval=1)
            self._add_metric('system.cpu.usage', cpu_percent, {'type': 'system'})
            
            # 메모리 사용률
            memory = psutil.virtual_memory()
            self._add_metric('system.memory.usage', memory.percent, {'type': 'system'})
            self._add_metric('system.memory.available', memory.available, {'type': 'system'})
            
            # 디스크 사용률
            disk = psutil.disk_usage('/')
            self._add_metric('system.disk.usage', (disk.used / disk.total) * 100, {'type': 'system'})
            
            # 네트워크 I/O
            network = psutil.net_io_counters()
            self._add_metric('system.network.bytes_sent', network.bytes_sent, {'type': 'system'})
            self._add_metric('system.network.bytes_recv', network.bytes_recv, {'type': 'system'})
            
            # 프로세스 정보
            process = psutil.Process()
            self._add_metric('system.process.cpu_percent', process.cpu_percent(), {'type': 'system'})
            self._add_metric('system.process.memory_percent', process.memory_percent(), {'type': 'system'})
            
            # 애플리케이션 메트릭
            self._add_metric('app.active_connections', len(self._get_active_connections()), {'type': 'application'})
            self._add_metric('app.request_rate', self._calculate_request_rate(), {'type': 'application'})
            self._add_metric('app.error_rate', self._calculate_error_rate(), {'type': 'application'})
            
        except Exception as e:
            logger.error(f"Failed to collect system metrics: {e}")
    
    async def _collect_trading_metrics(self):
        """거래 메트릭 수집"""
        try:
            # 거래소별 메트릭 수집
            for exchange_name, exchange in self.exchanges.items():
                try:
                    # 거래소 상태 확인
                    health = await exchange.health_check()
                    
                    self._add_metric(
                        f'trading.exchange.{exchange_name}.connected',
                        1 if health['connected'] else 0,
                        {'exchange': exchange_name, 'type': 'trading'}
                    )
                    
                    self._add_metric(
                        f'trading.exchange.{exchange_name}.response_time',
                        health.get('response_time', 0),
                        {'exchange': exchange_name, 'type': 'trading'}
                    )
                    
                    # 거래량 메트릭
                    for symbol in self.monitored_symbols:
                        ticker = await exchange.get_ticker(symbol)
                        if ticker:
                            trading_metric = TradingMetric(
                                symbol=symbol,
                                price=ticker.last_price,
                                volume=ticker.volume,
                                timestamp=datetime.now(),
                                exchange=exchange_name,
                                bid=ticker.bid,
                                ask=ticker.ask,
                                spread=ticker.ask - ticker.bid
                            )
                            
                            self.trading_metrics[symbol].append(trading_metric)
                            
                            # 가격 메트릭
                            self._add_metric(
                                f'trading.price.{symbol}',
                                float(ticker.last_price),
                                {'symbol': symbol, 'exchange': exchange_name, 'type': 'trading'}
                            )
                            
                            # 스프레드 메트릭
                            spread_percentage = float((ticker.ask - ticker.bid) / ticker.bid * 100)
                            self._add_metric(
                                f'trading.spread.{symbol}',
                                spread_percentage,
                                {'symbol': symbol, 'exchange': exchange_name, 'type': 'trading'}
                            )
                            
                except Exception as e:
                    logger.error(f"Failed to collect metrics for {exchange_name}: {e}")
                    self._add_metric(
                        f'trading.exchange.{exchange_name}.error',
                        1,
                        {'exchange': exchange_name, 'type': 'trading', 'error': str(e)}
                    )
                    
        except Exception as e:
            logger.error(f"Failed to collect trading metrics: {e}")
    
    def _add_metric(self, name: str, value: float, tags: Dict[str, str], metadata: Dict[str, Any] = None):
        """메트릭 추가"""
        metric = Metric(
            name=name,
            value=value,
            timestamp=datetime.now(),
            tags=tags,
            metadata=metadata
        )
        
        self.metrics_buffer.append(metric)
        self.metrics_count += 1
    
    async def _store_metrics(self):
        """메트릭 저장"""
        if not self.metrics_buffer:
            return
        
        try:
            metrics_batch = list(self.metrics_buffer)
            self.metrics_buffer.clear()
            
            if self.storage_backend:
                await self.storage_backend.store_metrics(metrics_batch)
            
            # 메모리 내 저장 (최근 1시간)
            current_time = datetime.now()
            cutoff_time = current_time - timedelta(hours=1)
            
            # 오래된 메트릭 제거
            self.metrics_buffer = deque(
                [m for m in self.metrics_buffer if m.timestamp > cutoff_time],
                maxlen=10000
            )
            
        except Exception as e:
            logger.error(f"Failed to store metrics: {e}")
    
    async def _cleanup_old_metrics(self):
        """오래된 메트릭 정리"""
        try:
            current_time = datetime.now()
            cutoff_time = current_time - timedelta(hours=1)
            
            # 거래 메트릭 정리
            for symbol in list(self.trading_metrics.keys()):
                self.trading_metrics[symbol] = [
                    m for m in self.trading_metrics[symbol]
                    if m.timestamp > cutoff_time
                ]
                
                # 최대 1000개만 유지
                if len(self.trading_metrics[symbol]) > 1000:
                    self.trading_metrics[symbol] = self.trading_metrics[symbol][-1000:]
                    
        except Exception as e:
            logger.error(f"Failed to cleanup old metrics: {e}")
    
    def _get_active_connections(self) -> List[Any]:
        """활성 연결 수 조회"""
        # 실제 구현에서는 현재 활성 연결 목록 반환
        return []
    
    def _calculate_request_rate(self) -> float:
        """요청률 계산"""
        # 실제 구현에서는 요청률 계산
        return 0.0
    
    def _calculate_error_rate(self) -> float:
        """오류률 계산"""
        # 실제 구현에서는 오류률 계산
        return 0.0
    
    def get_metrics_summary(self, time_range: str = '1h') -> Dict[str, Any]:
        """메트릭 요약 조회"""
        try:
            current_time = datetime.now()
            
            if time_range == '1h':
                cutoff_time = current_time - timedelta(hours=1)
            elif time_range == '1d':
                cutoff_time = current_time - timedelta(days=1)
            elif time_range == '7d':
                cutoff_time = current_time - timedelta(days=7)
            else:
                cutoff_time = current_time - timedelta(hours=1)
            
            # 필터링된 메트릭
            filtered_metrics = [
                m for m in self.metrics_buffer
                if m.timestamp > cutoff_time
            ]
            
            # 메트릭별 통계
            metrics_summary = {}
            for metric in filtered_metrics:
                if metric.name not in metrics_summary:
                    metrics_summary[metric.name] = {
                        'count': 0,
                        'min': float('inf'),
                        'max': float('-inf'),
                        'sum': 0.0,
                        'values': []
                    }
                
                summary = metrics_summary[metric.name]
                summary['count'] += 1
                summary['min'] = min(summary['min'], metric.value)
                summary['max'] = max(summary['max'], metric.value)
                summary['sum'] += metric.value
                summary['values'].append(metric.value)
            
            # 평균 계산
            for name, summary in metrics_summary.items():
                summary['avg'] = summary['sum'] / summary['count']
                del summary['values']  # 메모리 절약
            
            return {
                'time_range': time_range,
                'total_metrics': len(filtered_metrics),
                'metrics_summary': metrics_summary,
                'collection_stats': {
                    'total_collected': self.metrics_count,
                    'last_collection': self.last_collection_time.isoformat()
                }
            }
            
        except Exception as e:
            logger.error(f"Failed to get metrics summary: {e}")
            return {}
    
    def stop_collection(self):
        """메트릭 수집 중지"""
        self.is_running = False
        logger.info("Stopped metrics collection")
```

## 🏥 **헬스 체커**

```python
# src/monitoring/core/health_checker.py
import asyncio
import time
from typing import Dict, List, Optional, Any
from datetime import datetime, timedelta
from dataclasses import dataclass
import aiohttp
import json

@dataclass
class HealthStatus:
    """건강 상태 정보"""
    component: str
    status: str  # 'healthy', 'degraded', 'unhealthy'
    response_time: float
    last_check: datetime
    error_message: Optional[str] = None
    metadata: Dict[str, Any] = None

class HealthChecker:
    """헬스 체커"""
    
    def __init__(self, alert_manager=None):
        self.alert_manager = alert_manager
        self.health_status = {}
        self.check_interval = 30  # 30초
        self.is_running = False
        
        # 헬스 체크 구성
        self.health_checks = {
            'database': self._check_database,
            'redis': self._check_redis,
            'exchanges': self._check_exchanges,
            'api': self._check_api,
            'external_services': self._check_external_services
        }
        
        logger.info("Initialized health checker")
    
    async def start_monitoring(self):
        """헬스 체크 모니터링 시작"""
        self.is_running = True
        
        while self.is_running:
            try:
                # 모든 컴포넌트 헬스 체크
                for component, check_func in self.health_checks.items():
                    await self._perform_health_check(component, check_func)
                
                # 알림 전송
                await self._send_health_alerts()
                
                await asyncio.sleep(self.check_interval)
                
            except Exception as e:
                logger.error(f"Error in health monitoring: {e}")
                await asyncio.sleep(10)
    
    async def _perform_health_check(self, component: str, check_func):
        """헬스 체크 수행"""
        try:
            start_time = time.time()
            
            # 헬스 체크 실행
            result = await check_func()
            
            end_time = time.time()
            response_time = end_time - start_time
            
            # 상태 결정
            if result['healthy']:
                status = 'healthy'
                error_message = None
            elif result.get('degraded', False):
                status = 'degraded'
                error_message = result.get('message', 'Component is degraded')
            else:
                status = 'unhealthy'
                error_message = result.get('message', 'Component is unhealthy')
            
            # 상태 업데이트
            health_status = HealthStatus(
                component=component,
                status=status,
                response_time=response_time,
                last_check=datetime.now(),
                error_message=error_message,
                metadata=result.get('metadata', {})
            )
            
            self.health_status[component] = health_status
            
            # 상태 변경 감지
            await self._detect_status_change(component, health_status)
            
        except Exception as e:
            logger.error(f"Health check failed for {component}: {e}")
            
            health_status = HealthStatus(
                component=component,
                status='unhealthy',
                response_time=0.0,
                last_check=datetime.now(),
                error_message=str(e)
            )
            
            self.health_status[component] = health_status
    
    async def _check_database(self) -> Dict[str, Any]:
        """데이터베이스 헬스 체크"""
        try:
            # 데이터베이스 연결 테스트
            async with self.db_pool.acquire() as conn:
                await conn.execute("SELECT 1")
            
            return {
                'healthy': True,
                'message': 'Database is healthy',
                'metadata': {
                    'connection_pool_size': self.db_pool.size,
                    'active_connections': self.db_pool.size - self.db_pool.freesize
                }
            }
            
        except Exception as e:
            return {
                'healthy': False,
                'message': f'Database health check failed: {e}'
            }
    
    async def _check_redis(self) -> Dict[str, Any]:
        """Redis 헬스 체크"""
        try:
            # Redis 연결 테스트
            await self.redis.ping()
            
            # 메모리 사용량 확인
            info = await self.redis.info('memory')
            used_memory = int(info['used_memory'])
            max_memory = int(info.get('maxmemory', 0))
            
            memory_usage_percent = (used_memory / max_memory * 100) if max_memory > 0 else 0
            
            if memory_usage_percent > 90:
                return {
                    'healthy': False,
                    'degraded': True,
                    'message': f'Redis memory usage is high: {memory_usage_percent:.1f}%'
                }
            
            return {
                'healthy': True,
                'message': 'Redis is healthy',
                'metadata': {
                    'memory_usage_percent': memory_usage_percent,
                    'used_memory': used_memory,
                    'max_memory': max_memory
                }
            }
            
        except Exception as e:
            return {
                'healthy': False,
                'message': f'Redis health check failed: {e}'
            }
    
    async def _check_exchanges(self) -> Dict[str, Any]:
        """거래소 헬스 체크"""
        try:
            exchange_status = {}
            healthy_exchanges = 0
            total_exchanges = len(self.exchanges)
            
            for exchange_name, exchange in self.exchanges.items():
                try:
                    health = await exchange.health_check()
                    exchange_status[exchange_name] = health
                    
                    if health['connected']:
                        healthy_exchanges += 1
                        
                except Exception as e:
                    exchange_status[exchange_name] = {
                        'connected': False,
                        'error': str(e)
                    }
            
            health_percentage = (healthy_exchanges / total_exchanges * 100) if total_exchanges > 0 else 0
            
            if health_percentage == 100:
                return {
                    'healthy': True,
                    'message': 'All exchanges are healthy',
                    'metadata': {
                        'healthy_exchanges': healthy_exchanges,
                        'total_exchanges': total_exchanges,
                        'health_percentage': health_percentage,
                        'exchange_status': exchange_status
                    }
                }
            elif health_percentage >= 50:
                return {
                    'healthy': False,
                    'degraded': True,
                    'message': f'Some exchanges are unhealthy: {health_percentage:.1f}% healthy',
                    'metadata': {
                        'healthy_exchanges': healthy_exchanges,
                        'total_exchanges': total_exchanges,
                        'health_percentage': health_percentage,
                        'exchange_status': exchange_status
                    }
                }
            else:
                return {
                    'healthy': False,
                    'message': f'Most exchanges are unhealthy: {health_percentage:.1f}% healthy',
                    'metadata': {
                        'healthy_exchanges': healthy_exchanges,
                        'total_exchanges': total_exchanges,
                        'health_percentage': health_percentage,
                        'exchange_status': exchange_status
                    }
                }
                
        except Exception as e:
            return {
                'healthy': False,
                'message': f'Exchange health check failed: {e}'
            }
    
    async def _check_api(self) -> Dict[str, Any]:
        """API 헬스 체크"""
        try:
            # API 엔드포인트 테스트
            async with aiohttp.ClientSession() as session:
                async with session.get('http://localhost:8000/health') as response:
                    if response.status == 200:
                        data = await response.json()
                        return {
                            'healthy': True,
                            'message': 'API is healthy',
                            'metadata': data
                        }
                    else:
                        return {
                            'healthy': False,
                            'message': f'API returned status {response.status}'
                        }
                        
        except Exception as e:
            return {
                'healthy': False,
                'message': f'API health check failed: {e}'
            }
    
    async def _check_external_services(self) -> Dict[str, Any]:
        """외부 서비스 헬스 체크"""
        try:
            external_services = {
                'binance_api': 'https://api.binance.com/api/v3/ping',
                'coinbase_api': 'https://api.exchange.coinbase.com/time'
            }
            
            service_status = {}
            healthy_services = 0
            total_services = len(external_services)
            
            async with aiohttp.ClientSession() as session:
                for service_name, url in external_services.items():
                    try:
                        async with session.get(url, timeout=5) as response:
                            if response.status == 200:
                                service_status[service_name] = {'status': 'healthy'}
                                healthy_services += 1
                            else:
                                service_status[service_name] = {
                                    'status': 'unhealthy',
                                    'error': f'HTTP {response.status}'
                                }
                    except Exception as e:
                        service_status[service_name] = {
                            'status': 'unhealthy',
                            'error': str(e)
                        }
            
            health_percentage = (healthy_services / total_services * 100) if total_services > 0 else 0
            
            return {
                'healthy': health_percentage >= 80,
                'degraded': 50 <= health_percentage < 80,
                'message': f'External services health: {health_percentage:.1f}% healthy',
                'metadata': {
                    'healthy_services': healthy_services,
                    'total_services': total_services,
                    'health_percentage': health_percentage,
                    'service_status': service_status
                }
            }
            
        except Exception as e:
            return {
                'healthy': False,
                'message': f'External services health check failed: {e}'
            }
    
    async def _detect_status_change(self, component: str, health_status: HealthStatus):
        """상태 변경 감지"""
        try:
            previous_status = self.health_status.get(component)
            
            if previous_status and previous_status.status != health_status.status:
                # 상태 변경 알림
                if self.alert_manager:
                    await self.alert_manager.send_alert(
                        alert_type='health_status_change',
                        severity='warning' if health_status.status == 'degraded' else 'critical',
                        title=f'Health Status Change: {component}',
                        message=f'{component} status changed from {previous_status.status} to {health_status.status}',
                        metadata={
                            'component': component,
                            'previous_status': previous_status.status,
                            'current_status': health_status.status,
                            'response_time': health_status.response_time,
                            'error_message': health_status.error_message
                        }
                    )
                    
        except Exception as e:
            logger.error(f"Failed to detect status change: {e}")
    
    async def _send_health_alerts(self):
        """헬스 알림 전송"""
        try:
            if not self.alert_manager:
                return
            
            # 전체 시스템 상태 확인
            unhealthy_components = [
                component for component, status in self.health_status.items()
                if status.status == 'unhealthy'
            ]
            
            degraded_components = [
                component for component, status in self.health_status.items()
                if status.status == 'degraded'
            ]
            
            if unhealthy_components:
                await self.alert_manager.send_alert(
                    alert_type='system_unhealthy',
                    severity='critical',
                    title='System Unhealthy',
                    message=f'Unhealthy components: {", ".join(unhealthy_components)}',
                    metadata={
                        'unhealthy_components': unhealthy_components,
                        'degraded_components': degraded_components
                    }
                )
            elif degraded_components:
                await self.alert_manager.send_alert(
                    alert_type='system_degraded',
                    severity='warning',
                    title='System Degraded',
                    message=f'Degraded components: {", ".join(degraded_components)}',
                    metadata={
                        'degraded_components': degraded_components
                    }
                )
                
        except Exception as e:
            logger.error(f"Failed to send health alerts: {e}")
    
    def get_health_summary(self) -> Dict[str, Any]:
        """헬스 상태 요약"""
        try:
            total_components = len(self.health_status)
            healthy_components = sum(1 for s in self.health_status.values() if s.status == 'healthy')
            degraded_components = sum(1 for s in self.health_status.values() if s.status == 'degraded')
            unhealthy_components = sum(1 for s in self.health_status.values() if s.status == 'unhealthy')
            
            return {
                'overall_status': 'healthy' if unhealthy_components == 0 else 'unhealthy',
                'total_components': total_components,
                'healthy_components': healthy_components,
                'degraded_components': degraded_components,
                'unhealthy_components': unhealthy_components,
                'health_percentage': (healthy_components / total_components * 100) if total_components > 0 else 0,
                'last_check': datetime.now().isoformat(),
                'component_status': {
                    component: {
                        'status': status.status,
                        'response_time': status.response_time,
                        'last_check': status.last_check.isoformat(),
                        'error_message': status.error_message
                    }
                    for component, status in self.health_status.items()
                }
            }
            
        except Exception as e:
            logger.error(f"Failed to get health summary: {e}")
            return {}
    
    def stop_monitoring(self):
        """헬스 체크 모니터링 중지"""
        self.is_running = False
        logger.info("Stopped health monitoring")
```

## 🚨 **알림 관리 시스템**

```python
# src/monitoring/core/alert_manager.py
import asyncio
from typing import Dict, List, Optional, Any
from datetime import datetime
from dataclasses import dataclass
import json

@dataclass
class Alert:
    """알림 정보"""
    id: str
    alert_type: str
    severity: str  # 'info', 'warning', 'critical'
    title: str
    message: str
    timestamp: datetime
    metadata: Dict[str, Any] = None
    acknowledged: bool = False
    acknowledged_by: Optional[str] = None
    acknowledged_at: Optional[datetime] = None

class AlertManager:
    """알림 관리자"""
    
    def __init__(self, notification_channels=None):
        self.notification_channels = notification_channels or []
        self.active_alerts = {}
        self.alert_history = []
        self.alert_rules = {}
        self.alert_counters = defaultdict(int)
        
        logger.info("Initialized alert manager")
    
    async def send_alert(self, alert_type: str, severity: str, title: str, 
                        message: str, metadata: Dict[str, Any] = None) -> str:
        """알림 전송"""
        try:
            # 알림 ID 생성
            alert_id = f"{alert_type}_{datetime.now().timestamp()}"
            
            # 알림 생성
            alert = Alert(
                id=alert_id,
                alert_type=alert_type,
                severity=severity,
                title=title,
                message=message,
                timestamp=datetime.now(),
                metadata=metadata or {}
            )
            
            # 알림 규칙 확인
            if not await self._should_send_alert(alert):
                logger.info(f"Alert suppressed by rules: {alert_id}")
                return alert_id
            
            # 활성 알림에 추가
            self.active_alerts[alert_id] = alert
            
            # 알림 카운터 증가
            self.alert_counters[alert_type] += 1
            
            # 알림 채널로 전송
            await self._send_to_channels(alert)
            
            logger.info(f"Alert sent: {alert_id} - {severity}: {title}")
            return alert_id
            
        except Exception as e:
            logger.error(f"Failed to send alert: {e}")
            return None
    
    async def _should_send_alert(self, alert: Alert) -> bool:
        """알림 전송 여부 확인"""
        try:
            # 알림 규칙 확인
            if alert.alert_type in self.alert_rules:
                rule = self.alert_rules[alert.alert_type]
                
                # 빈도 제한 확인
                if 'rate_limit' in rule:
                    rate_limit = rule['rate_limit']
                    current_count = self.alert_counters[alert.alert_type]
                    
                    if current_count >= rate_limit['max_alerts']:
                        time_window = rate_limit.get('time_window', 3600)  # 기본 1시간
                        cutoff_time = datetime.now().timestamp() - time_window
                        
                        # 오래된 알림 제거
                        old_alerts = [
                            aid for aid, a in self.active_alerts.items()
                            if a.alert_type == alert.alert_type and a.timestamp.timestamp() < cutoff_time
                        ]
                        
                        for old_alert_id in old_alerts:
                            del self.active_alerts[old_alert_id]
                            self.alert_counters[alert.alert_type] -= 1
                        
                        # 여전히 제한을 초과하면 알림 차단
                        if self.alert_counters[alert.alert_type] >= rate_limit['max_alerts']:
                            return False
                
                # 중복 알림 방지
                if rule.get('prevent_duplicates', False):
                    for existing_alert in self.active_alerts.values():
                        if (existing_alert.alert_type == alert.alert_type and
                            existing_alert.severity == alert.severity and
                            existing_alert.title == alert.title):
                            return False
            
            return True
            
        except Exception as e:
            logger.error(f"Failed to check alert rules: {e}")
            return True
    
    async def _send_to_channels(self, alert: Alert):
        """알림 채널로 전송"""
        try:
            for channel in self.notification_channels:
                try:
                    await channel.send_alert(alert)
                except Exception as e:
                    logger.error(f"Failed to send alert to channel {channel.name}: {e}")
                    
        except Exception as e:
            logger.error(f"Failed to send alert to channels: {e}")
    
    async def acknowledge_alert(self, alert_id: str, acknowledged_by: str) -> bool:
        """알림 확인"""
        try:
            if alert_id not in self.active_alerts:
                return False
            
            alert = self.active_alerts[alert_id]
            alert.acknowledged = True
            alert.acknowledged_by = acknowledged_by
            alert.acknowledged_at = datetime.now()
            
            logger.info(f"Alert acknowledged: {alert_id} by {acknowledged_by}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to acknowledge alert: {e}")
            return False
    
    async def resolve_alert(self, alert_id: str, resolved_by: str, resolution_notes: str = None) -> bool:
        """알림 해결"""
        try:
            if alert_id not in self.active_alerts:
                return False
            
            alert = self.active_alerts[alert_id]
            
            # 알림 히스토리로 이동
            alert.metadata = alert.metadata or {}
            alert.metadata['resolved_by'] = resolved_by
            alert.metadata['resolved_at'] = datetime.now().isoformat()
            if resolution_notes:
                alert.metadata['resolution_notes'] = resolution_notes
            
            self.alert_history.append(alert)
            del self.active_alerts[alert_id]
            
            # 알림 카운터 감소
            self.alert_counters[alert.alert_type] = max(0, self.alert_counters[alert.alert_type] - 1)
            
            logger.info(f"Alert resolved: {alert_id} by {resolved_by}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to resolve alert: {e}")
            return False
    
    def add_alert_rule(self, alert_type: str, rule: Dict[str, Any]):
        """알림 규칙 추가"""
        self.alert_rules[alert_type] = rule
        logger.info(f"Added alert rule for {alert_type}")
    
    def get_active_alerts(self, severity: Optional[str] = None) -> List[Alert]:
        """활성 알림 조회"""
        alerts = list(self.active_alerts.values())
        
        if severity:
            alerts = [a for a in alerts if a.severity == severity]
        
        return sorted(alerts, key=lambda x: x.timestamp, reverse=True)
    
    def get_alert_summary(self) -> Dict[str, Any]:
        """알림 요약"""
        try:
            total_active = len(self.active_alerts)
            total_history = len(self.alert_history)
            
            severity_counts = defaultdict(int)
            for alert in self.active_alerts.values():
                severity_counts[alert.severity] += 1
            
            return {
                'total_active_alerts': total_active,
                'total_alert_history': total_history,
                'severity_distribution': dict(severity_counts),
                'alert_type_distribution': dict(self.alert_counters),
                'last_alert': max([a.timestamp for a in self.active_alerts.values()]).isoformat() if self.active_alerts else None
            }
            
        except Exception as e:
            logger.error(f"Failed to get alert summary: {e}")
            return {}
```

## 🎯 **다음 단계**

### 📋 **완료된 작업**
- ✅ 메트릭 수집 시스템
- ✅ 헬스 체크 시스템
- ✅ 알림 관리 시스템
- ✅ 실시간 모니터링

### 🔄 **진행 중인 작업**
- 🔄 대시보드 구현
- 🔄 리포팅 시스템
- 🔄 알림 채널 구현

### ⏳ **다음 단계**
1. **Phase 1.4 인프라 확장** 문서 생성
2. **Phase 2 마이크로서비스** 시작
3. **공통 컴포넌트** 완성

---

**마지막 업데이트**: 2024-01-31
**다음 업데이트**: 2024-02-01 (Phase 1.4 인프라 확장)
**모니터링 목표**: 지연 < 30초, 알림 < 10초
**데이터 수집**: 1초 간격, 실시간 대시보드 