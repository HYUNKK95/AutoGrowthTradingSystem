# ğŸ“Š Phase 1.3: ëª¨ë‹ˆí„°ë§ ë° ì•Œë¦¼ ì‹œìŠ¤í…œ

## ğŸ“‹ **ê°œìš”**

### ğŸ¯ **ëª©í‘œ**
- **ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§**: 24/7 ì‹œìŠ¤í…œ ìƒíƒœ ê°ì‹œ
- **ì„±ëŠ¥ ë©”íŠ¸ë¦­ ìˆ˜ì§‘**: ëª¨ë“  ê±°ë˜ ë° ì‹œìŠ¤í…œ ì„±ëŠ¥ ì¶”ì 
- **ìë™ ì•Œë¦¼**: ì„ê³„ê°’ ê¸°ë°˜ ìë™ ì•Œë¦¼ ì‹œìŠ¤í…œ
- **ëŒ€ì‹œë³´ë“œ**: ì‹¤ì‹œê°„ ê±°ë˜ ë° ì‹œìŠ¤í…œ ëŒ€ì‹œë³´ë“œ

### ğŸ“Š **ì„±ëŠ¥ ëª©í‘œ**
- **ëª¨ë‹ˆí„°ë§ ì§€ì—°**: < 30ì´ˆ
- **ì•Œë¦¼ ì „ì†¡ ì‹œê°„**: < 10ì´ˆ
- **ë°ì´í„° ìˆ˜ì§‘ ë¹ˆë„**: 1ì´ˆ ê°„ê²©
- **ëŒ€ì‹œë³´ë“œ ì—…ë°ì´íŠ¸**: ì‹¤ì‹œê°„

## ğŸ—ï¸ **ëª¨ë‹ˆí„°ë§ ì•„í‚¤í…ì²˜**

### ğŸ“ **ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ êµ¬ì¡°**
```
src/monitoring/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ core/                           # í•µì‹¬ ëª¨ë‹ˆí„°ë§
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ metrics_collector.py        # ë©”íŠ¸ë¦­ ìˆ˜ì§‘ê¸°
â”‚   â”œâ”€â”€ health_checker.py           # í—¬ìŠ¤ ì²´ì»¤
â”‚   â”œâ”€â”€ performance_monitor.py      # ì„±ëŠ¥ ëª¨ë‹ˆí„°
â”‚   â””â”€â”€ alert_manager.py            # ì•Œë¦¼ ê´€ë¦¬ì
â”œâ”€â”€ dashboards/                     # ëŒ€ì‹œë³´ë“œ
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ trading_dashboard.py        # ê±°ë˜ ëŒ€ì‹œë³´ë“œ
â”‚   â”œâ”€â”€ system_dashboard.py         # ì‹œìŠ¤í…œ ëŒ€ì‹œë³´ë“œ
â”‚   â””â”€â”€ portfolio_dashboard.py      # í¬íŠ¸í´ë¦¬ì˜¤ ëŒ€ì‹œë³´ë“œ
â”œâ”€â”€ alerts/                         # ì•Œë¦¼ ì‹œìŠ¤í…œ
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ alert_rules.py              # ì•Œë¦¼ ê·œì¹™
â”‚   â”œâ”€â”€ notification_channels.py    # ì•Œë¦¼ ì±„ë„
â”‚   â””â”€â”€ alert_history.py            # ì•Œë¦¼ íˆìŠ¤í† ë¦¬
â””â”€â”€ reporting/                      # ë¦¬í¬íŒ…
    â”œâ”€â”€ __init__.py
    â”œâ”€â”€ daily_report.py             # ì¼ì¼ ë¦¬í¬íŠ¸
    â”œâ”€â”€ performance_report.py       # ì„±ê³¼ ë¦¬í¬íŠ¸
    â””â”€â”€ risk_report.py              # ë¦¬ìŠ¤í¬ ë¦¬í¬íŠ¸
```

## ğŸ“Š **ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ì‹œìŠ¤í…œ**

### ğŸ”§ **ë©”íŠ¸ë¦­ ìˆ˜ì§‘ê¸°**

```python
# src/monitoring/core/metrics_collector.py
import asyncio
import time
from typing import Dict, List, Optional, Any
from decimal import Decimal
from datetime import datetime, timedelta
from dataclasses import dataclass
from collections import defaultdict, deque
import psutil
import json

@dataclass
class Metric:
    """ë©”íŠ¸ë¦­ ë°ì´í„°"""
    name: str
    value: float
    timestamp: datetime
    tags: Dict[str, str]
    metadata: Dict[str, Any] = None

@dataclass
class TradingMetric:
    """ê±°ë˜ ë©”íŠ¸ë¦­"""
    symbol: str
    price: Decimal
    volume: Decimal
    timestamp: datetime
    exchange: str
    bid: Decimal
    ask: Decimal
    spread: Decimal

class MetricsCollector:
    """ë©”íŠ¸ë¦­ ìˆ˜ì§‘ê¸°"""
    
    def __init__(self, storage_backend=None):
        self.storage_backend = storage_backend
        self.metrics_buffer = deque(maxlen=10000)
        self.trading_metrics = defaultdict(list)
        self.system_metrics = {}
        self.collection_interval = 1  # 1ì´ˆ
        self.is_running = False
        
        # ë©”íŠ¸ë¦­ ì¹´ìš´í„°
        self.metrics_count = 0
        self.last_collection_time = datetime.now()
        
        logger.info("Initialized metrics collector")
    
    async def start_collection(self):
        """ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ì‹œì‘"""
        self.is_running = True
        
        while self.is_running:
            try:
                # ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
                await self._collect_system_metrics()
                
                # ê±°ë˜ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
                await self._collect_trading_metrics()
                
                # ë©”íŠ¸ë¦­ ì €ì¥
                await self._store_metrics()
                
                # ë²„í¼ ì •ë¦¬
                await self._cleanup_old_metrics()
                
                await asyncio.sleep(self.collection_interval)
                
            except Exception as e:
                logger.error(f"Error collecting metrics: {e}")
                await asyncio.sleep(5)
    
    async def _collect_system_metrics(self):
        """ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­ ìˆ˜ì§‘"""
        try:
            # CPU ì‚¬ìš©ë¥ 
            cpu_percent = psutil.cpu_percent(interval=1)
            self._add_metric('system.cpu.usage', cpu_percent, {'type': 'system'})
            
            # ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ 
            memory = psutil.virtual_memory()
            self._add_metric('system.memory.usage', memory.percent, {'type': 'system'})
            self._add_metric('system.memory.available', memory.available, {'type': 'system'})
            
            # ë””ìŠ¤í¬ ì‚¬ìš©ë¥ 
            disk = psutil.disk_usage('/')
            self._add_metric('system.disk.usage', (disk.used / disk.total) * 100, {'type': 'system'})
            
            # ë„¤íŠ¸ì›Œí¬ I/O
            network = psutil.net_io_counters()
            self._add_metric('system.network.bytes_sent', network.bytes_sent, {'type': 'system'})
            self._add_metric('system.network.bytes_recv', network.bytes_recv, {'type': 'system'})
            
            # í”„ë¡œì„¸ìŠ¤ ì •ë³´
            process = psutil.Process()
            self._add_metric('system.process.cpu_percent', process.cpu_percent(), {'type': 'system'})
            self._add_metric('system.process.memory_percent', process.memory_percent(), {'type': 'system'})
            
            # ì• í”Œë¦¬ì¼€ì´ì…˜ ë©”íŠ¸ë¦­
            self._add_metric('app.active_connections', len(self._get_active_connections()), {'type': 'application'})
            self._add_metric('app.request_rate', self._calculate_request_rate(), {'type': 'application'})
            self._add_metric('app.error_rate', self._calculate_error_rate(), {'type': 'application'})
            
        except Exception as e:
            logger.error(f"Failed to collect system metrics: {e}")
    
    async def _collect_trading_metrics(self):
        """ê±°ë˜ ë©”íŠ¸ë¦­ ìˆ˜ì§‘"""
        try:
            # ê±°ë˜ì†Œë³„ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
            for exchange_name, exchange in self.exchanges.items():
                try:
                    # ê±°ë˜ì†Œ ìƒíƒœ í™•ì¸
                    health = await exchange.health_check()
                    
                    self._add_metric(
                        f'trading.exchange.{exchange_name}.connected',
                        1 if health['connected'] else 0,
                        {'exchange': exchange_name, 'type': 'trading'}
                    )
                    
                    self._add_metric(
                        f'trading.exchange.{exchange_name}.response_time',
                        health.get('response_time', 0),
                        {'exchange': exchange_name, 'type': 'trading'}
                    )
                    
                    # ê±°ë˜ëŸ‰ ë©”íŠ¸ë¦­
                    for symbol in self.monitored_symbols:
                        ticker = await exchange.get_ticker(symbol)
                        if ticker:
                            trading_metric = TradingMetric(
                                symbol=symbol,
                                price=ticker.last_price,
                                volume=ticker.volume,
                                timestamp=datetime.now(),
                                exchange=exchange_name,
                                bid=ticker.bid,
                                ask=ticker.ask,
                                spread=ticker.ask - ticker.bid
                            )
                            
                            self.trading_metrics[symbol].append(trading_metric)
                            
                            # ê°€ê²© ë©”íŠ¸ë¦­
                            self._add_metric(
                                f'trading.price.{symbol}',
                                float(ticker.last_price),
                                {'symbol': symbol, 'exchange': exchange_name, 'type': 'trading'}
                            )
                            
                            # ìŠ¤í”„ë ˆë“œ ë©”íŠ¸ë¦­
                            spread_percentage = float((ticker.ask - ticker.bid) / ticker.bid * 100)
                            self._add_metric(
                                f'trading.spread.{symbol}',
                                spread_percentage,
                                {'symbol': symbol, 'exchange': exchange_name, 'type': 'trading'}
                            )
                            
                except Exception as e:
                    logger.error(f"Failed to collect metrics for {exchange_name}: {e}")
                    self._add_metric(
                        f'trading.exchange.{exchange_name}.error',
                        1,
                        {'exchange': exchange_name, 'type': 'trading', 'error': str(e)}
                    )
                    
        except Exception as e:
            logger.error(f"Failed to collect trading metrics: {e}")
    
    def _add_metric(self, name: str, value: float, tags: Dict[str, str], metadata: Dict[str, Any] = None):
        """ë©”íŠ¸ë¦­ ì¶”ê°€"""
        metric = Metric(
            name=name,
            value=value,
            timestamp=datetime.now(),
            tags=tags,
            metadata=metadata
        )
        
        self.metrics_buffer.append(metric)
        self.metrics_count += 1
    
    async def _store_metrics(self):
        """ë©”íŠ¸ë¦­ ì €ì¥"""
        if not self.metrics_buffer:
            return
        
        try:
            metrics_batch = list(self.metrics_buffer)
            self.metrics_buffer.clear()
            
            if self.storage_backend:
                await self.storage_backend.store_metrics(metrics_batch)
            
            # ë©”ëª¨ë¦¬ ë‚´ ì €ì¥ (ìµœê·¼ 1ì‹œê°„)
            current_time = datetime.now()
            cutoff_time = current_time - timedelta(hours=1)
            
            # ì˜¤ë˜ëœ ë©”íŠ¸ë¦­ ì œê±°
            self.metrics_buffer = deque(
                [m for m in self.metrics_buffer if m.timestamp > cutoff_time],
                maxlen=10000
            )
            
        except Exception as e:
            logger.error(f"Failed to store metrics: {e}")
    
    async def _cleanup_old_metrics(self):
        """ì˜¤ë˜ëœ ë©”íŠ¸ë¦­ ì •ë¦¬"""
        try:
            current_time = datetime.now()
            cutoff_time = current_time - timedelta(hours=1)
            
            # ê±°ë˜ ë©”íŠ¸ë¦­ ì •ë¦¬
            for symbol in list(self.trading_metrics.keys()):
                self.trading_metrics[symbol] = [
                    m for m in self.trading_metrics[symbol]
                    if m.timestamp > cutoff_time
                ]
                
                # ìµœëŒ€ 1000ê°œë§Œ ìœ ì§€
                if len(self.trading_metrics[symbol]) > 1000:
                    self.trading_metrics[symbol] = self.trading_metrics[symbol][-1000:]
                    
        except Exception as e:
            logger.error(f"Failed to cleanup old metrics: {e}")
    
    def _get_active_connections(self) -> List[Any]:
        """í™œì„± ì—°ê²° ìˆ˜ ì¡°íšŒ"""
        # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” í˜„ì¬ í™œì„± ì—°ê²° ëª©ë¡ ë°˜í™˜
        return []
    
    def _calculate_request_rate(self) -> float:
        """ìš”ì²­ë¥  ê³„ì‚°"""
        # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ìš”ì²­ë¥  ê³„ì‚°
        return 0.0
    
    def _calculate_error_rate(self) -> float:
        """ì˜¤ë¥˜ë¥  ê³„ì‚°"""
        # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì˜¤ë¥˜ë¥  ê³„ì‚°
        return 0.0
    
    def get_metrics_summary(self, time_range: str = '1h') -> Dict[str, Any]:
        """ë©”íŠ¸ë¦­ ìš”ì•½ ì¡°íšŒ"""
        try:
            current_time = datetime.now()
            
            if time_range == '1h':
                cutoff_time = current_time - timedelta(hours=1)
            elif time_range == '1d':
                cutoff_time = current_time - timedelta(days=1)
            elif time_range == '7d':
                cutoff_time = current_time - timedelta(days=7)
            else:
                cutoff_time = current_time - timedelta(hours=1)
            
            # í•„í„°ë§ëœ ë©”íŠ¸ë¦­
            filtered_metrics = [
                m for m in self.metrics_buffer
                if m.timestamp > cutoff_time
            ]
            
            # ë©”íŠ¸ë¦­ë³„ í†µê³„
            metrics_summary = {}
            for metric in filtered_metrics:
                if metric.name not in metrics_summary:
                    metrics_summary[metric.name] = {
                        'count': 0,
                        'min': float('inf'),
                        'max': float('-inf'),
                        'sum': 0.0,
                        'values': []
                    }
                
                summary = metrics_summary[metric.name]
                summary['count'] += 1
                summary['min'] = min(summary['min'], metric.value)
                summary['max'] = max(summary['max'], metric.value)
                summary['sum'] += metric.value
                summary['values'].append(metric.value)
            
            # í‰ê·  ê³„ì‚°
            for name, summary in metrics_summary.items():
                summary['avg'] = summary['sum'] / summary['count']
                del summary['values']  # ë©”ëª¨ë¦¬ ì ˆì•½
            
            return {
                'time_range': time_range,
                'total_metrics': len(filtered_metrics),
                'metrics_summary': metrics_summary,
                'collection_stats': {
                    'total_collected': self.metrics_count,
                    'last_collection': self.last_collection_time.isoformat()
                }
            }
            
        except Exception as e:
            logger.error(f"Failed to get metrics summary: {e}")
            return {}
    
    def stop_collection(self):
        """ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ì¤‘ì§€"""
        self.is_running = False
        logger.info("Stopped metrics collection")
```

## ğŸ¥ **í—¬ìŠ¤ ì²´ì»¤**

```python
# src/monitoring/core/health_checker.py
import asyncio
import time
from typing import Dict, List, Optional, Any
from datetime import datetime, timedelta
from dataclasses import dataclass
import aiohttp
import json

@dataclass
class HealthStatus:
    """ê±´ê°• ìƒíƒœ ì •ë³´"""
    component: str
    status: str  # 'healthy', 'degraded', 'unhealthy'
    response_time: float
    last_check: datetime
    error_message: Optional[str] = None
    metadata: Dict[str, Any] = None

class HealthChecker:
    """í—¬ìŠ¤ ì²´ì»¤"""
    
    def __init__(self, alert_manager=None):
        self.alert_manager = alert_manager
        self.health_status = {}
        self.check_interval = 30  # 30ì´ˆ
        self.is_running = False
        
        # í—¬ìŠ¤ ì²´í¬ êµ¬ì„±
        self.health_checks = {
            'database': self._check_database,
            'redis': self._check_redis,
            'exchanges': self._check_exchanges,
            'api': self._check_api,
            'external_services': self._check_external_services
        }
        
        logger.info("Initialized health checker")
    
    async def start_monitoring(self):
        """í—¬ìŠ¤ ì²´í¬ ëª¨ë‹ˆí„°ë§ ì‹œì‘"""
        self.is_running = True
        
        while self.is_running:
            try:
                # ëª¨ë“  ì»´í¬ë„ŒíŠ¸ í—¬ìŠ¤ ì²´í¬
                for component, check_func in self.health_checks.items():
                    await self._perform_health_check(component, check_func)
                
                # ì•Œë¦¼ ì „ì†¡
                await self._send_health_alerts()
                
                await asyncio.sleep(self.check_interval)
                
            except Exception as e:
                logger.error(f"Error in health monitoring: {e}")
                await asyncio.sleep(10)
    
    async def _perform_health_check(self, component: str, check_func):
        """í—¬ìŠ¤ ì²´í¬ ìˆ˜í–‰"""
        try:
            start_time = time.time()
            
            # í—¬ìŠ¤ ì²´í¬ ì‹¤í–‰
            result = await check_func()
            
            end_time = time.time()
            response_time = end_time - start_time
            
            # ìƒíƒœ ê²°ì •
            if result['healthy']:
                status = 'healthy'
                error_message = None
            elif result.get('degraded', False):
                status = 'degraded'
                error_message = result.get('message', 'Component is degraded')
            else:
                status = 'unhealthy'
                error_message = result.get('message', 'Component is unhealthy')
            
            # ìƒíƒœ ì—…ë°ì´íŠ¸
            health_status = HealthStatus(
                component=component,
                status=status,
                response_time=response_time,
                last_check=datetime.now(),
                error_message=error_message,
                metadata=result.get('metadata', {})
            )
            
            self.health_status[component] = health_status
            
            # ìƒíƒœ ë³€ê²½ ê°ì§€
            await self._detect_status_change(component, health_status)
            
        except Exception as e:
            logger.error(f"Health check failed for {component}: {e}")
            
            health_status = HealthStatus(
                component=component,
                status='unhealthy',
                response_time=0.0,
                last_check=datetime.now(),
                error_message=str(e)
            )
            
            self.health_status[component] = health_status
    
    async def _check_database(self) -> Dict[str, Any]:
        """ë°ì´í„°ë² ì´ìŠ¤ í—¬ìŠ¤ ì²´í¬"""
        try:
            # ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° í…ŒìŠ¤íŠ¸
            async with self.db_pool.acquire() as conn:
                await conn.execute("SELECT 1")
            
            return {
                'healthy': True,
                'message': 'Database is healthy',
                'metadata': {
                    'connection_pool_size': self.db_pool.size,
                    'active_connections': self.db_pool.size - self.db_pool.freesize
                }
            }
            
        except Exception as e:
            return {
                'healthy': False,
                'message': f'Database health check failed: {e}'
            }
    
    async def _check_redis(self) -> Dict[str, Any]:
        """Redis í—¬ìŠ¤ ì²´í¬"""
        try:
            # Redis ì—°ê²° í…ŒìŠ¤íŠ¸
            await self.redis.ping()
            
            # ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ í™•ì¸
            info = await self.redis.info('memory')
            used_memory = int(info['used_memory'])
            max_memory = int(info.get('maxmemory', 0))
            
            memory_usage_percent = (used_memory / max_memory * 100) if max_memory > 0 else 0
            
            if memory_usage_percent > 90:
                return {
                    'healthy': False,
                    'degraded': True,
                    'message': f'Redis memory usage is high: {memory_usage_percent:.1f}%'
                }
            
            return {
                'healthy': True,
                'message': 'Redis is healthy',
                'metadata': {
                    'memory_usage_percent': memory_usage_percent,
                    'used_memory': used_memory,
                    'max_memory': max_memory
                }
            }
            
        except Exception as e:
            return {
                'healthy': False,
                'message': f'Redis health check failed: {e}'
            }
    
    async def _check_exchanges(self) -> Dict[str, Any]:
        """ê±°ë˜ì†Œ í—¬ìŠ¤ ì²´í¬"""
        try:
            exchange_status = {}
            healthy_exchanges = 0
            total_exchanges = len(self.exchanges)
            
            for exchange_name, exchange in self.exchanges.items():
                try:
                    health = await exchange.health_check()
                    exchange_status[exchange_name] = health
                    
                    if health['connected']:
                        healthy_exchanges += 1
                        
                except Exception as e:
                    exchange_status[exchange_name] = {
                        'connected': False,
                        'error': str(e)
                    }
            
            health_percentage = (healthy_exchanges / total_exchanges * 100) if total_exchanges > 0 else 0
            
            if health_percentage == 100:
                return {
                    'healthy': True,
                    'message': 'All exchanges are healthy',
                    'metadata': {
                        'healthy_exchanges': healthy_exchanges,
                        'total_exchanges': total_exchanges,
                        'health_percentage': health_percentage,
                        'exchange_status': exchange_status
                    }
                }
            elif health_percentage >= 50:
                return {
                    'healthy': False,
                    'degraded': True,
                    'message': f'Some exchanges are unhealthy: {health_percentage:.1f}% healthy',
                    'metadata': {
                        'healthy_exchanges': healthy_exchanges,
                        'total_exchanges': total_exchanges,
                        'health_percentage': health_percentage,
                        'exchange_status': exchange_status
                    }
                }
            else:
                return {
                    'healthy': False,
                    'message': f'Most exchanges are unhealthy: {health_percentage:.1f}% healthy',
                    'metadata': {
                        'healthy_exchanges': healthy_exchanges,
                        'total_exchanges': total_exchanges,
                        'health_percentage': health_percentage,
                        'exchange_status': exchange_status
                    }
                }
                
        except Exception as e:
            return {
                'healthy': False,
                'message': f'Exchange health check failed: {e}'
            }
    
    async def _check_api(self) -> Dict[str, Any]:
        """API í—¬ìŠ¤ ì²´í¬"""
        try:
            # API ì—”ë“œí¬ì¸íŠ¸ í…ŒìŠ¤íŠ¸
            async with aiohttp.ClientSession() as session:
                async with session.get('http://localhost:8000/health') as response:
                    if response.status == 200:
                        data = await response.json()
                        return {
                            'healthy': True,
                            'message': 'API is healthy',
                            'metadata': data
                        }
                    else:
                        return {
                            'healthy': False,
                            'message': f'API returned status {response.status}'
                        }
                        
        except Exception as e:
            return {
                'healthy': False,
                'message': f'API health check failed: {e}'
            }
    
    async def _check_external_services(self) -> Dict[str, Any]:
        """ì™¸ë¶€ ì„œë¹„ìŠ¤ í—¬ìŠ¤ ì²´í¬"""
        try:
            external_services = {
                'binance_api': 'https://api.binance.com/api/v3/ping',
                'coinbase_api': 'https://api.exchange.coinbase.com/time'
            }
            
            service_status = {}
            healthy_services = 0
            total_services = len(external_services)
            
            async with aiohttp.ClientSession() as session:
                for service_name, url in external_services.items():
                    try:
                        async with session.get(url, timeout=5) as response:
                            if response.status == 200:
                                service_status[service_name] = {'status': 'healthy'}
                                healthy_services += 1
                            else:
                                service_status[service_name] = {
                                    'status': 'unhealthy',
                                    'error': f'HTTP {response.status}'
                                }
                    except Exception as e:
                        service_status[service_name] = {
                            'status': 'unhealthy',
                            'error': str(e)
                        }
            
            health_percentage = (healthy_services / total_services * 100) if total_services > 0 else 0
            
            return {
                'healthy': health_percentage >= 80,
                'degraded': 50 <= health_percentage < 80,
                'message': f'External services health: {health_percentage:.1f}% healthy',
                'metadata': {
                    'healthy_services': healthy_services,
                    'total_services': total_services,
                    'health_percentage': health_percentage,
                    'service_status': service_status
                }
            }
            
        except Exception as e:
            return {
                'healthy': False,
                'message': f'External services health check failed: {e}'
            }
    
    async def _detect_status_change(self, component: str, health_status: HealthStatus):
        """ìƒíƒœ ë³€ê²½ ê°ì§€"""
        try:
            previous_status = self.health_status.get(component)
            
            if previous_status and previous_status.status != health_status.status:
                # ìƒíƒœ ë³€ê²½ ì•Œë¦¼
                if self.alert_manager:
                    await self.alert_manager.send_alert(
                        alert_type='health_status_change',
                        severity='warning' if health_status.status == 'degraded' else 'critical',
                        title=f'Health Status Change: {component}',
                        message=f'{component} status changed from {previous_status.status} to {health_status.status}',
                        metadata={
                            'component': component,
                            'previous_status': previous_status.status,
                            'current_status': health_status.status,
                            'response_time': health_status.response_time,
                            'error_message': health_status.error_message
                        }
                    )
                    
        except Exception as e:
            logger.error(f"Failed to detect status change: {e}")
    
    async def _send_health_alerts(self):
        """í—¬ìŠ¤ ì•Œë¦¼ ì „ì†¡"""
        try:
            if not self.alert_manager:
                return
            
            # ì „ì²´ ì‹œìŠ¤í…œ ìƒíƒœ í™•ì¸
            unhealthy_components = [
                component for component, status in self.health_status.items()
                if status.status == 'unhealthy'
            ]
            
            degraded_components = [
                component for component, status in self.health_status.items()
                if status.status == 'degraded'
            ]
            
            if unhealthy_components:
                await self.alert_manager.send_alert(
                    alert_type='system_unhealthy',
                    severity='critical',
                    title='System Unhealthy',
                    message=f'Unhealthy components: {", ".join(unhealthy_components)}',
                    metadata={
                        'unhealthy_components': unhealthy_components,
                        'degraded_components': degraded_components
                    }
                )
            elif degraded_components:
                await self.alert_manager.send_alert(
                    alert_type='system_degraded',
                    severity='warning',
                    title='System Degraded',
                    message=f'Degraded components: {", ".join(degraded_components)}',
                    metadata={
                        'degraded_components': degraded_components
                    }
                )
                
        except Exception as e:
            logger.error(f"Failed to send health alerts: {e}")
    
    def get_health_summary(self) -> Dict[str, Any]:
        """í—¬ìŠ¤ ìƒíƒœ ìš”ì•½"""
        try:
            total_components = len(self.health_status)
            healthy_components = sum(1 for s in self.health_status.values() if s.status == 'healthy')
            degraded_components = sum(1 for s in self.health_status.values() if s.status == 'degraded')
            unhealthy_components = sum(1 for s in self.health_status.values() if s.status == 'unhealthy')
            
            return {
                'overall_status': 'healthy' if unhealthy_components == 0 else 'unhealthy',
                'total_components': total_components,
                'healthy_components': healthy_components,
                'degraded_components': degraded_components,
                'unhealthy_components': unhealthy_components,
                'health_percentage': (healthy_components / total_components * 100) if total_components > 0 else 0,
                'last_check': datetime.now().isoformat(),
                'component_status': {
                    component: {
                        'status': status.status,
                        'response_time': status.response_time,
                        'last_check': status.last_check.isoformat(),
                        'error_message': status.error_message
                    }
                    for component, status in self.health_status.items()
                }
            }
            
        except Exception as e:
            logger.error(f"Failed to get health summary: {e}")
            return {}
    
    def stop_monitoring(self):
        """í—¬ìŠ¤ ì²´í¬ ëª¨ë‹ˆí„°ë§ ì¤‘ì§€"""
        self.is_running = False
        logger.info("Stopped health monitoring")
```

## ğŸš¨ **ì•Œë¦¼ ê´€ë¦¬ ì‹œìŠ¤í…œ**

```python
# src/monitoring/core/alert_manager.py
import asyncio
from typing import Dict, List, Optional, Any
from datetime import datetime
from dataclasses import dataclass
import json

@dataclass
class Alert:
    """ì•Œë¦¼ ì •ë³´"""
    id: str
    alert_type: str
    severity: str  # 'info', 'warning', 'critical'
    title: str
    message: str
    timestamp: datetime
    metadata: Dict[str, Any] = None
    acknowledged: bool = False
    acknowledged_by: Optional[str] = None
    acknowledged_at: Optional[datetime] = None

class AlertManager:
    """ì•Œë¦¼ ê´€ë¦¬ì"""
    
    def __init__(self, notification_channels=None):
        self.notification_channels = notification_channels or []
        self.active_alerts = {}
        self.alert_history = []
        self.alert_rules = {}
        self.alert_counters = defaultdict(int)
        
        logger.info("Initialized alert manager")
    
    async def send_alert(self, alert_type: str, severity: str, title: str, 
                        message: str, metadata: Dict[str, Any] = None) -> str:
        """ì•Œë¦¼ ì „ì†¡"""
        try:
            # ì•Œë¦¼ ID ìƒì„±
            alert_id = f"{alert_type}_{datetime.now().timestamp()}"
            
            # ì•Œë¦¼ ìƒì„±
            alert = Alert(
                id=alert_id,
                alert_type=alert_type,
                severity=severity,
                title=title,
                message=message,
                timestamp=datetime.now(),
                metadata=metadata or {}
            )
            
            # ì•Œë¦¼ ê·œì¹™ í™•ì¸
            if not await self._should_send_alert(alert):
                logger.info(f"Alert suppressed by rules: {alert_id}")
                return alert_id
            
            # í™œì„± ì•Œë¦¼ì— ì¶”ê°€
            self.active_alerts[alert_id] = alert
            
            # ì•Œë¦¼ ì¹´ìš´í„° ì¦ê°€
            self.alert_counters[alert_type] += 1
            
            # ì•Œë¦¼ ì±„ë„ë¡œ ì „ì†¡
            await self._send_to_channels(alert)
            
            logger.info(f"Alert sent: {alert_id} - {severity}: {title}")
            return alert_id
            
        except Exception as e:
            logger.error(f"Failed to send alert: {e}")
            return None
    
    async def _should_send_alert(self, alert: Alert) -> bool:
        """ì•Œë¦¼ ì „ì†¡ ì—¬ë¶€ í™•ì¸"""
        try:
            # ì•Œë¦¼ ê·œì¹™ í™•ì¸
            if alert.alert_type in self.alert_rules:
                rule = self.alert_rules[alert.alert_type]
                
                # ë¹ˆë„ ì œí•œ í™•ì¸
                if 'rate_limit' in rule:
                    rate_limit = rule['rate_limit']
                    current_count = self.alert_counters[alert.alert_type]
                    
                    if current_count >= rate_limit['max_alerts']:
                        time_window = rate_limit.get('time_window', 3600)  # ê¸°ë³¸ 1ì‹œê°„
                        cutoff_time = datetime.now().timestamp() - time_window
                        
                        # ì˜¤ë˜ëœ ì•Œë¦¼ ì œê±°
                        old_alerts = [
                            aid for aid, a in self.active_alerts.items()
                            if a.alert_type == alert.alert_type and a.timestamp.timestamp() < cutoff_time
                        ]
                        
                        for old_alert_id in old_alerts:
                            del self.active_alerts[old_alert_id]
                            self.alert_counters[alert.alert_type] -= 1
                        
                        # ì—¬ì „íˆ ì œí•œì„ ì´ˆê³¼í•˜ë©´ ì•Œë¦¼ ì°¨ë‹¨
                        if self.alert_counters[alert.alert_type] >= rate_limit['max_alerts']:
                            return False
                
                # ì¤‘ë³µ ì•Œë¦¼ ë°©ì§€
                if rule.get('prevent_duplicates', False):
                    for existing_alert in self.active_alerts.values():
                        if (existing_alert.alert_type == alert.alert_type and
                            existing_alert.severity == alert.severity and
                            existing_alert.title == alert.title):
                            return False
            
            return True
            
        except Exception as e:
            logger.error(f"Failed to check alert rules: {e}")
            return True
    
    async def _send_to_channels(self, alert: Alert):
        """ì•Œë¦¼ ì±„ë„ë¡œ ì „ì†¡"""
        try:
            for channel in self.notification_channels:
                try:
                    await channel.send_alert(alert)
                except Exception as e:
                    logger.error(f"Failed to send alert to channel {channel.name}: {e}")
                    
        except Exception as e:
            logger.error(f"Failed to send alert to channels: {e}")
    
    async def acknowledge_alert(self, alert_id: str, acknowledged_by: str) -> bool:
        """ì•Œë¦¼ í™•ì¸"""
        try:
            if alert_id not in self.active_alerts:
                return False
            
            alert = self.active_alerts[alert_id]
            alert.acknowledged = True
            alert.acknowledged_by = acknowledged_by
            alert.acknowledged_at = datetime.now()
            
            logger.info(f"Alert acknowledged: {alert_id} by {acknowledged_by}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to acknowledge alert: {e}")
            return False
    
    async def resolve_alert(self, alert_id: str, resolved_by: str, resolution_notes: str = None) -> bool:
        """ì•Œë¦¼ í•´ê²°"""
        try:
            if alert_id not in self.active_alerts:
                return False
            
            alert = self.active_alerts[alert_id]
            
            # ì•Œë¦¼ íˆìŠ¤í† ë¦¬ë¡œ ì´ë™
            alert.metadata = alert.metadata or {}
            alert.metadata['resolved_by'] = resolved_by
            alert.metadata['resolved_at'] = datetime.now().isoformat()
            if resolution_notes:
                alert.metadata['resolution_notes'] = resolution_notes
            
            self.alert_history.append(alert)
            del self.active_alerts[alert_id]
            
            # ì•Œë¦¼ ì¹´ìš´í„° ê°ì†Œ
            self.alert_counters[alert.alert_type] = max(0, self.alert_counters[alert.alert_type] - 1)
            
            logger.info(f"Alert resolved: {alert_id} by {resolved_by}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to resolve alert: {e}")
            return False
    
    def add_alert_rule(self, alert_type: str, rule: Dict[str, Any]):
        """ì•Œë¦¼ ê·œì¹™ ì¶”ê°€"""
        self.alert_rules[alert_type] = rule
        logger.info(f"Added alert rule for {alert_type}")
    
    def get_active_alerts(self, severity: Optional[str] = None) -> List[Alert]:
        """í™œì„± ì•Œë¦¼ ì¡°íšŒ"""
        alerts = list(self.active_alerts.values())
        
        if severity:
            alerts = [a for a in alerts if a.severity == severity]
        
        return sorted(alerts, key=lambda x: x.timestamp, reverse=True)
    
    def get_alert_summary(self) -> Dict[str, Any]:
        """ì•Œë¦¼ ìš”ì•½"""
        try:
            total_active = len(self.active_alerts)
            total_history = len(self.alert_history)
            
            severity_counts = defaultdict(int)
            for alert in self.active_alerts.values():
                severity_counts[alert.severity] += 1
            
            return {
                'total_active_alerts': total_active,
                'total_alert_history': total_history,
                'severity_distribution': dict(severity_counts),
                'alert_type_distribution': dict(self.alert_counters),
                'last_alert': max([a.timestamp for a in self.active_alerts.values()]).isoformat() if self.active_alerts else None
            }
            
        except Exception as e:
            logger.error(f"Failed to get alert summary: {e}")
            return {}
```

## ğŸ¯ **ë‹¤ìŒ ë‹¨ê³„**

### ğŸ“‹ **ì™„ë£Œëœ ì‘ì—…**
- âœ… ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ì‹œìŠ¤í…œ
- âœ… í—¬ìŠ¤ ì²´í¬ ì‹œìŠ¤í…œ
- âœ… ì•Œë¦¼ ê´€ë¦¬ ì‹œìŠ¤í…œ
- âœ… ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§

### ğŸ”„ **ì§„í–‰ ì¤‘ì¸ ì‘ì—…**
- ğŸ”„ ëŒ€ì‹œë³´ë“œ êµ¬í˜„
- ğŸ”„ ë¦¬í¬íŒ… ì‹œìŠ¤í…œ
- ğŸ”„ ì•Œë¦¼ ì±„ë„ êµ¬í˜„

### â³ **ë‹¤ìŒ ë‹¨ê³„**
1. **Phase 1.4 ì¸í”„ë¼ í™•ì¥** ë¬¸ì„œ ìƒì„±
2. **Phase 2 ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤** ì‹œì‘
3. **ê³µí†µ ì»´í¬ë„ŒíŠ¸** ì™„ì„±

---

**ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸**: 2024-01-31
**ë‹¤ìŒ ì—…ë°ì´íŠ¸**: 2024-02-01 (Phase 1.4 ì¸í”„ë¼ í™•ì¥)
**ëª¨ë‹ˆí„°ë§ ëª©í‘œ**: ì§€ì—° < 30ì´ˆ, ì•Œë¦¼ < 10ì´ˆ
**ë°ì´í„° ìˆ˜ì§‘**: 1ì´ˆ ê°„ê²©, ì‹¤ì‹œê°„ ëŒ€ì‹œë³´ë“œ 