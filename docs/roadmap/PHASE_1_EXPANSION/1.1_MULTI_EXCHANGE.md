# 🔗 Phase 1.1: 다중 거래소 연동 시스템

## 📋 **개요**

### 🎯 **목표**
- **다중 거래소 지원**: Binance, Upbit 등 주요 거래소 통합
- **통합 API 인터페이스**: 일관된 거래소 API 추상화
- **기본 데이터 동기화**: 거래소 데이터 수집
- **수동 거래소 선택**: 사용자가 거래소 선택

### 📊 **성능 목표**
- **API 응답 시간**: < 200ms (네트워크 지연 고려)
- **데이터 동기화 지연**: < 5초
- **거래소 전환 시간**: < 10초
- **가용성**: 99% 이상

## 🏗️ **다중 거래소 아키텍처**

### 📁 **거래소 통합 구조**
```
src/exchanges/
├── base/                          # 기본 거래소 인터페이스
│   ├── __init__.py
│   ├── exchange_base.py           # 거래소 기본 클래스
│   ├── exchange_interface.py      # 거래소 인터페이스
│   └── exchange_factory.py        # 거래소 팩토리
├── binance/                       # Binance 거래소
│   ├── __init__.py
│   ├── binance_exchange.py        # Binance 구현
│   └── binance_rest.py            # Binance REST API
├── upbit/                         # Upbit 거래소
│   ├── __init__.py
│   ├── upbit_exchange.py          # Upbit 구현
│   └── upbit_rest.py              # Upbit REST API
├── aggregator/                    # 거래소 데이터 집계
│   ├── __init__.py
│   ├── price_aggregator.py        # 가격 집계
│   └── order_book_aggregator.py   # 호가창 집계
└── manager/                       # 거래소 관리자
    ├── __init__.py
    ├── exchange_manager.py        # 거래소 관리
    └── balance_manager.py         # 잔고 관리
```

## 🔧 **거래소 기본 인터페이스**

### 📦 **거래소 기본 클래스**

```python
# src/exchanges/base/exchange_base.py
from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Any
from decimal import Decimal
from datetime import datetime
from dataclasses import dataclass
import asyncio
import logging

logger = logging.getLogger(__name__)

@dataclass
class Ticker:
    """시장 데이터"""
    symbol: str
    last_price: Decimal
    bid: Decimal
    ask: Decimal
    volume: Decimal
    timestamp: datetime
    exchange: str

@dataclass
class OrderBook:
    """호가창 데이터"""
    symbol: str
    bids: List[Dict[str, Decimal]]  # [price, quantity]
    asks: List[Dict[str, Decimal]]  # [price, quantity]
    timestamp: datetime
    exchange: str

@dataclass
class Trade:
    """거래 내역"""
    id: str
    symbol: str
    price: Decimal
    quantity: Decimal
    side: str  # 'buy' or 'sell'
    timestamp: datetime
    exchange: str

@dataclass
class Balance:
    """잔고 정보"""
    asset: str
    free: Decimal
    locked: Decimal
    total: Decimal
    exchange: str

class ExchangeBase(ABC):
    """거래소 기본 클래스"""
    
    def __init__(self, api_key: str, api_secret: str, testnet: bool = True):
        self.api_key = api_key
        self.api_secret = api_secret
        self.testnet = testnet
        self.name = self.__class__.__name__
        self.rate_limit_delay = 0.1  # 100ms (API 제한 고려)
    
    @abstractmethod
    async def get_ticker(self, symbol: str) -> Optional[Ticker]:
        """시세 조회"""
        pass
    
    @abstractmethod
    async def get_order_book(self, symbol: str, limit: int = 20) -> Optional[OrderBook]:
        """호가창 조회"""
        pass
    
    @abstractmethod
    async def place_order(self, order_data: Dict[str, Any]) -> Dict[str, Any]:
        """주문 실행"""
        pass
    
    @abstractmethod
    async def cancel_order(self, order_id: str, symbol: str) -> bool:
        """주문 취소"""
        pass
    
    @abstractmethod
    async def get_balance(self, asset: str = None) -> List[Balance]:
        """잔고 조회"""
        pass
    
    @abstractmethod
    async def get_order_status(self, order_id: str, symbol: str) -> Dict[str, Any]:
        """주문 상태 조회"""
        pass
    
    async def _rate_limit(self):
        """API 레이트 리밋 준수"""
        await asyncio.sleep(self.rate_limit_delay)
    
    def _log_error(self, method: str, error: Exception):
        """에러 로깅"""
        logger.error(f"{self.name} {method} 실패: {error}")
    
    def _log_info(self, method: str, message: str):
        """정보 로깅"""
        logger.info(f"{self.name} {method}: {message}")
```

## 🔗 **1.1.1 Binance 연동**

### 📦 **Binance 거래소 구현**

```python
# src/exchanges/binance/binance_exchange.py
import aiohttp
import hmac
import hashlib
import time
from typing import Dict, List, Optional, Any
from decimal import Decimal
from datetime import datetime, timezone

from ..base.exchange_base import ExchangeBase, Ticker, OrderBook, Balance

logger = logging.getLogger(__name__)

class BinanceExchange(ExchangeBase):
    """Binance 거래소 구현"""
    
    def __init__(self, api_key: str, api_secret: str, testnet: bool = True):
        super().__init__(api_key, api_secret, testnet)
        self.base_url = "https://testnet.binance.vision" if testnet else "https://api.binance.com"
        self.session = None
    
    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
    
    async def get_ticker(self, symbol: str) -> Optional[Ticker]:
        """시세 조회"""
        try:
            await self._rate_limit()
            
            params = {'symbol': symbol}
            async with self.session.get(f"{self.base_url}/api/v3/ticker/24hr", params=params) as response:
                if response.status == 200:
                    data = await response.json()
                    
                    return Ticker(
                        symbol=data['symbol'],
                        last_price=Decimal(data['lastPrice']),
                        bid=Decimal(data['bidPrice']),
                        ask=Decimal(data['askPrice']),
                        volume=Decimal(data['volume']),
                        timestamp=datetime.now(timezone.utc),
                        exchange='binance'
                    )
                else:
                    self._log_error('get_ticker', Exception(f"HTTP {response.status}"))
                    return None
                    
        except Exception as e:
            self._log_error('get_ticker', e)
            return None
    
    async def get_order_book(self, symbol: str, limit: int = 20) -> Optional[OrderBook]:
        """호가창 조회"""
        try:
            await self._rate_limit()
            
            params = {'symbol': symbol, 'limit': limit}
            async with self.session.get(f"{self.base_url}/api/v3/depth", params=params) as response:
                if response.status == 200:
                    data = await response.json()
                    
                    bids = [{'price': Decimal(price), 'quantity': Decimal(qty)} 
                           for price, qty in data['bids'][:limit]]
                    asks = [{'price': Decimal(price), 'quantity': Decimal(qty)} 
                           for price, qty in data['asks'][:limit]]
                    
                    return OrderBook(
                        symbol=symbol,
                        bids=bids,
                        asks=asks,
                        timestamp=datetime.now(timezone.utc),
                        exchange='binance'
                    )
                else:
                    self._log_error('get_order_book', Exception(f"HTTP {response.status}"))
                    return None
                    
        except Exception as e:
            self._log_error('get_order_book', e)
            return None
    
    async def place_order(self, order_data: Dict[str, Any]) -> Dict[str, Any]:
        """주문 실행"""
        try:
            await self._rate_limit()
            
            params = {
                'symbol': order_data['symbol'],
                'side': order_data['side'],
                'type': order_data['order_type'],
                'quantity': str(order_data['quantity'])
            }
            
            if order_data.get('price'):
                params['price'] = str(order_data['price'])
            if order_data.get('stopPrice'):
                params['stopPrice'] = str(order_data['stopPrice'])
            
            # 서명 생성
            signature = self._create_signature(params)
            params['signature'] = signature
            
            headers = {'X-MBX-APIKEY': self.api_key}
            
            async with self.session.post(
                f"{self.base_url}/api/v3/order",
                params=params,
                headers=headers
            ) as response:
                result = await response.json()
                
                if response.status == 200:
                    self._log_info('place_order', f"주문 성공: {result.get('orderId')}")
                    return {'success': True, 'data': result}
                else:
                    self._log_error('place_order', Exception(result.get('msg', 'Unknown error')))
                    return {'success': False, 'error': result.get('msg', 'Unknown error')}
                    
        except Exception as e:
            self._log_error('place_order', e)
            return {'success': False, 'error': str(e)}
    
    async def cancel_order(self, order_id: str, symbol: str) -> bool:
        """주문 취소"""
        try:
            await self._rate_limit()
            
            params = {
                'symbol': symbol,
                'orderId': order_id
            }
            
            signature = self._create_signature(params)
            params['signature'] = signature
            
            headers = {'X-MBX-APIKEY': self.api_key}
            
            async with self.session.delete(
                f"{self.base_url}/api/v3/order",
                params=params,
                headers=headers
            ) as response:
                result = await response.json()
                
                if response.status == 200:
                    self._log_info('cancel_order', f"주문 취소 성공: {order_id}")
                    return True
                else:
                    self._log_error('cancel_order', Exception(result.get('msg', 'Unknown error')))
                    return False
                    
        except Exception as e:
            self._log_error('cancel_order', e)
            return False
    
    async def get_balance(self, asset: str = None) -> List[Balance]:
        """잔고 조회"""
        try:
            await self._rate_limit()
            
            params = {}
            signature = self._create_signature(params)
            params['signature'] = signature
            
            headers = {'X-MBX-APIKEY': self.api_key}
            
            async with self.session.get(
                f"{self.base_url}/api/v3/account",
                params=params,
                headers=headers
            ) as response:
                if response.status == 200:
                    data = await response.json()
                    balances = []
                    
                    for balance_data in data.get('balances', []):
                        if asset and balance_data['asset'] != asset:
                            continue
                        
                        if Decimal(balance_data['free']) > 0 or Decimal(balance_data['locked']) > 0:
                            balances.append(Balance(
                                asset=balance_data['asset'],
                                free=Decimal(balance_data['free']),
                                locked=Decimal(balance_data['locked']),
                                total=Decimal(balance_data['free']) + Decimal(balance_data['locked']),
                                exchange='binance'
                            ))
                    
                    return balances
                else:
                    self._log_error('get_balance', Exception(f"HTTP {response.status}"))
                    return []
                    
        except Exception as e:
            self._log_error('get_balance', e)
            return []
    
    async def get_order_status(self, order_id: str, symbol: str) -> Dict[str, Any]:
        """주문 상태 조회"""
        try:
            await self._rate_limit()
            
            params = {
                'symbol': symbol,
                'orderId': order_id
            }
            
            signature = self._create_signature(params)
            params['signature'] = signature
            
            headers = {'X-MBX-APIKEY': self.api_key}
            
            async with self.session.get(
                f"{self.base_url}/api/v3/order",
                params=params,
                headers=headers
            ) as response:
                if response.status == 200:
                    return await response.json()
                else:
                    self._log_error('get_order_status', Exception(f"HTTP {response.status}"))
                    return {}
                    
        except Exception as e:
            self._log_error('get_order_status', e)
            return {}
    
    def _create_signature(self, params: Dict[str, Any]) -> str:
        """API 서명 생성"""
        query_string = '&'.join([f"{k}={v}" for k, v in params.items()])
        return hmac.new(
            self.api_secret.encode('utf-8'),
            query_string.encode('utf-8'),
            hashlib.sha256
        ).hexdigest()
```

## 🔗 **1.1.2 Upbit 연동**

### 📦 **Upbit 거래소 구현**

```python
# src/exchanges/upbit/upbit_exchange.py
import aiohttp
import jwt
import uuid
import hashlib
from typing import Dict, List, Optional, Any
from decimal import Decimal
from datetime import datetime, timezone

from ..base.exchange_base import ExchangeBase, Ticker, OrderBook, Balance

logger = logging.getLogger(__name__)

class UpbitExchange(ExchangeBase):
    """Upbit 거래소 구현"""
    
    def __init__(self, api_key: str, api_secret: str, testnet: bool = True):
        super().__init__(api_key, api_secret, testnet)
        self.base_url = "https://api.upbit.com/v1"
        self.session = None
    
    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
    
    async def get_ticker(self, symbol: str) -> Optional[Ticker]:
        """시세 조회"""
        try:
            await self._rate_limit()
            
            # Upbit는 KRW-BTC 형식 사용
            if not symbol.startswith('KRW-'):
                symbol = f"KRW-{symbol}"
            
            params = {'markets': symbol}
            async with self.session.get(f"{self.base_url}/ticker", params=params) as response:
                if response.status == 200:
                    data = await response.json()
                    if data:
                        ticker_data = data[0]
                        
                        return Ticker(
                            symbol=ticker_data['market'],
                            last_price=Decimal(str(ticker_data['trade_price'])),
                            bid=Decimal(str(ticker_data['highest_bid_price'])),
                            ask=Decimal(str(ticker_data['lowest_ask_price'])),
                            volume=Decimal(str(ticker_data['acc_trade_volume_24h'])),
                            timestamp=datetime.now(timezone.utc),
                            exchange='upbit'
                        )
                else:
                    self._log_error('get_ticker', Exception(f"HTTP {response.status}"))
                    return None
                    
        except Exception as e:
            self._log_error('get_ticker', e)
            return None
    
    async def get_order_book(self, symbol: str, limit: int = 20) -> Optional[OrderBook]:
        """호가창 조회"""
        try:
            await self._rate_limit()
            
            # Upbit는 KRW-BTC 형식 사용
            if not symbol.startswith('KRW-'):
                symbol = f"KRW-{symbol}"
            
            params = {'markets': symbol}
            async with self.session.get(f"{self.base_url}/orderbook", params=params) as response:
                if response.status == 200:
                    data = await response.json()
                    if data:
                        orderbook_data = data[0]
                        
                        bids = [{'price': Decimal(str(bid['price'])), 'quantity': Decimal(str(bid['size']))} 
                               for bid in orderbook_data['orderbook_units'][:limit]]
                        asks = [{'price': Decimal(str(ask['price'])), 'quantity': Decimal(str(ask['size']))} 
                               for ask in orderbook_data['orderbook_units'][:limit]]
                        
                        return OrderBook(
                            symbol=symbol,
                            bids=bids,
                            asks=asks,
                            timestamp=datetime.now(timezone.utc),
                            exchange='upbit'
                        )
                else:
                    self._log_error('get_order_book', Exception(f"HTTP {response.status}"))
                    return None
                    
        except Exception as e:
            self._log_error('get_order_book', e)
            return None
    
    async def place_order(self, order_data: Dict[str, Any]) -> Dict[str, Any]:
        """주문 실행"""
        try:
            await self._rate_limit()
            
            # Upbit는 KRW-BTC 형식 사용
            market = order_data['symbol']
            if not market.startswith('KRW-'):
                market = f"KRW-{market}"
            
            payload = {
                'market': market,
                'side': order_data['side'].lower(),
                'ord_type': order_data['order_type'].lower(),
                'volume': str(order_data['quantity'])
            }
            
            if order_data.get('price'):
                payload['price'] = str(order_data['price'])
            
            # JWT 토큰 생성
            token = self._create_jwt_token(payload)
            headers = {'Authorization': f'Bearer {token}'}
            
            async with self.session.post(
                f"{self.base_url}/orders",
                json=payload,
                headers=headers
            ) as response:
                result = await response.json()
                
                if response.status == 201:
                    self._log_info('place_order', f"주문 성공: {result.get('uuid')}")
                    return {'success': True, 'data': result}
                else:
                    self._log_error('place_order', Exception(result.get('error', {}).get('message', 'Unknown error')))
                    return {'success': False, 'error': result.get('error', {}).get('message', 'Unknown error')}
                    
        except Exception as e:
            self._log_error('place_order', e)
            return {'success': False, 'error': str(e)}
    
    async def cancel_order(self, order_id: str, symbol: str) -> bool:
        """주문 취소"""
        try:
            await self._rate_limit()
            
            payload = {'uuid': order_id}
            
            # JWT 토큰 생성
            token = self._create_jwt_token(payload)
            headers = {'Authorization': f'Bearer {token}'}
            
            async with self.session.delete(
                f"{self.base_url}/order",
                json=payload,
                headers=headers
            ) as response:
                result = await response.json()
                
                if response.status == 200:
                    self._log_info('cancel_order', f"주문 취소 성공: {order_id}")
                    return True
                else:
                    self._log_error('cancel_order', Exception(result.get('error', {}).get('message', 'Unknown error')))
                    return False
                    
        except Exception as e:
            self._log_error('cancel_order', e)
            return False
    
    async def get_balance(self, asset: str = None) -> List[Balance]:
        """잔고 조회"""
        try:
            await self._rate_limit()
            
            # JWT 토큰 생성
            token = self._create_jwt_token({})
            headers = {'Authorization': f'Bearer {token}'}
            
            async with self.session.get(
                f"{self.base_url}/accounts",
                headers=headers
            ) as response:
                if response.status == 200:
                    data = await response.json()
                    balances = []
                    
                    for balance_data in data:
                        if asset and balance_data['currency'] != asset:
                            continue
                        
                        if Decimal(balance_data['balance']) > 0 or Decimal(balance_data['locked']) > 0:
                            balances.append(Balance(
                                asset=balance_data['currency'],
                                free=Decimal(balance_data['balance']),
                                locked=Decimal(balance_data['locked']),
                                total=Decimal(balance_data['balance']) + Decimal(balance_data['locked']),
                                exchange='upbit'
                            ))
                    
                    return balances
                else:
                    self._log_error('get_balance', Exception(f"HTTP {response.status}"))
                    return []
                    
        except Exception as e:
            self._log_error('get_balance', e)
            return []
    
    async def get_order_status(self, order_id: str, symbol: str) -> Dict[str, Any]:
        """주문 상태 조회"""
        try:
            await self._rate_limit()
            
            params = {'uuid': order_id}
            
            # JWT 토큰 생성
            token = self._create_jwt_token(params)
            headers = {'Authorization': f'Bearer {token}'}
            
            async with self.session.get(
                f"{self.base_url}/order",
                params=params,
                headers=headers
            ) as response:
                if response.status == 200:
                    return await response.json()
                else:
                    self._log_error('get_order_status', Exception(f"HTTP {response.status}"))
                    return {}
                    
        except Exception as e:
            self._log_error('get_order_status', e)
            return {}
    
    def _create_jwt_token(self, payload: Dict[str, Any]) -> str:
        """JWT 토큰 생성"""
        import jwt
        
        payload['access_key'] = self.api_key
        payload['nonce'] = str(uuid.uuid4())
        
        return jwt.encode(payload, self.api_secret, algorithm='HS256')
```

## 🔗 **1.1.3 통합 거래소 관리**

### 📦 **거래소 관리자 구현**

```python
# src/exchanges/manager/exchange_manager.py
import asyncio
import logging
from typing import Dict, List, Optional, Any
from decimal import Decimal
from datetime import datetime

from ..base.exchange_base import ExchangeBase, Ticker, OrderBook, Balance
from ..binance.binance_exchange import BinanceExchange
from ..upbit.upbit_exchange import UpbitExchange

logger = logging.getLogger(__name__)

class ExchangeManager:
    """거래소 관리자"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.exchanges: Dict[str, ExchangeBase] = {}
        self.active_exchange = None
        self._init_exchanges()
    
    def _init_exchanges(self):
        """거래소 초기화"""
        try:
            # Binance 초기화
            if 'binance' in self.config:
                binance_config = self.config['binance']
                self.exchanges['binance'] = BinanceExchange(
                    api_key=binance_config['api_key'],
                    api_secret=binance_config['api_secret'],
                    testnet=binance_config.get('testnet', True)
                )
            
            # Upbit 초기화
            if 'upbit' in self.config:
                upbit_config = self.config['upbit']
                self.exchanges['upbit'] = UpbitExchange(
                    api_key=upbit_config['api_key'],
                    api_secret=upbit_config['api_secret'],
                    testnet=upbit_config.get('testnet', True)
                )
            
            # 기본 거래소 설정
            self.active_exchange = self.config.get('default_exchange', 'binance')
            
            logger.info(f"거래소 초기화 완료: {list(self.exchanges.keys())}")
            
        except Exception as e:
            logger.error(f"거래소 초기화 실패: {e}")
    
    def get_exchange(self, exchange_name: str = None) -> Optional[ExchangeBase]:
        """거래소 조회"""
        exchange_name = exchange_name or self.active_exchange
        return self.exchanges.get(exchange_name)
    
    def set_active_exchange(self, exchange_name: str) -> bool:
        """활성 거래소 설정"""
        if exchange_name in self.exchanges:
            self.active_exchange = exchange_name
            logger.info(f"활성 거래소 변경: {exchange_name}")
            return True
        else:
            logger.error(f"거래소를 찾을 수 없음: {exchange_name}")
            return False
    
    async def get_ticker(self, symbol: str, exchange_name: str = None) -> Optional[Ticker]:
        """시세 조회"""
        exchange = self.get_exchange(exchange_name)
        if not exchange:
            return None
        
        async with exchange:
            return await exchange.get_ticker(symbol)
    
    async def get_order_book(self, symbol: str, exchange_name: str = None, limit: int = 20) -> Optional[OrderBook]:
        """호가창 조회"""
        exchange = self.get_exchange(exchange_name)
        if not exchange:
            return None
        
        async with exchange:
            return await exchange.get_order_book(symbol, limit)
    
    async def place_order(self, order_data: Dict[str, Any], exchange_name: str = None) -> Dict[str, Any]:
        """주문 실행"""
        exchange = self.get_exchange(exchange_name)
        if not exchange:
            return {'success': False, 'error': '거래소를 찾을 수 없음'}
        
        async with exchange:
            return await exchange.place_order(order_data)
    
    async def cancel_order(self, order_id: str, symbol: str, exchange_name: str = None) -> bool:
        """주문 취소"""
        exchange = self.get_exchange(exchange_name)
        if not exchange:
            return False
        
        async with exchange:
            return await exchange.cancel_order(order_id, symbol)
    
    async def get_balance(self, asset: str = None, exchange_name: str = None) -> List[Balance]:
        """잔고 조회"""
        exchange = self.get_exchange(exchange_name)
        if not exchange:
            return []
        
        async with exchange:
            return await exchange.get_balance(asset)
    
    async def get_all_balances(self) -> Dict[str, List[Balance]]:
        """모든 거래소 잔고 조회"""
        all_balances = {}
        
        for exchange_name, exchange in self.exchanges.items():
            try:
                async with exchange:
                    balances = await exchange.get_balance()
                    all_balances[exchange_name] = balances
            except Exception as e:
                logger.error(f"{exchange_name} 잔고 조회 실패: {e}")
                all_balances[exchange_name] = []
        
        return all_balances
    
    async def compare_prices(self, symbol: str) -> Dict[str, Any]:
        """거래소별 가격 비교"""
        prices = {}
        
        for exchange_name, exchange in self.exchanges.items():
            try:
                async with exchange:
                    ticker = await exchange.get_ticker(symbol)
                    if ticker:
                        prices[exchange_name] = {
                            'last_price': ticker.last_price,
                            'bid': ticker.bid,
                            'ask': ticker.ask,
                            'spread': ticker.ask - ticker.bid,
                            'timestamp': ticker.timestamp
                        }
            except Exception as e:
                logger.error(f"{exchange_name} 가격 조회 실패: {e}")
        
        return prices
    
    def get_exchange_info(self) -> Dict[str, Any]:
        """거래소 정보 조회"""
        info = {
            'available_exchanges': list(self.exchanges.keys()),
            'active_exchange': self.active_exchange,
            'exchange_count': len(self.exchanges)
        }
        
        return info
```

### 📦 **거래소 팩토리 구현**

```python
# src/exchanges/base/exchange_factory.py
from typing import Dict, Any, Optional
from .exchange_base import ExchangeBase
from ..binance.binance_exchange import BinanceExchange
from ..upbit.upbit_exchange import UpbitExchange

class ExchangeFactory:
    """거래소 팩토리"""
    
    @staticmethod
    def create_exchange(exchange_type: str, config: Dict[str, Any]) -> Optional[ExchangeBase]:
        """거래소 생성"""
        try:
            if exchange_type.lower() == 'binance':
                return BinanceExchange(
                    api_key=config['api_key'],
                    api_secret=config['api_secret'],
                    testnet=config.get('testnet', True)
                )
            elif exchange_type.lower() == 'upbit':
                return UpbitExchange(
                    api_key=config['api_key'],
                    api_secret=config['api_secret'],
                    testnet=config.get('testnet', True)
                )
            else:
                raise ValueError(f"지원하지 않는 거래소: {exchange_type}")
                
        except Exception as e:
            logger.error(f"거래소 생성 실패: {e}")
            return None
    
    @staticmethod
    def get_supported_exchanges() -> List[str]:
        """지원하는 거래소 목록"""
        return ['binance', 'upbit']
```

## 📊 **성능 최적화**

### 🎯 **현실적 성능 목표**
- **API 응답 시간**: < 200ms (네트워크 지연 고려)
- **거래소 전환 시간**: < 10초
- **동시 거래소 처리**: 2개 거래소
- **메모리 사용량**: < 500MB

### 🔧 **최적화 전략**
1. **API 레이트 리밋 준수**: 100ms 지연 추가
2. **비동기 처리**: asyncio 활용
3. **연결 풀링**: aiohttp 세션 재사용
4. **에러 처리**: 견고한 예외 처리

## 🔒 **보안 고려사항**

### 🛡️ **기본 보안 요구사항**
1. **API 키 관리**: 환경 변수 사용
2. **서명 검증**: 모든 API 요청 서명
3. **로깅**: 민감한 정보 마스킹
4. **에러 처리**: 민감한 정보 노출 방지

## 📋 **테스트 계획**

### 🧪 **단위 테스트**
- 거래소별 API 연동 테스트
- 거래소 관리자 기능 테스트
- 에러 처리 테스트

### 🔗 **통합 테스트**
- 다중 거래소 연동 테스트
- 거래소 전환 테스트
- 잔고 동기화 테스트

### ⚡ **성능 테스트**
- API 응답 시간 테스트
- 동시 요청 처리 테스트
- 메모리 사용량 테스트

---

**Phase 1.1 완료 기준**: Binance, Upbit 연동 완료, 통합 거래소 관리 시스템 구축 