# âš–ï¸ Phase 2.3: ë¡œë“œ ë°¸ëŸ°ì‹± ë° íŠ¸ë˜í”½ ë¶„ì‚°

## ğŸ“‹ **ê°œìš”**

### ğŸ¯ **ëª©í‘œ**
- **íŠ¸ë˜í”½ ë¶„ì‚°**: ì„œë¹„ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ ê°„ ë¶€í•˜ ê· ë“± ë¶„ì‚°
- **ê³ ê°€ìš©ì„±**: ì„œë¹„ìŠ¤ ì¥ì•  ì‹œ ìë™ ì¥ì•  ì¡°ì¹˜
- **ì„±ëŠ¥ ìµœì í™”**: ì‘ë‹µ ì‹œê°„ ë° ì²˜ë¦¬ëŸ‰ ìµœì í™”
- **í™•ì¥ì„±**: ë™ì  ìŠ¤ì¼€ì¼ë§ ì§€ì›

### ğŸ“Š **ì„±ëŠ¥ ëª©í‘œ**
- **ì‘ë‹µ ì‹œê°„**: < 50ms (95th percentile)
- **ì²˜ë¦¬ëŸ‰**: 10,000 RPS (ìš”ì²­/ì´ˆ)
- **ê°€ìš©ì„±**: 99.99% (ì—°ê°„ ë‹¤ìš´íƒ€ì„ < 1ì‹œê°„)
- **ì¥ì•  ë³µêµ¬**: < 10ì´ˆ (ìë™ ì¥ì•  ì¡°ì¹˜)

## ğŸ—ï¸ **ë¡œë“œ ë°¸ëŸ°ì‹± ì•„í‚¤í…ì²˜**

### ğŸ“ **ë¡œë“œ ë°¸ëŸ°ì‹± êµ¬ì¡°**
```
load-balancing/
â”œâ”€â”€ algorithms/                    # ë¡œë“œ ë°¸ëŸ°ì‹± ì•Œê³ ë¦¬ì¦˜
â”‚   â”œâ”€â”€ round-robin/              # ë¼ìš´ë“œ ë¡œë¹ˆ
â”‚   â”œâ”€â”€ least-connections/        # ìµœì†Œ ì—°ê²°
â”‚   â”œâ”€â”€ weighted/                 # ê°€ì¤‘ì¹˜ ê¸°ë°˜
â”‚   â”œâ”€â”€ ip-hash/                  # IP í•´ì‹œ
â”‚   â””â”€â”€ least-response-time/      # ìµœì†Œ ì‘ë‹µ ì‹œê°„
â”œâ”€â”€ health-checking/              # í—¬ìŠ¤ ì²´í¬
â”‚   â”œâ”€â”€ active/                   # ëŠ¥ë™ì  í—¬ìŠ¤ ì²´í¬
â”‚   â”œâ”€â”€ passive/                  # ìˆ˜ë™ì  í—¬ìŠ¤ ì²´í¬
â”‚   â””â”€â”€ custom/                   # ì»¤ìŠ¤í…€ í—¬ìŠ¤ ì²´í¬
â”œâ”€â”€ session-management/           # ì„¸ì…˜ ê´€ë¦¬
â”‚   â”œâ”€â”€ sticky-sessions/          # ìŠ¤í‹°í‚¤ ì„¸ì…˜
â”‚   â”œâ”€â”€ session-replication/      # ì„¸ì…˜ ë³µì œ
â”‚   â””â”€â”€ distributed-sessions/     # ë¶„ì‚° ì„¸ì…˜
â””â”€â”€ monitoring/                   # ëª¨ë‹ˆí„°ë§
    â”œâ”€â”€ metrics/                  # ë©”íŠ¸ë¦­ ìˆ˜ì§‘
    â”œâ”€â”€ alerts/                   # ì•Œë¦¼ ì‹œìŠ¤í…œ
    â””â”€â”€ dashboard/                # ëŒ€ì‹œë³´ë“œ
```

## ğŸ”§ **ë¡œë“œ ë°¸ëŸ°ì‹± ì•Œê³ ë¦¬ì¦˜**

### ğŸ“¦ **ë¼ìš´ë“œ ë¡œë¹ˆ ë¡œë“œ ë°¸ëŸ°ì„œ**

```python
# load-balancing/algorithms/round-robin/round_robin_balancer.py
import asyncio
import threading
from typing import List, Dict, Any, Optional
from dataclasses import dataclass
from datetime import datetime, timedelta
import logging

logger = logging.getLogger(__name__)

@dataclass
class BackendServer:
    """ë°±ì—”ë“œ ì„œë²„"""
    id: str
    address: str
    port: int
    weight: int = 1
    is_healthy: bool = True
    active_connections: int = 0
    response_time: float = 0.0
    last_health_check: Optional[datetime] = None

class RoundRobinLoadBalancer:
    """ë¼ìš´ë“œ ë¡œë¹ˆ ë¡œë“œ ë°¸ëŸ°ì„œ"""
    
    def __init__(self):
        self.backends: List[BackendServer] = []
        self.current_index = 0
        self.lock = threading.Lock()
        self.health_check_interval = 10  # 10ì´ˆ
        self.connection_timeout = 30  # 30ì´ˆ
        
        logger.info("Initialized round-robin load balancer")
    
    def add_backend(self, server_id: str, address: str, port: int, weight: int = 1):
        """ë°±ì—”ë“œ ì„œë²„ ì¶”ê°€"""
        with self.lock:
            backend = BackendServer(
                id=server_id,
                address=address,
                port=port,
                weight=weight
            )
            self.backends.append(backend)
            logger.info(f"Added backend server: {server_id} ({address}:{port})")
    
    def remove_backend(self, server_id: str):
        """ë°±ì—”ë“œ ì„œë²„ ì œê±°"""
        with self.lock:
            self.backends = [b for b in self.backends if b.id != server_id]
            logger.info(f"Removed backend server: {server_id}")
    
    def get_next_backend(self) -> Optional[BackendServer]:
        """ë‹¤ìŒ ë°±ì—”ë“œ ì„œë²„ ì„ íƒ"""
        with self.lock:
            if not self.backends:
                return None
            
            # ê±´ê°•í•œ ì„œë²„ë§Œ í•„í„°ë§
            healthy_backends = [b for b in self.backends if b.is_healthy]
            
            if not healthy_backends:
                logger.warning("No healthy backend servers available")
                return None
            
            # ë¼ìš´ë“œ ë¡œë¹ˆ ì„ íƒ
            selected_backend = healthy_backends[self.current_index % len(healthy_backends)]
            self.current_index += 1
            
            # ì—°ê²° ìˆ˜ ì¦ê°€
            selected_backend.active_connections += 1
            
            logger.debug(f"Selected backend: {selected_backend.id} (connections: {selected_backend.active_connections})")
            return selected_backend
    
    def release_connection(self, server_id: str):
        """ì—°ê²° í•´ì œ"""
        with self.lock:
            for backend in self.backends:
                if backend.id == server_id:
                    backend.active_connections = max(0, backend.active_connections - 1)
                    logger.debug(f"Released connection from {server_id} (connections: {backend.active_connections})")
                    break
    
    def update_server_health(self, server_id: str, is_healthy: bool, response_time: float = 0.0):
        """ì„œë²„ í—¬ìŠ¤ ìƒíƒœ ì—…ë°ì´íŠ¸"""
        with self.lock:
            for backend in self.backends:
                if backend.id == server_id:
                    backend.is_healthy = is_healthy
                    backend.response_time = response_time
                    backend.last_health_check = datetime.now()
                    
                    if not is_healthy:
                        logger.warning(f"Backend server {server_id} is unhealthy")
                    else:
                        logger.debug(f"Backend server {server_id} is healthy (response time: {response_time}ms)")
                    break
    
    def get_backend_stats(self) -> Dict[str, Any]:
        """ë°±ì—”ë“œ í†µê³„ ì¡°íšŒ"""
        with self.lock:
            total_backends = len(self.backends)
            healthy_backends = len([b for b in self.backends if b.is_healthy])
            total_connections = sum(b.active_connections for b in self.backends)
            
            return {
                "total_backends": total_backends,
                "healthy_backends": healthy_backends,
                "unhealthy_backends": total_backends - healthy_backends,
                "total_connections": total_connections,
                "backends": [
                    {
                        "id": b.id,
                        "address": b.address,
                        "port": b.port,
                        "weight": b.weight,
                        "is_healthy": b.is_healthy,
                        "active_connections": b.active_connections,
                        "response_time": b.response_time,
                        "last_health_check": b.last_health_check.isoformat() if b.last_health_check else None
                    }
                    for b in self.backends
                ]
            }
    
    async def start_health_check_loop(self):
        """í—¬ìŠ¤ ì²´í¬ ë£¨í”„ ì‹œì‘"""
        while True:
            try:
                for backend in self.backends:
                    await self._check_backend_health(backend)
                
                await asyncio.sleep(self.health_check_interval)
                
            except Exception as e:
                logger.error(f"Health check loop error: {e}")
                await asyncio.sleep(self.health_check_interval)
    
    async def _check_backend_health(self, backend: BackendServer):
        """ë°±ì—”ë“œ í—¬ìŠ¤ ì²´í¬"""
        try:
            start_time = datetime.now()
            
            # HTTP í—¬ìŠ¤ ì²´í¬
            health_url = f"http://{backend.address}:{backend.port}/health"
            
            async with aiohttp.ClientSession() as session:
                async with session.get(health_url, timeout=5) as response:
                    response_time = (datetime.now() - start_time).total_seconds() * 1000
                    
                    if response.status == 200:
                        self.update_server_health(backend.id, True, response_time)
                    else:
                        self.update_server_health(backend.id, False, response_time)
                        
        except Exception as e:
            logger.error(f"Health check failed for {backend.id}: {e}")
            self.update_server_health(backend.id, False, 0.0)
```

### ğŸ“¦ **ìµœì†Œ ì—°ê²° ë¡œë“œ ë°¸ëŸ°ì„œ**

```python
# load-balancing/algorithms/least-connections/least_connections_balancer.py
import asyncio
import threading
from typing import List, Dict, Any, Optional
from dataclasses import dataclass
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

class LeastConnectionsLoadBalancer:
    """ìµœì†Œ ì—°ê²° ë¡œë“œ ë°¸ëŸ°ì„œ"""
    
    def __init__(self):
        self.backends: List[BackendServer] = []
        self.lock = threading.Lock()
        self.health_check_interval = 10  # 10ì´ˆ
        
        logger.info("Initialized least-connections load balancer")
    
    def add_backend(self, server_id: str, address: str, port: int, weight: int = 1):
        """ë°±ì—”ë“œ ì„œë²„ ì¶”ê°€"""
        with self.lock:
            backend = BackendServer(
                id=server_id,
                address=address,
                port=port,
                weight=weight
            )
            self.backends.append(backend)
            logger.info(f"Added backend server: {server_id} ({address}:{port})")
    
    def remove_backend(self, server_id: str):
        """ë°±ì—”ë“œ ì„œë²„ ì œê±°"""
        with self.lock:
            self.backends = [b for b in self.backends if b.id != server_id]
            logger.info(f"Removed backend server: {server_id}")
    
    def get_next_backend(self) -> Optional[BackendServer]:
        """ë‹¤ìŒ ë°±ì—”ë“œ ì„œë²„ ì„ íƒ (ìµœì†Œ ì—°ê²°)"""
        with self.lock:
            if not self.backends:
                return None
            
            # ê±´ê°•í•œ ì„œë²„ë§Œ í•„í„°ë§
            healthy_backends = [b for b in self.backends if b.is_healthy]
            
            if not healthy_backends:
                logger.warning("No healthy backend servers available")
                return None
            
            # ìµœì†Œ ì—°ê²° ìˆ˜ë¥¼ ê°€ì§„ ì„œë²„ ì„ íƒ
            selected_backend = min(healthy_backends, key=lambda b: b.active_connections)
            
            # ì—°ê²° ìˆ˜ ì¦ê°€
            selected_backend.active_connections += 1
            
            logger.debug(f"Selected backend: {selected_backend.id} (connections: {selected_backend.active_connections})")
            return selected_backend
    
    def release_connection(self, server_id: str):
        """ì—°ê²° í•´ì œ"""
        with self.lock:
            for backend in self.backends:
                if backend.id == server_id:
                    backend.active_connections = max(0, backend.active_connections - 1)
                    logger.debug(f"Released connection from {server_id} (connections: {backend.active_connections})")
                    break
    
    def get_backend_stats(self) -> Dict[str, Any]:
        """ë°±ì—”ë“œ í†µê³„ ì¡°íšŒ"""
        with self.lock:
            total_backends = len(self.backends)
            healthy_backends = len([b for b in self.backends if b.is_healthy])
            total_connections = sum(b.active_connections for b in self.backends)
            
            # ì—°ê²° ìˆ˜ë³„ ì •ë ¬
            sorted_backends = sorted(self.backends, key=lambda b: b.active_connections)
            
            return {
                "total_backends": total_backends,
                "healthy_backends": healthy_backends,
                "unhealthy_backends": total_backends - healthy_backends,
                "total_connections": total_connections,
                "backends": [
                    {
                        "id": b.id,
                        "address": b.address,
                        "port": b.port,
                        "weight": b.weight,
                        "is_healthy": b.is_healthy,
                        "active_connections": b.active_connections,
                        "response_time": b.response_time,
                        "last_health_check": b.last_health_check.isoformat() if b.last_health_check else None
                    }
                    for b in sorted_backends
                ]
            }
```

### ğŸ“¦ **ê°€ì¤‘ì¹˜ ê¸°ë°˜ ë¡œë“œ ë°¸ëŸ°ì„œ**

```python
# load-balancing/algorithms/weighted/weighted_balancer.py
import asyncio
import threading
import random
from typing import List, Dict, Any, Optional
from dataclasses import dataclass
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

class WeightedLoadBalancer:
    """ê°€ì¤‘ì¹˜ ê¸°ë°˜ ë¡œë“œ ë°¸ëŸ°ì„œ"""
    
    def __init__(self):
        self.backends: List[BackendServer] = []
        self.lock = threading.Lock()
        self.health_check_interval = 10  # 10ì´ˆ
        
        logger.info("Initialized weighted load balancer")
    
    def add_backend(self, server_id: str, address: str, port: int, weight: int = 1):
        """ë°±ì—”ë“œ ì„œë²„ ì¶”ê°€"""
        with self.lock:
            backend = BackendServer(
                id=server_id,
                address=address,
                port=port,
                weight=weight
            )
            self.backends.append(backend)
            logger.info(f"Added backend server: {server_id} ({address}:{port}) with weight {weight}")
    
    def remove_backend(self, server_id: str):
        """ë°±ì—”ë“œ ì„œë²„ ì œê±°"""
        with self.lock:
            self.backends = [b for b in self.backends if b.id != server_id]
            logger.info(f"Removed backend server: {server_id}")
    
    def get_next_backend(self) -> Optional[BackendServer]:
        """ë‹¤ìŒ ë°±ì—”ë“œ ì„œë²„ ì„ íƒ (ê°€ì¤‘ì¹˜ ê¸°ë°˜)"""
        with self.lock:
            if not self.backends:
                return None
            
            # ê±´ê°•í•œ ì„œë²„ë§Œ í•„í„°ë§
            healthy_backends = [b for b in self.backends if b.is_healthy]
            
            if not healthy_backends:
                logger.warning("No healthy backend servers available")
                return None
            
            # ê°€ì¤‘ì¹˜ ê¸°ë°˜ ì„ íƒ
            total_weight = sum(b.weight for b in healthy_backends)
            if total_weight == 0:
                return None
            
            # ëœë¤ ì„ íƒ (ê°€ì¤‘ì¹˜ ê¸°ë°˜)
            random_value = random.uniform(0, total_weight)
            current_weight = 0
            
            for backend in healthy_backends:
                current_weight += backend.weight
                if random_value <= current_weight:
                    # ì—°ê²° ìˆ˜ ì¦ê°€
                    backend.active_connections += 1
                    logger.debug(f"Selected backend: {backend.id} (weight: {backend.weight}, connections: {backend.active_connections})")
                    return backend
            
            # í´ë°± (ë§ˆì§€ë§‰ ì„œë²„)
            selected_backend = healthy_backends[-1]
            selected_backend.active_connections += 1
            return selected_backend
    
    def release_connection(self, server_id: str):
        """ì—°ê²° í•´ì œ"""
        with self.lock:
            for backend in self.backends:
                if backend.id == server_id:
                    backend.active_connections = max(0, backend.active_connections - 1)
                    logger.debug(f"Released connection from {server_id} (connections: {backend.active_connections})")
                    break
    
    def update_backend_weight(self, server_id: str, new_weight: int):
        """ë°±ì—”ë“œ ê°€ì¤‘ì¹˜ ì—…ë°ì´íŠ¸"""
        with self.lock:
            for backend in self.backends:
                if backend.id == server_id:
                    old_weight = backend.weight
                    backend.weight = new_weight
                    logger.info(f"Updated backend {server_id} weight: {old_weight} -> {new_weight}")
                    break
    
    def get_backend_stats(self) -> Dict[str, Any]:
        """ë°±ì—”ë“œ í†µê³„ ì¡°íšŒ"""
        with self.lock:
            total_backends = len(self.backends)
            healthy_backends = len([b for b in self.backends if b.is_healthy])
            total_connections = sum(b.active_connections for b in self.backends)
            total_weight = sum(b.weight for b in self.backends)
            
            return {
                "total_backends": total_backends,
                "healthy_backends": healthy_backends,
                "unhealthy_backends": total_backends - healthy_backends,
                "total_connections": total_connections,
                "total_weight": total_weight,
                "backends": [
                    {
                        "id": b.id,
                        "address": b.address,
                        "port": b.port,
                        "weight": b.weight,
                        "is_healthy": b.is_healthy,
                        "active_connections": b.active_connections,
                        "response_time": b.response_time,
                        "last_health_check": b.last_health_check.isoformat() if b.last_health_check else None
                    }
                    for b in self.backends
                ]
            }
```

## ğŸ”§ **ì„¸ì…˜ ê´€ë¦¬**

### ğŸ“¦ **ìŠ¤í‹°í‚¤ ì„¸ì…˜ ê´€ë¦¬ì**

```python
# load-balancing/session-management/sticky-sessions/sticky_session_manager.py
import asyncio
import hashlib
import time
from typing import Dict, Optional, Any
from dataclasses import dataclass
from datetime import datetime, timedelta
import logging

logger = logging.getLogger(__name__)

@dataclass
class StickySession:
    """ìŠ¤í‹°í‚¤ ì„¸ì…˜"""
    session_id: str
    backend_id: str
    created_at: datetime
    last_accessed: datetime
    ttl: int = 3600  # 1ì‹œê°„

class StickySessionManager:
    """ìŠ¤í‹°í‚¤ ì„¸ì…˜ ê´€ë¦¬ì"""
    
    def __init__(self):
        self.sessions: Dict[str, StickySession] = {}
        self.session_cleanup_interval = 300  # 5ë¶„
        self.default_ttl = 3600  # 1ì‹œê°„
        
        logger.info("Initialized sticky session manager")
    
    def create_session(self, client_id: str, backend_id: str, ttl: int = None) -> str:
        """ì„¸ì…˜ ìƒì„±"""
        session_id = self._generate_session_id(client_id)
        
        session = StickySession(
            session_id=session_id,
            backend_id=backend_id,
            created_at=datetime.now(),
            last_accessed=datetime.now(),
            ttl=ttl or self.default_ttl
        )
        
        self.sessions[session_id] = session
        logger.debug(f"Created sticky session: {session_id} -> {backend_id}")
        
        return session_id
    
    def get_session_backend(self, session_id: str) -> Optional[str]:
        """ì„¸ì…˜ì˜ ë°±ì—”ë“œ ID ì¡°íšŒ"""
        session = self.sessions.get(session_id)
        
        if not session:
            return None
        
        # TTL í™•ì¸
        if self._is_session_expired(session):
            self.remove_session(session_id)
            return None
        
        # ë§ˆì§€ë§‰ ì ‘ê·¼ ì‹œê°„ ì—…ë°ì´íŠ¸
        session.last_accessed = datetime.now()
        
        logger.debug(f"Retrieved sticky session: {session_id} -> {session.backend_id}")
        return session.backend_id
    
    def update_session_backend(self, session_id: str, new_backend_id: str):
        """ì„¸ì…˜ ë°±ì—”ë“œ ì—…ë°ì´íŠ¸"""
        session = self.sessions.get(session_id)
        
        if session:
            old_backend_id = session.backend_id
            session.backend_id = new_backend_id
            session.last_accessed = datetime.now()
            
            logger.info(f"Updated sticky session: {session_id} {old_backend_id} -> {new_backend_id}")
    
    def remove_session(self, session_id: str):
        """ì„¸ì…˜ ì œê±°"""
        if session_id in self.sessions:
            del self.sessions[session_id]
            logger.debug(f"Removed sticky session: {session_id}")
    
    def _generate_session_id(self, client_id: str) -> str:
        """ì„¸ì…˜ ID ìƒì„±"""
        timestamp = str(int(time.time()))
        data = f"{client_id}:{timestamp}"
        return hashlib.md5(data.encode()).hexdigest()
    
    def _is_session_expired(self, session: StickySession) -> bool:
        """ì„¸ì…˜ ë§Œë£Œ í™•ì¸"""
        expiry_time = session.last_accessed + timedelta(seconds=session.ttl)
        return datetime.now() > expiry_time
    
    async def start_cleanup_loop(self):
        """ì„¸ì…˜ ì •ë¦¬ ë£¨í”„ ì‹œì‘"""
        while True:
            try:
                await self._cleanup_expired_sessions()
                await asyncio.sleep(self.session_cleanup_interval)
                
            except Exception as e:
                logger.error(f"Session cleanup loop error: {e}")
                await asyncio.sleep(self.session_cleanup_interval)
    
    async def _cleanup_expired_sessions(self):
        """ë§Œë£Œëœ ì„¸ì…˜ ì •ë¦¬"""
        expired_sessions = []
        
        for session_id, session in self.sessions.items():
            if self._is_session_expired(session):
                expired_sessions.append(session_id)
        
        for session_id in expired_sessions:
            self.remove_session(session_id)
        
        if expired_sessions:
            logger.info(f"Cleaned up {len(expired_sessions)} expired sessions")
    
    def get_session_stats(self) -> Dict[str, Any]:
        """ì„¸ì…˜ í†µê³„ ì¡°íšŒ"""
        total_sessions = len(self.sessions)
        active_sessions = len([s for s in self.sessions.values() if not self._is_session_expired(s)])
        expired_sessions = total_sessions - active_sessions
        
        # ë°±ì—”ë“œë³„ ì„¸ì…˜ ìˆ˜
        backend_sessions = {}
        for session in self.sessions.values():
            backend_id = session.backend_id
            backend_sessions[backend_id] = backend_sessions.get(backend_id, 0) + 1
        
        return {
            "total_sessions": total_sessions,
            "active_sessions": active_sessions,
            "expired_sessions": expired_sessions,
            "backend_sessions": backend_sessions
        }
```

## ğŸ”§ **ë¡œë“œ ë°¸ëŸ°ì„œ í”„ë¡ì‹œ**

### ğŸ“¦ **HTTP ë¡œë“œ ë°¸ëŸ°ì„œ í”„ë¡ì‹œ**

```python
# load-balancing/proxy/http_load_balancer_proxy.py
import asyncio
import aiohttp
from aiohttp import web
from typing import Dict, List, Optional, Any
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

class HTTPLoadBalancerProxy:
    """HTTP ë¡œë“œ ë°¸ëŸ°ì„œ í”„ë¡ì‹œ"""
    
    def __init__(self, balancer, session_manager=None):
        self.balancer = balancer
        self.session_manager = session_manager
        self.app = web.Application()
        self.setup_routes()
        
        logger.info("Initialized HTTP load balancer proxy")
    
    def setup_routes(self):
        """ë¼ìš°íŠ¸ ì„¤ì •"""
        self.app.router.add_route('*', '/{path:.*}', self.proxy_handler)
    
    async def proxy_handler(self, request: web.Request) -> web.Response:
        """í”„ë¡ì‹œ í•¸ë“¤ëŸ¬"""
        try:
            # ë°±ì—”ë“œ ì„œë²„ ì„ íƒ
            backend = await self._select_backend(request)
            
            if not backend:
                return web.Response(
                    text="No healthy backend servers available",
                    status=503
                )
            
            # ìš”ì²­ ì „ë‹¬
            response = await self._forward_request(request, backend)
            
            # ì—°ê²° í•´ì œ
            self.balancer.release_connection(backend.id)
            
            return response
            
        except Exception as e:
            logger.error(f"Proxy handler error: {e}")
            return web.Response(
                text="Internal server error",
                status=500
            )
    
    async def _select_backend(self, request: web.Request):
        """ë°±ì—”ë“œ ì„œë²„ ì„ íƒ"""
        # ìŠ¤í‹°í‚¤ ì„¸ì…˜ í™•ì¸
        if self.session_manager:
            session_id = request.cookies.get('session_id')
            if session_id:
                backend_id = self.session_manager.get_session_backend(session_id)
                if backend_id:
                    # í•´ë‹¹ ë°±ì—”ë“œ ì°¾ê¸°
                    for backend in self.balancer.backends:
                        if backend.id == backend_id and backend.is_healthy:
                            backend.active_connections += 1
                            return backend
        
        # ì¼ë°˜ì ì¸ ë¡œë“œ ë°¸ëŸ°ì‹±
        return self.balancer.get_next_backend()
    
    async def _forward_request(self, request: web.Request, backend) -> web.Response:
        """ìš”ì²­ ì „ë‹¬"""
        try:
            # ìš”ì²­ ë³¸ë¬¸ ì½ê¸°
            body = await request.read()
            
            # í—¤ë” ì¤€ë¹„
            headers = dict(request.headers)
            headers.pop('Host', None)  # Host í—¤ë” ì œê±°
            
            # URL êµ¬ì„±
            target_url = f"http://{backend.address}:{backend.port}{request.path_qs}"
            
            # HTTP í´ë¼ì´ì–¸íŠ¸ë¡œ ìš”ì²­ ì „ë‹¬
            async with aiohttp.ClientSession() as session:
                async with session.request(
                    method=request.method,
                    url=target_url,
                    headers=headers,
                    data=body,
                    timeout=aiohttp.ClientTimeout(total=30)
                ) as response:
                    
                    # ì‘ë‹µ ë³¸ë¬¸ ì½ê¸°
                    response_body = await response.read()
                    
                    # ì‘ë‹µ ìƒì„±
                    proxy_response = web.Response(
                        body=response_body,
                        status=response.status,
                        headers=response.headers
                    )
                    
                    # ìŠ¤í‹°í‚¤ ì„¸ì…˜ ì„¤ì •
                    if self.session_manager and not request.cookies.get('session_id'):
                        session_id = self.session_manager.create_session(
                            client_id=request.remote,
                            backend_id=backend.id
                        )
                        proxy_response.set_cookie('session_id', session_id, max_age=3600)
                    
                    return proxy_response
                    
        except Exception as e:
            logger.error(f"Request forwarding failed: {e}")
            raise
    
    async def start_server(self, host: str = '0.0.0.0', port: int = 8080):
        """ì„œë²„ ì‹œì‘"""
        runner = web.AppRunner(self.app)
        await runner.setup()
        
        site = web.TCPSite(runner, host, port)
        await site.start()
        
        logger.info(f"Load balancer proxy started on {host}:{port}")
        
        # í—¬ìŠ¤ ì²´í¬ ë£¨í”„ ì‹œì‘
        asyncio.create_task(self.balancer.start_health_check_loop())
        
        # ì„¸ì…˜ ì •ë¦¬ ë£¨í”„ ì‹œì‘
        if self.session_manager:
            asyncio.create_task(self.session_manager.start_cleanup_loop())
        
        try:
            await asyncio.Future()  # ë¬´í•œ ëŒ€ê¸°
        except KeyboardInterrupt:
            logger.info("Shutting down load balancer proxy")
            await runner.cleanup()
```

## ğŸ”§ **ëª¨ë‹ˆí„°ë§ ë° ë©”íŠ¸ë¦­**

### ğŸ“¦ **ë¡œë“œ ë°¸ëŸ°ì„œ ëª¨ë‹ˆí„°ë§**

```python
# load-balancing/monitoring/load_balancer_monitor.py
import asyncio
import time
from typing import Dict, List, Any
from dataclasses import dataclass
from datetime import datetime, timedelta
import logging

logger = logging.getLogger(__name__)

@dataclass
class LoadBalancerMetrics:
    """ë¡œë“œ ë°¸ëŸ°ì„œ ë©”íŠ¸ë¦­"""
    total_requests: int
    successful_requests: int
    failed_requests: int
    average_response_time: float
    requests_per_second: float
    active_connections: int
    timestamp: datetime

class LoadBalancerMonitor:
    """ë¡œë“œ ë°¸ëŸ°ì„œ ëª¨ë‹ˆí„°ë§"""
    
    def __init__(self, balancer):
        self.balancer = balancer
        self.metrics_history = []
        self.request_count = 0
        self.successful_requests = 0
        self.failed_requests = 0
        self.total_response_time = 0.0
        self.start_time = datetime.now()
        
        logger.info("Initialized load balancer monitor")
    
    def record_request(self, success: bool, response_time: float):
        """ìš”ì²­ ê¸°ë¡"""
        self.request_count += 1
        
        if success:
            self.successful_requests += 1
        else:
            self.failed_requests += 1
        
        self.total_response_time += response_time
    
    def get_current_metrics(self) -> LoadBalancerMetrics:
        """í˜„ì¬ ë©”íŠ¸ë¦­ ì¡°íšŒ"""
        uptime = (datetime.now() - self.start_time).total_seconds()
        requests_per_second = self.request_count / uptime if uptime > 0 else 0
        average_response_time = self.total_response_time / self.request_count if self.request_count > 0 else 0
        
        backend_stats = self.balancer.get_backend_stats()
        active_connections = backend_stats.get('total_connections', 0)
        
        metrics = LoadBalancerMetrics(
            total_requests=self.request_count,
            successful_requests=self.successful_requests,
            failed_requests=self.failed_requests,
            average_response_time=average_response_time,
            requests_per_second=requests_per_second,
            active_connections=active_connections,
            timestamp=datetime.now()
        )
        
        # ë©”íŠ¸ë¦­ íˆìŠ¤í† ë¦¬ì— ì¶”ê°€
        self.metrics_history.append(metrics)
        
        # 1ì‹œê°„ ì´ì „ ë°ì´í„° ì œê±°
        cutoff_time = datetime.now() - timedelta(hours=1)
        self.metrics_history = [
            m for m in self.metrics_history
            if m.timestamp > cutoff_time
        ]
        
        return metrics
    
    def get_metrics_summary(self) -> Dict[str, Any]:
        """ë©”íŠ¸ë¦­ ìš”ì•½"""
        current_metrics = self.get_current_metrics()
        backend_stats = self.balancer.get_backend_stats()
        
        return {
            "load_balancer": {
                "total_requests": current_metrics.total_requests,
                "successful_requests": current_metrics.successful_requests,
                "failed_requests": current_metrics.failed_requests,
                "success_rate": (current_metrics.successful_requests / current_metrics.total_requests * 100) if current_metrics.total_requests > 0 else 0,
                "average_response_time_ms": current_metrics.average_response_time,
                "requests_per_second": current_metrics.requests_per_second,
                "active_connections": current_metrics.active_connections,
                "uptime_seconds": (datetime.now() - self.start_time).total_seconds()
            },
            "backends": backend_stats,
            "session_stats": self.balancer.session_manager.get_session_stats() if hasattr(self.balancer, 'session_manager') and self.balancer.session_manager else {}
        }
    
    async def start_monitoring_loop(self, interval: int = 60):
        """ëª¨ë‹ˆí„°ë§ ë£¨í”„ ì‹œì‘"""
        while True:
            try:
                metrics = self.get_current_metrics()
                
                # ë©”íŠ¸ë¦­ ë¡œê¹…
                logger.info(f"Load balancer metrics: {metrics.requests_per_second:.2f} RPS, "
                          f"{metrics.average_response_time:.2f}ms avg response time, "
                          f"{metrics.active_connections} active connections")
                
                # ì•Œë¦¼ ì²´í¬
                await self._check_alerts(metrics)
                
                await asyncio.sleep(interval)
                
            except Exception as e:
                logger.error(f"Monitoring loop error: {e}")
                await asyncio.sleep(interval)
    
    async def _check_alerts(self, metrics: LoadBalancerMetrics):
        """ì•Œë¦¼ ì²´í¬"""
        # ë†’ì€ ì‘ë‹µ ì‹œê°„ ì•Œë¦¼
        if metrics.average_response_time > 1000:  # 1ì´ˆ ì´ìƒ
            logger.warning(f"High average response time: {metrics.average_response_time:.2f}ms")
        
        # ë†’ì€ ì‹¤íŒ¨ìœ¨ ì•Œë¦¼
        if metrics.total_requests > 0:
            failure_rate = (metrics.failed_requests / metrics.total_requests) * 100
            if failure_rate > 5:  # 5% ì´ìƒ
                logger.warning(f"High failure rate: {failure_rate:.2f}%")
        
        # ë°±ì—”ë“œ ì„œë²„ ë¶€ì¡± ì•Œë¦¼
        backend_stats = self.balancer.get_backend_stats()
        if backend_stats['healthy_backends'] == 0:
            logger.error("No healthy backend servers available")
```

## ğŸ¯ **ë‹¤ìŒ ë‹¨ê³„**

### ğŸ“‹ **ì™„ë£Œëœ ì‘ì—…**
- âœ… ë¼ìš´ë“œ ë¡œë¹ˆ ë¡œë“œ ë°¸ëŸ°ì„œ
- âœ… ìµœì†Œ ì—°ê²° ë¡œë“œ ë°¸ëŸ°ì„œ
- âœ… ê°€ì¤‘ì¹˜ ê¸°ë°˜ ë¡œë“œ ë°¸ëŸ°ì„œ
- âœ… ìŠ¤í‹°í‚¤ ì„¸ì…˜ ê´€ë¦¬
- âœ… HTTP ë¡œë“œ ë°¸ëŸ°ì„œ í”„ë¡ì‹œ
- âœ… ë¡œë“œ ë°¸ëŸ°ì„œ ëª¨ë‹ˆí„°ë§

### ğŸ”„ **ì§„í–‰ ì¤‘ì¸ ì‘ì—…**
- ğŸ”„ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ
- ğŸ”„ ì¥ì•  ë³µêµ¬ ì‹œìŠ¤í…œ
- ğŸ”„ ì„±ëŠ¥ ìµœì í™”

### â³ **ë‹¤ìŒ ë‹¨ê³„**
1. **Phase 2.4 ëª¨ë‹ˆí„°ë§** ë¬¸ì„œ ìƒì„±
2. **Phase 2.5 ì¥ì•  ë³µêµ¬** ë¬¸ì„œ ìƒì„±
3. **Phase 2.6 ì„±ëŠ¥ ìµœì í™”** ë¬¸ì„œ ìƒì„±

---

**ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸**: 2024-01-31
**ë‹¤ìŒ ì—…ë°ì´íŠ¸**: 2024-02-01 (Phase 2.4 ëª¨ë‹ˆí„°ë§)
**ë¡œë“œ ë°¸ëŸ°ì‹± ëª©í‘œ**: < 50ms ì‘ë‹µì‹œê°„, 10,000 RPS, 99.99% ê°€ìš©ì„±
**ì¥ì•  ë³µêµ¬**: < 10ì´ˆ ìë™ ì¥ì•  ì¡°ì¹˜ 