# ⚖️ Phase 2.3: 로드 밸런싱 및 트래픽 분산

## 📋 **개요**

### 🎯 **목표**
- **트래픽 분산**: 서비스 인스턴스 간 부하 균등 분산
- **고가용성**: 서비스 장애 시 자동 장애 조치
- **성능 최적화**: 응답 시간 및 처리량 최적화
- **확장성**: 동적 스케일링 지원

### 📊 **성능 목표**
- **응답 시간**: < 50ms (95th percentile)
- **처리량**: 10,000 RPS (요청/초)
- **가용성**: 99.99% (연간 다운타임 < 1시간)
- **장애 복구**: < 10초 (자동 장애 조치)

## 🏗️ **로드 밸런싱 아키텍처**

### 📁 **로드 밸런싱 구조**
```
load-balancing/
├── algorithms/                    # 로드 밸런싱 알고리즘
│   ├── round-robin/              # 라운드 로빈
│   ├── least-connections/        # 최소 연결
│   ├── weighted/                 # 가중치 기반
│   ├── ip-hash/                  # IP 해시
│   └── least-response-time/      # 최소 응답 시간
├── health-checking/              # 헬스 체크
│   ├── active/                   # 능동적 헬스 체크
│   ├── passive/                  # 수동적 헬스 체크
│   └── custom/                   # 커스텀 헬스 체크
├── session-management/           # 세션 관리
│   ├── sticky-sessions/          # 스티키 세션
│   ├── session-replication/      # 세션 복제
│   └── distributed-sessions/     # 분산 세션
└── monitoring/                   # 모니터링
    ├── metrics/                  # 메트릭 수집
    ├── alerts/                   # 알림 시스템
    └── dashboard/                # 대시보드
```

## 🔧 **로드 밸런싱 알고리즘**

### 📦 **라운드 로빈 로드 밸런서**

```python
# load-balancing/algorithms/round-robin/round_robin_balancer.py
import asyncio
import threading
from typing import List, Dict, Any, Optional
from dataclasses import dataclass
from datetime import datetime, timedelta
import logging

logger = logging.getLogger(__name__)

@dataclass
class BackendServer:
    """백엔드 서버"""
    id: str
    address: str
    port: int
    weight: int = 1
    is_healthy: bool = True
    active_connections: int = 0
    response_time: float = 0.0
    last_health_check: Optional[datetime] = None

class RoundRobinLoadBalancer:
    """라운드 로빈 로드 밸런서"""
    
    def __init__(self):
        self.backends: List[BackendServer] = []
        self.current_index = 0
        self.lock = threading.Lock()
        self.health_check_interval = 10  # 10초
        self.connection_timeout = 30  # 30초
        
        logger.info("Initialized round-robin load balancer")
    
    def add_backend(self, server_id: str, address: str, port: int, weight: int = 1):
        """백엔드 서버 추가"""
        with self.lock:
            backend = BackendServer(
                id=server_id,
                address=address,
                port=port,
                weight=weight
            )
            self.backends.append(backend)
            logger.info(f"Added backend server: {server_id} ({address}:{port})")
    
    def remove_backend(self, server_id: str):
        """백엔드 서버 제거"""
        with self.lock:
            self.backends = [b for b in self.backends if b.id != server_id]
            logger.info(f"Removed backend server: {server_id}")
    
    def get_next_backend(self) -> Optional[BackendServer]:
        """다음 백엔드 서버 선택"""
        with self.lock:
            if not self.backends:
                return None
            
            # 건강한 서버만 필터링
            healthy_backends = [b for b in self.backends if b.is_healthy]
            
            if not healthy_backends:
                logger.warning("No healthy backend servers available")
                return None
            
            # 라운드 로빈 선택
            selected_backend = healthy_backends[self.current_index % len(healthy_backends)]
            self.current_index += 1
            
            # 연결 수 증가
            selected_backend.active_connections += 1
            
            logger.debug(f"Selected backend: {selected_backend.id} (connections: {selected_backend.active_connections})")
            return selected_backend
    
    def release_connection(self, server_id: str):
        """연결 해제"""
        with self.lock:
            for backend in self.backends:
                if backend.id == server_id:
                    backend.active_connections = max(0, backend.active_connections - 1)
                    logger.debug(f"Released connection from {server_id} (connections: {backend.active_connections})")
                    break
    
    def update_server_health(self, server_id: str, is_healthy: bool, response_time: float = 0.0):
        """서버 헬스 상태 업데이트"""
        with self.lock:
            for backend in self.backends:
                if backend.id == server_id:
                    backend.is_healthy = is_healthy
                    backend.response_time = response_time
                    backend.last_health_check = datetime.now()
                    
                    if not is_healthy:
                        logger.warning(f"Backend server {server_id} is unhealthy")
                    else:
                        logger.debug(f"Backend server {server_id} is healthy (response time: {response_time}ms)")
                    break
    
    def get_backend_stats(self) -> Dict[str, Any]:
        """백엔드 통계 조회"""
        with self.lock:
            total_backends = len(self.backends)
            healthy_backends = len([b for b in self.backends if b.is_healthy])
            total_connections = sum(b.active_connections for b in self.backends)
            
            return {
                "total_backends": total_backends,
                "healthy_backends": healthy_backends,
                "unhealthy_backends": total_backends - healthy_backends,
                "total_connections": total_connections,
                "backends": [
                    {
                        "id": b.id,
                        "address": b.address,
                        "port": b.port,
                        "weight": b.weight,
                        "is_healthy": b.is_healthy,
                        "active_connections": b.active_connections,
                        "response_time": b.response_time,
                        "last_health_check": b.last_health_check.isoformat() if b.last_health_check else None
                    }
                    for b in self.backends
                ]
            }
    
    async def start_health_check_loop(self):
        """헬스 체크 루프 시작"""
        while True:
            try:
                for backend in self.backends:
                    await self._check_backend_health(backend)
                
                await asyncio.sleep(self.health_check_interval)
                
            except Exception as e:
                logger.error(f"Health check loop error: {e}")
                await asyncio.sleep(self.health_check_interval)
    
    async def _check_backend_health(self, backend: BackendServer):
        """백엔드 헬스 체크"""
        try:
            start_time = datetime.now()
            
            # HTTP 헬스 체크
            health_url = f"http://{backend.address}:{backend.port}/health"
            
            async with aiohttp.ClientSession() as session:
                async with session.get(health_url, timeout=5) as response:
                    response_time = (datetime.now() - start_time).total_seconds() * 1000
                    
                    if response.status == 200:
                        self.update_server_health(backend.id, True, response_time)
                    else:
                        self.update_server_health(backend.id, False, response_time)
                        
        except Exception as e:
            logger.error(f"Health check failed for {backend.id}: {e}")
            self.update_server_health(backend.id, False, 0.0)
```

### 📦 **최소 연결 로드 밸런서**

```python
# load-balancing/algorithms/least-connections/least_connections_balancer.py
import asyncio
import threading
from typing import List, Dict, Any, Optional
from dataclasses import dataclass
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

class LeastConnectionsLoadBalancer:
    """최소 연결 로드 밸런서"""
    
    def __init__(self):
        self.backends: List[BackendServer] = []
        self.lock = threading.Lock()
        self.health_check_interval = 10  # 10초
        
        logger.info("Initialized least-connections load balancer")
    
    def add_backend(self, server_id: str, address: str, port: int, weight: int = 1):
        """백엔드 서버 추가"""
        with self.lock:
            backend = BackendServer(
                id=server_id,
                address=address,
                port=port,
                weight=weight
            )
            self.backends.append(backend)
            logger.info(f"Added backend server: {server_id} ({address}:{port})")
    
    def remove_backend(self, server_id: str):
        """백엔드 서버 제거"""
        with self.lock:
            self.backends = [b for b in self.backends if b.id != server_id]
            logger.info(f"Removed backend server: {server_id}")
    
    def get_next_backend(self) -> Optional[BackendServer]:
        """다음 백엔드 서버 선택 (최소 연결)"""
        with self.lock:
            if not self.backends:
                return None
            
            # 건강한 서버만 필터링
            healthy_backends = [b for b in self.backends if b.is_healthy]
            
            if not healthy_backends:
                logger.warning("No healthy backend servers available")
                return None
            
            # 최소 연결 수를 가진 서버 선택
            selected_backend = min(healthy_backends, key=lambda b: b.active_connections)
            
            # 연결 수 증가
            selected_backend.active_connections += 1
            
            logger.debug(f"Selected backend: {selected_backend.id} (connections: {selected_backend.active_connections})")
            return selected_backend
    
    def release_connection(self, server_id: str):
        """연결 해제"""
        with self.lock:
            for backend in self.backends:
                if backend.id == server_id:
                    backend.active_connections = max(0, backend.active_connections - 1)
                    logger.debug(f"Released connection from {server_id} (connections: {backend.active_connections})")
                    break
    
    def get_backend_stats(self) -> Dict[str, Any]:
        """백엔드 통계 조회"""
        with self.lock:
            total_backends = len(self.backends)
            healthy_backends = len([b for b in self.backends if b.is_healthy])
            total_connections = sum(b.active_connections for b in self.backends)
            
            # 연결 수별 정렬
            sorted_backends = sorted(self.backends, key=lambda b: b.active_connections)
            
            return {
                "total_backends": total_backends,
                "healthy_backends": healthy_backends,
                "unhealthy_backends": total_backends - healthy_backends,
                "total_connections": total_connections,
                "backends": [
                    {
                        "id": b.id,
                        "address": b.address,
                        "port": b.port,
                        "weight": b.weight,
                        "is_healthy": b.is_healthy,
                        "active_connections": b.active_connections,
                        "response_time": b.response_time,
                        "last_health_check": b.last_health_check.isoformat() if b.last_health_check else None
                    }
                    for b in sorted_backends
                ]
            }
```

### 📦 **가중치 기반 로드 밸런서**

```python
# load-balancing/algorithms/weighted/weighted_balancer.py
import asyncio
import threading
import random
from typing import List, Dict, Any, Optional
from dataclasses import dataclass
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

class WeightedLoadBalancer:
    """가중치 기반 로드 밸런서"""
    
    def __init__(self):
        self.backends: List[BackendServer] = []
        self.lock = threading.Lock()
        self.health_check_interval = 10  # 10초
        
        logger.info("Initialized weighted load balancer")
    
    def add_backend(self, server_id: str, address: str, port: int, weight: int = 1):
        """백엔드 서버 추가"""
        with self.lock:
            backend = BackendServer(
                id=server_id,
                address=address,
                port=port,
                weight=weight
            )
            self.backends.append(backend)
            logger.info(f"Added backend server: {server_id} ({address}:{port}) with weight {weight}")
    
    def remove_backend(self, server_id: str):
        """백엔드 서버 제거"""
        with self.lock:
            self.backends = [b for b in self.backends if b.id != server_id]
            logger.info(f"Removed backend server: {server_id}")
    
    def get_next_backend(self) -> Optional[BackendServer]:
        """다음 백엔드 서버 선택 (가중치 기반)"""
        with self.lock:
            if not self.backends:
                return None
            
            # 건강한 서버만 필터링
            healthy_backends = [b for b in self.backends if b.is_healthy]
            
            if not healthy_backends:
                logger.warning("No healthy backend servers available")
                return None
            
            # 가중치 기반 선택
            total_weight = sum(b.weight for b in healthy_backends)
            if total_weight == 0:
                return None
            
            # 랜덤 선택 (가중치 기반)
            random_value = random.uniform(0, total_weight)
            current_weight = 0
            
            for backend in healthy_backends:
                current_weight += backend.weight
                if random_value <= current_weight:
                    # 연결 수 증가
                    backend.active_connections += 1
                    logger.debug(f"Selected backend: {backend.id} (weight: {backend.weight}, connections: {backend.active_connections})")
                    return backend
            
            # 폴백 (마지막 서버)
            selected_backend = healthy_backends[-1]
            selected_backend.active_connections += 1
            return selected_backend
    
    def release_connection(self, server_id: str):
        """연결 해제"""
        with self.lock:
            for backend in self.backends:
                if backend.id == server_id:
                    backend.active_connections = max(0, backend.active_connections - 1)
                    logger.debug(f"Released connection from {server_id} (connections: {backend.active_connections})")
                    break
    
    def update_backend_weight(self, server_id: str, new_weight: int):
        """백엔드 가중치 업데이트"""
        with self.lock:
            for backend in self.backends:
                if backend.id == server_id:
                    old_weight = backend.weight
                    backend.weight = new_weight
                    logger.info(f"Updated backend {server_id} weight: {old_weight} -> {new_weight}")
                    break
    
    def get_backend_stats(self) -> Dict[str, Any]:
        """백엔드 통계 조회"""
        with self.lock:
            total_backends = len(self.backends)
            healthy_backends = len([b for b in self.backends if b.is_healthy])
            total_connections = sum(b.active_connections for b in self.backends)
            total_weight = sum(b.weight for b in self.backends)
            
            return {
                "total_backends": total_backends,
                "healthy_backends": healthy_backends,
                "unhealthy_backends": total_backends - healthy_backends,
                "total_connections": total_connections,
                "total_weight": total_weight,
                "backends": [
                    {
                        "id": b.id,
                        "address": b.address,
                        "port": b.port,
                        "weight": b.weight,
                        "is_healthy": b.is_healthy,
                        "active_connections": b.active_connections,
                        "response_time": b.response_time,
                        "last_health_check": b.last_health_check.isoformat() if b.last_health_check else None
                    }
                    for b in self.backends
                ]
            }
```

## 🔧 **세션 관리**

### 📦 **스티키 세션 관리자**

```python
# load-balancing/session-management/sticky-sessions/sticky_session_manager.py
import asyncio
import hashlib
import time
from typing import Dict, Optional, Any
from dataclasses import dataclass
from datetime import datetime, timedelta
import logging

logger = logging.getLogger(__name__)

@dataclass
class StickySession:
    """스티키 세션"""
    session_id: str
    backend_id: str
    created_at: datetime
    last_accessed: datetime
    ttl: int = 3600  # 1시간

class StickySessionManager:
    """스티키 세션 관리자"""
    
    def __init__(self):
        self.sessions: Dict[str, StickySession] = {}
        self.session_cleanup_interval = 300  # 5분
        self.default_ttl = 3600  # 1시간
        
        logger.info("Initialized sticky session manager")
    
    def create_session(self, client_id: str, backend_id: str, ttl: int = None) -> str:
        """세션 생성"""
        session_id = self._generate_session_id(client_id)
        
        session = StickySession(
            session_id=session_id,
            backend_id=backend_id,
            created_at=datetime.now(),
            last_accessed=datetime.now(),
            ttl=ttl or self.default_ttl
        )
        
        self.sessions[session_id] = session
        logger.debug(f"Created sticky session: {session_id} -> {backend_id}")
        
        return session_id
    
    def get_session_backend(self, session_id: str) -> Optional[str]:
        """세션의 백엔드 ID 조회"""
        session = self.sessions.get(session_id)
        
        if not session:
            return None
        
        # TTL 확인
        if self._is_session_expired(session):
            self.remove_session(session_id)
            return None
        
        # 마지막 접근 시간 업데이트
        session.last_accessed = datetime.now()
        
        logger.debug(f"Retrieved sticky session: {session_id} -> {session.backend_id}")
        return session.backend_id
    
    def update_session_backend(self, session_id: str, new_backend_id: str):
        """세션 백엔드 업데이트"""
        session = self.sessions.get(session_id)
        
        if session:
            old_backend_id = session.backend_id
            session.backend_id = new_backend_id
            session.last_accessed = datetime.now()
            
            logger.info(f"Updated sticky session: {session_id} {old_backend_id} -> {new_backend_id}")
    
    def remove_session(self, session_id: str):
        """세션 제거"""
        if session_id in self.sessions:
            del self.sessions[session_id]
            logger.debug(f"Removed sticky session: {session_id}")
    
    def _generate_session_id(self, client_id: str) -> str:
        """세션 ID 생성"""
        timestamp = str(int(time.time()))
        data = f"{client_id}:{timestamp}"
        return hashlib.md5(data.encode()).hexdigest()
    
    def _is_session_expired(self, session: StickySession) -> bool:
        """세션 만료 확인"""
        expiry_time = session.last_accessed + timedelta(seconds=session.ttl)
        return datetime.now() > expiry_time
    
    async def start_cleanup_loop(self):
        """세션 정리 루프 시작"""
        while True:
            try:
                await self._cleanup_expired_sessions()
                await asyncio.sleep(self.session_cleanup_interval)
                
            except Exception as e:
                logger.error(f"Session cleanup loop error: {e}")
                await asyncio.sleep(self.session_cleanup_interval)
    
    async def _cleanup_expired_sessions(self):
        """만료된 세션 정리"""
        expired_sessions = []
        
        for session_id, session in self.sessions.items():
            if self._is_session_expired(session):
                expired_sessions.append(session_id)
        
        for session_id in expired_sessions:
            self.remove_session(session_id)
        
        if expired_sessions:
            logger.info(f"Cleaned up {len(expired_sessions)} expired sessions")
    
    def get_session_stats(self) -> Dict[str, Any]:
        """세션 통계 조회"""
        total_sessions = len(self.sessions)
        active_sessions = len([s for s in self.sessions.values() if not self._is_session_expired(s)])
        expired_sessions = total_sessions - active_sessions
        
        # 백엔드별 세션 수
        backend_sessions = {}
        for session in self.sessions.values():
            backend_id = session.backend_id
            backend_sessions[backend_id] = backend_sessions.get(backend_id, 0) + 1
        
        return {
            "total_sessions": total_sessions,
            "active_sessions": active_sessions,
            "expired_sessions": expired_sessions,
            "backend_sessions": backend_sessions
        }
```

## 🔧 **로드 밸런서 프록시**

### 📦 **HTTP 로드 밸런서 프록시**

```python
# load-balancing/proxy/http_load_balancer_proxy.py
import asyncio
import aiohttp
from aiohttp import web
from typing import Dict, List, Optional, Any
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

class HTTPLoadBalancerProxy:
    """HTTP 로드 밸런서 프록시"""
    
    def __init__(self, balancer, session_manager=None):
        self.balancer = balancer
        self.session_manager = session_manager
        self.app = web.Application()
        self.setup_routes()
        
        logger.info("Initialized HTTP load balancer proxy")
    
    def setup_routes(self):
        """라우트 설정"""
        self.app.router.add_route('*', '/{path:.*}', self.proxy_handler)
    
    async def proxy_handler(self, request: web.Request) -> web.Response:
        """프록시 핸들러"""
        try:
            # 백엔드 서버 선택
            backend = await self._select_backend(request)
            
            if not backend:
                return web.Response(
                    text="No healthy backend servers available",
                    status=503
                )
            
            # 요청 전달
            response = await self._forward_request(request, backend)
            
            # 연결 해제
            self.balancer.release_connection(backend.id)
            
            return response
            
        except Exception as e:
            logger.error(f"Proxy handler error: {e}")
            return web.Response(
                text="Internal server error",
                status=500
            )
    
    async def _select_backend(self, request: web.Request):
        """백엔드 서버 선택"""
        # 스티키 세션 확인
        if self.session_manager:
            session_id = request.cookies.get('session_id')
            if session_id:
                backend_id = self.session_manager.get_session_backend(session_id)
                if backend_id:
                    # 해당 백엔드 찾기
                    for backend in self.balancer.backends:
                        if backend.id == backend_id and backend.is_healthy:
                            backend.active_connections += 1
                            return backend
        
        # 일반적인 로드 밸런싱
        return self.balancer.get_next_backend()
    
    async def _forward_request(self, request: web.Request, backend) -> web.Response:
        """요청 전달"""
        try:
            # 요청 본문 읽기
            body = await request.read()
            
            # 헤더 준비
            headers = dict(request.headers)
            headers.pop('Host', None)  # Host 헤더 제거
            
            # URL 구성
            target_url = f"http://{backend.address}:{backend.port}{request.path_qs}"
            
            # HTTP 클라이언트로 요청 전달
            async with aiohttp.ClientSession() as session:
                async with session.request(
                    method=request.method,
                    url=target_url,
                    headers=headers,
                    data=body,
                    timeout=aiohttp.ClientTimeout(total=30)
                ) as response:
                    
                    # 응답 본문 읽기
                    response_body = await response.read()
                    
                    # 응답 생성
                    proxy_response = web.Response(
                        body=response_body,
                        status=response.status,
                        headers=response.headers
                    )
                    
                    # 스티키 세션 설정
                    if self.session_manager and not request.cookies.get('session_id'):
                        session_id = self.session_manager.create_session(
                            client_id=request.remote,
                            backend_id=backend.id
                        )
                        proxy_response.set_cookie('session_id', session_id, max_age=3600)
                    
                    return proxy_response
                    
        except Exception as e:
            logger.error(f"Request forwarding failed: {e}")
            raise
    
    async def start_server(self, host: str = '0.0.0.0', port: int = 8080):
        """서버 시작"""
        runner = web.AppRunner(self.app)
        await runner.setup()
        
        site = web.TCPSite(runner, host, port)
        await site.start()
        
        logger.info(f"Load balancer proxy started on {host}:{port}")
        
        # 헬스 체크 루프 시작
        asyncio.create_task(self.balancer.start_health_check_loop())
        
        # 세션 정리 루프 시작
        if self.session_manager:
            asyncio.create_task(self.session_manager.start_cleanup_loop())
        
        try:
            await asyncio.Future()  # 무한 대기
        except KeyboardInterrupt:
            logger.info("Shutting down load balancer proxy")
            await runner.cleanup()
```

## 🔧 **모니터링 및 메트릭**

### 📦 **로드 밸런서 모니터링**

```python
# load-balancing/monitoring/load_balancer_monitor.py
import asyncio
import time
from typing import Dict, List, Any
from dataclasses import dataclass
from datetime import datetime, timedelta
import logging

logger = logging.getLogger(__name__)

@dataclass
class LoadBalancerMetrics:
    """로드 밸런서 메트릭"""
    total_requests: int
    successful_requests: int
    failed_requests: int
    average_response_time: float
    requests_per_second: float
    active_connections: int
    timestamp: datetime

class LoadBalancerMonitor:
    """로드 밸런서 모니터링"""
    
    def __init__(self, balancer):
        self.balancer = balancer
        self.metrics_history = []
        self.request_count = 0
        self.successful_requests = 0
        self.failed_requests = 0
        self.total_response_time = 0.0
        self.start_time = datetime.now()
        
        logger.info("Initialized load balancer monitor")
    
    def record_request(self, success: bool, response_time: float):
        """요청 기록"""
        self.request_count += 1
        
        if success:
            self.successful_requests += 1
        else:
            self.failed_requests += 1
        
        self.total_response_time += response_time
    
    def get_current_metrics(self) -> LoadBalancerMetrics:
        """현재 메트릭 조회"""
        uptime = (datetime.now() - self.start_time).total_seconds()
        requests_per_second = self.request_count / uptime if uptime > 0 else 0
        average_response_time = self.total_response_time / self.request_count if self.request_count > 0 else 0
        
        backend_stats = self.balancer.get_backend_stats()
        active_connections = backend_stats.get('total_connections', 0)
        
        metrics = LoadBalancerMetrics(
            total_requests=self.request_count,
            successful_requests=self.successful_requests,
            failed_requests=self.failed_requests,
            average_response_time=average_response_time,
            requests_per_second=requests_per_second,
            active_connections=active_connections,
            timestamp=datetime.now()
        )
        
        # 메트릭 히스토리에 추가
        self.metrics_history.append(metrics)
        
        # 1시간 이전 데이터 제거
        cutoff_time = datetime.now() - timedelta(hours=1)
        self.metrics_history = [
            m for m in self.metrics_history
            if m.timestamp > cutoff_time
        ]
        
        return metrics
    
    def get_metrics_summary(self) -> Dict[str, Any]:
        """메트릭 요약"""
        current_metrics = self.get_current_metrics()
        backend_stats = self.balancer.get_backend_stats()
        
        return {
            "load_balancer": {
                "total_requests": current_metrics.total_requests,
                "successful_requests": current_metrics.successful_requests,
                "failed_requests": current_metrics.failed_requests,
                "success_rate": (current_metrics.successful_requests / current_metrics.total_requests * 100) if current_metrics.total_requests > 0 else 0,
                "average_response_time_ms": current_metrics.average_response_time,
                "requests_per_second": current_metrics.requests_per_second,
                "active_connections": current_metrics.active_connections,
                "uptime_seconds": (datetime.now() - self.start_time).total_seconds()
            },
            "backends": backend_stats,
            "session_stats": self.balancer.session_manager.get_session_stats() if hasattr(self.balancer, 'session_manager') and self.balancer.session_manager else {}
        }
    
    async def start_monitoring_loop(self, interval: int = 60):
        """모니터링 루프 시작"""
        while True:
            try:
                metrics = self.get_current_metrics()
                
                # 메트릭 로깅
                logger.info(f"Load balancer metrics: {metrics.requests_per_second:.2f} RPS, "
                          f"{metrics.average_response_time:.2f}ms avg response time, "
                          f"{metrics.active_connections} active connections")
                
                # 알림 체크
                await self._check_alerts(metrics)
                
                await asyncio.sleep(interval)
                
            except Exception as e:
                logger.error(f"Monitoring loop error: {e}")
                await asyncio.sleep(interval)
    
    async def _check_alerts(self, metrics: LoadBalancerMetrics):
        """알림 체크"""
        # 높은 응답 시간 알림
        if metrics.average_response_time > 1000:  # 1초 이상
            logger.warning(f"High average response time: {metrics.average_response_time:.2f}ms")
        
        # 높은 실패율 알림
        if metrics.total_requests > 0:
            failure_rate = (metrics.failed_requests / metrics.total_requests) * 100
            if failure_rate > 5:  # 5% 이상
                logger.warning(f"High failure rate: {failure_rate:.2f}%")
        
        # 백엔드 서버 부족 알림
        backend_stats = self.balancer.get_backend_stats()
        if backend_stats['healthy_backends'] == 0:
            logger.error("No healthy backend servers available")
```

## 🎯 **다음 단계**

### 📋 **완료된 작업**
- ✅ 라운드 로빈 로드 밸런서
- ✅ 최소 연결 로드 밸런서
- ✅ 가중치 기반 로드 밸런서
- ✅ 스티키 세션 관리
- ✅ HTTP 로드 밸런서 프록시
- ✅ 로드 밸런서 모니터링

### 🔄 **진행 중인 작업**
- 🔄 모니터링 시스템
- 🔄 장애 복구 시스템
- 🔄 성능 최적화

### ⏳ **다음 단계**
1. **Phase 2.4 모니터링** 문서 생성
2. **Phase 2.5 장애 복구** 문서 생성
3. **Phase 2.6 성능 최적화** 문서 생성

---

**마지막 업데이트**: 2024-01-31
**다음 업데이트**: 2024-02-01 (Phase 2.4 모니터링)
**로드 밸런싱 목표**: < 50ms 응답시간, 10,000 RPS, 99.99% 가용성
**장애 복구**: < 10초 자동 장애 조치 