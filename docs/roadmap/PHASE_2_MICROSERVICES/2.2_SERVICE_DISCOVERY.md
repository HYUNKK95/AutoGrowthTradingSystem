# 🔍 Phase 2.2: 서비스 디스커버리 및 레지스트리

## 📋 **개요**

### 🎯 **목표**
- **동적 서비스 등록**: 서비스 자동 등록 및 해제
- **헬스 체크**: 서비스 상태 실시간 모니터링
- **로드 밸런싱**: 서비스 인스턴스 간 부하 분산
- **장애 감지**: 서비스 장애 자동 감지 및 복구

### 📊 **성능 목표**
- **서비스 등록 시간**: < 5초
- **서비스 해제 시간**: < 3초
- **헬스 체크 간격**: 10초
- **장애 감지 시간**: < 30초
- **서비스 조회 시간**: < 100ms

## 🏗️ **서비스 디스커버리 아키텍처**

### 📁 **서비스 디스커버리 구조**
```
service-discovery/
├── registry/                      # 서비스 레지스트리
│   ├── consul/                   # Consul 기반 레지스트리
│   ├── etcd/                     # etcd 기반 레지스트리
│   └── custom/                   # 커스텀 레지스트리
├── health-check/                 # 헬스 체크 시스템
│   ├── http-health/              # HTTP 헬스 체크
│   ├── tcp-health/               # TCP 헬스 체크
│   └── custom-health/            # 커스텀 헬스 체크
├── load-balancer/                # 로드 밸런서
│   ├── round-robin/              # 라운드 로빈
│   ├── least-connections/        # 최소 연결
│   └── weighted/                 # 가중치 기반
└── monitoring/                   # 모니터링
    ├── metrics/                  # 메트릭 수집
    ├── alerts/                   # 알림 시스템
    └── dashboard/                # 대시보드
```

## 🔧 **Consul 기반 서비스 레지스트리**

### 📦 **Consul 설정**

```yaml
# service-discovery/registry/consul/consul-config.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: consul-config
  namespace: trading-system
data:
  consul.json: |
    {
      "datacenter": "trading-dc",
      "data_dir": "/consul/data",
      "log_level": "INFO",
      "node_name": "consul-server",
      "server": true,
      "bootstrap_expect": 3,
      "client_addr": "0.0.0.0",
      "bind_addr": "0.0.0.0",
      "advertise_addr": "{{ GetPrivateIP }}",
      "retry_join": [
        "consul-server-0.consul-service.trading-system.svc.cluster.local",
        "consul-server-1.consul-service.trading-system.svc.cluster.local",
        "consul-server-2.consul-service.trading-system.svc.cluster.local"
      ],
      "ui_config": {
        "enabled": true
      },
      "connect": {
        "enabled": true
      },
      "ports": {
        "dns": 8600,
        "http": 8500,
        "https": -1,
        "grpc": 8502
      }
    }

---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: consul-server
  namespace: trading-system
spec:
  serviceName: consul-service
  replicas: 3
  selector:
    matchLabels:
      app: consul-server
  template:
    metadata:
      labels:
        app: consul-server
    spec:
      containers:
      - name: consul
        image: consul:1.15
        ports:
        - containerPort: 8500
          name: http
        - containerPort: 8600
          name: dns
        - containerPort: 8502
          name: grpc
        volumeMounts:
        - name: consul-config
          mountPath: /consul/config
        - name: consul-data
          mountPath: /consul/data
        command:
        - consul
        - agent
        - -config-file=/consul/config/consul.json
        resources:
          requests:
            memory: "256Mi"
            cpu: "250m"
          limits:
            memory: "512Mi"
            cpu: "500m"
      volumes:
      - name: consul-config
        configMap:
          name: consul-config

---
apiVersion: v1
kind: Service
metadata:
  name: consul-service
  namespace: trading-system
spec:
  selector:
    app: consul-server
  ports:
  - port: 8500
    targetPort: 8500
    name: http
  - port: 8600
    targetPort: 8600
    name: dns
  - port: 8502
    targetPort: 8502
    name: grpc
  type: ClusterIP
```

### 🔧 **서비스 레지스트리 매니저**

```python
# service-discovery/registry/consul/service_registry.py
import asyncio
import aiohttp
import json
from typing import Dict, List, Optional, Any
from datetime import datetime, timedelta
from dataclasses import dataclass
import logging

logger = logging.getLogger(__name__)

@dataclass
class ServiceInstance:
    """서비스 인스턴스"""
    id: str
    service_name: str
    address: str
    port: int
    tags: List[str]
    meta: Dict[str, str]
    status: str  # passing, warning, critical
    last_check: datetime
    created_at: datetime

@dataclass
class ServiceHealth:
    """서비스 헬스 정보"""
    service_id: str
    status: str
    output: str
    last_check: datetime
    check_id: str

class ConsulServiceRegistry:
    """Consul 기반 서비스 레지스트리"""
    
    def __init__(self, consul_url: str = "http://consul-service:8500"):
        self.consul_url = consul_url
        self.session = None
        self.services_cache = {}
        self.cache_ttl = 30  # 30초 캐시
        self.last_cache_update = None
        
        logger.info(f"Initialized Consul service registry: {consul_url}")
    
    async def initialize(self):
        """초기화"""
        try:
            self.session = aiohttp.ClientSession()
            
            # Consul 연결 테스트
            async with self.session.get(f"{self.consul_url}/v1/status/leader") as response:
                if response.status == 200:
                    leader = await response.text()
                    logger.info(f"Connected to Consul cluster, leader: {leader}")
                else:
                    raise Exception(f"Failed to connect to Consul: {response.status}")
                    
        except Exception as e:
            logger.error(f"Failed to initialize Consul registry: {e}")
            raise
    
    async def register_service(self, service_name: str, service_id: str, 
                             address: str, port: int, tags: List[str] = None,
                             meta: Dict[str, str] = None) -> bool:
        """서비스 등록"""
        try:
            registration_data = {
                "ID": service_id,
                "Name": service_name,
                "Address": address,
                "Port": port,
                "Tags": tags or [],
                "Meta": meta or {},
                "Check": {
                    "HTTP": f"http://{address}:{port}/health",
                    "Interval": "10s",
                    "Timeout": "5s",
                    "DeregisterCriticalServiceAfter": "30s"
                }
            }
            
            async with self.session.put(
                f"{self.consul_url}/v1/agent/service/register",
                json=registration_data
            ) as response:
                if response.status == 200:
                    logger.info(f"Registered service: {service_name} ({service_id})")
                    await self._invalidate_cache()
                    return True
                else:
                    error_text = await response.text()
                    logger.error(f"Failed to register service: {error_text}")
                    return False
                    
        except Exception as e:
            logger.error(f"Service registration failed: {e}")
            return False
    
    async def deregister_service(self, service_id: str) -> bool:
        """서비스 해제"""
        try:
            async with self.session.put(
                f"{self.consul_url}/v1/agent/service/deregister/{service_id}"
            ) as response:
                if response.status == 200:
                    logger.info(f"Deregistered service: {service_id}")
                    await self._invalidate_cache()
                    return True
                else:
                    error_text = await response.text()
                    logger.error(f"Failed to deregister service: {error_text}")
                    return False
                    
        except Exception as e:
            logger.error(f"Service deregistration failed: {e}")
            return False
    
    async def get_service_instances(self, service_name: str) -> List[ServiceInstance]:
        """서비스 인스턴스 조회"""
        try:
            # 캐시 확인
            if self._is_cache_valid():
                if service_name in self.services_cache:
                    return self.services_cache[service_name]
            
            async with self.session.get(
                f"{self.consul_url}/v1/health/service/{service_name}"
            ) as response:
                if response.status == 200:
                    data = await response.json()
                    instances = []
                    
                    for service_data in data:
                        service = service_data['Service']
                        checks = service_data['Checks']
                        
                        # 헬스 체크 상태 확인
                        status = "critical"
                        for check in checks:
                            if check['CheckID'] == f"service:{service['ID']}":
                                status = check['Status']
                                break
                        
                        instance = ServiceInstance(
                            id=service['ID'],
                            service_name=service['Service'],
                            address=service['Address'],
                            port=service['Port'],
                            tags=service.get('Tags', []),
                            meta=service.get('Meta', {}),
                            status=status,
                            last_check=datetime.now(),
                            created_at=datetime.now()
                        )
                        instances.append(instance)
                    
                    # 캐시 업데이트
                    self.services_cache[service_name] = instances
                    self.last_cache_update = datetime.now()
                    
                    return instances
                else:
                    logger.error(f"Failed to get service instances: {response.status}")
                    return []
                    
        except Exception as e:
            logger.error(f"Failed to get service instances: {e}")
            return []
    
    async def get_healthy_instances(self, service_name: str) -> List[ServiceInstance]:
        """건강한 서비스 인스턴스 조회"""
        instances = await self.get_service_instances(service_name)
        return [instance for instance in instances if instance.status == "passing"]
    
    async def get_service_health(self, service_id: str) -> Optional[ServiceHealth]:
        """서비스 헬스 정보 조회"""
        try:
            async with self.session.get(
                f"{self.consul_url}/v1/health/checks/{service_id}"
            ) as response:
                if response.status == 200:
                    checks = await response.json()
                    
                    for check in checks:
                        if check['CheckID'] == f"service:{service_id}":
                            return ServiceHealth(
                                service_id=service_id,
                                status=check['Status'],
                                output=check.get('Output', ''),
                                last_check=datetime.fromisoformat(check['LastUpdate'].replace('Z', '+00:00')),
                                check_id=check['CheckID']
                            )
                    
                    return None
                else:
                    logger.error(f"Failed to get service health: {response.status}")
                    return None
                    
        except Exception as e:
            logger.error(f"Failed to get service health: {e}")
            return None
    
    async def list_services(self) -> List[str]:
        """등록된 서비스 목록 조회"""
        try:
            async with self.session.get(
                f"{self.consul_url}/v1/catalog/services"
            ) as response:
                if response.status == 200:
                    services = await response.json()
                    return list(services.keys())
                else:
                    logger.error(f"Failed to list services: {response.status}")
                    return []
                    
        except Exception as e:
            logger.error(f"Failed to list services: {e}")
            return []
    
    def _is_cache_valid(self) -> bool:
        """캐시 유효성 확인"""
        if not self.last_cache_update:
            return False
        
        return (datetime.now() - self.last_cache_update).seconds < self.cache_ttl
    
    async def _invalidate_cache(self):
        """캐시 무효화"""
        self.services_cache.clear()
        self.last_cache_update = None
    
    async def close(self):
        """세션 종료"""
        if self.session:
            await self.session.close()
            logger.info("Closed Consul service registry session")
```

## 🔧 **헬스 체크 시스템**

### 📦 **HTTP 헬스 체크**

```python
# service-discovery/health-check/http-health/health_checker.py
import asyncio
import aiohttp
from typing import Dict, List, Optional, Any
from datetime import datetime, timedelta
from dataclasses import dataclass
import logging

logger = logging.getLogger(__name__)

@dataclass
class HealthCheckResult:
    """헬스 체크 결과"""
    service_id: str
    status: str  # healthy, unhealthy, unknown
    response_time: float
    last_check: datetime
    error_message: Optional[str] = None
    details: Dict[str, Any] = None

class HTTPHealthChecker:
    """HTTP 헬스 체크"""
    
    def __init__(self):
        self.session = None
        self.check_results = {}
        self.check_interval = 10  # 10초
        self.timeout = 5  # 5초
        
        logger.info("Initialized HTTP health checker")
    
    async def initialize(self):
        """초기화"""
        self.session = aiohttp.ClientSession()
    
    async def check_service_health(self, service_id: str, health_url: str) -> HealthCheckResult:
        """서비스 헬스 체크"""
        start_time = datetime.now()
        
        try:
            async with self.session.get(
                health_url,
                timeout=aiohttp.ClientTimeout(total=self.timeout)
            ) as response:
                response_time = (datetime.now() - start_time).total_seconds()
                
                if response.status == 200:
                    result = HealthCheckResult(
                        service_id=service_id,
                        status="healthy",
                        response_time=response_time,
                        last_check=datetime.now(),
                        details={
                            "status_code": response.status,
                            "content_length": len(await response.text())
                        }
                    )
                else:
                    result = HealthCheckResult(
                        service_id=service_id,
                        status="unhealthy",
                        response_time=response_time,
                        last_check=datetime.now(),
                        error_message=f"HTTP {response.status}",
                        details={"status_code": response.status}
                    )
                
                self.check_results[service_id] = result
                return result
                
        except asyncio.TimeoutError:
            result = HealthCheckResult(
                service_id=service_id,
                status="unhealthy",
                response_time=(datetime.now() - start_time).total_seconds(),
                last_check=datetime.now(),
                error_message="Timeout",
                details={"timeout": self.timeout}
            )
            self.check_results[service_id] = result
            return result
            
        except Exception as e:
            result = HealthCheckResult(
                service_id=service_id,
                status="unknown",
                response_time=(datetime.now() - start_time).total_seconds(),
                last_check=datetime.now(),
                error_message=str(e)
            )
            self.check_results[service_id] = result
            return result
    
    async def start_health_check_loop(self, services: Dict[str, str]):
        """헬스 체크 루프 시작"""
        while True:
            try:
                # 모든 서비스 헬스 체크
                tasks = []
                for service_id, health_url in services.items():
                    task = self.check_service_health(service_id, health_url)
                    tasks.append(task)
                
                results = await asyncio.gather(*tasks, return_exceptions=True)
                
                # 결과 로깅
                for result in results:
                    if isinstance(result, HealthCheckResult):
                        if result.status == "unhealthy":
                            logger.warning(f"Service {result.service_id} is unhealthy: {result.error_message}")
                        elif result.status == "unknown":
                            logger.error(f"Service {result.service_id} health check failed: {result.error_message}")
                
                await asyncio.sleep(self.check_interval)
                
            except Exception as e:
                logger.error(f"Health check loop error: {e}")
                await asyncio.sleep(self.check_interval)
    
    def get_service_health(self, service_id: str) -> Optional[HealthCheckResult]:
        """서비스 헬스 상태 조회"""
        return self.check_results.get(service_id)
    
    def get_all_health_status(self) -> Dict[str, HealthCheckResult]:
        """모든 서비스 헬스 상태 조회"""
        return self.check_results.copy()
    
    async def close(self):
        """세션 종료"""
        if self.session:
            await self.session.close()
            logger.info("Closed HTTP health checker session")
```

### 📦 **커스텀 헬스 체크**

```python
# service-discovery/health-check/custom-health/custom_health_checker.py
import asyncio
import psutil
import os
from typing import Dict, List, Optional, Any, Callable
from datetime import datetime
from dataclasses import dataclass
import logging

logger = logging.getLogger(__name__)

@dataclass
class CustomHealthCheck:
    """커스텀 헬스 체크"""
    name: str
    check_function: Callable
    interval: int
    timeout: int
    critical: bool = True

class CustomHealthChecker:
    """커스텀 헬스 체크"""
    
    def __init__(self):
        self.health_checks = {}
        self.check_results = {}
        
        logger.info("Initialized custom health checker")
    
    def add_health_check(self, check: CustomHealthCheck):
        """헬스 체크 추가"""
        self.health_checks[check.name] = check
        logger.info(f"Added health check: {check.name}")
    
    async def run_health_check(self, check_name: str) -> Dict[str, Any]:
        """헬스 체크 실행"""
        check = self.health_checks.get(check_name)
        if not check:
            return {"status": "unknown", "error": "Check not found"}
        
        try:
            # 비동기 함수인지 확인
            if asyncio.iscoroutinefunction(check.check_function):
                result = await asyncio.wait_for(
                    check.check_function(),
                    timeout=check.timeout
                )
            else:
                # 동기 함수를 비동기로 실행
                loop = asyncio.get_event_loop()
                result = await asyncio.wait_for(
                    loop.run_in_executor(None, check.check_function),
                    timeout=check.timeout
                )
            
            self.check_results[check_name] = {
                "status": "healthy",
                "result": result,
                "last_check": datetime.now()
            }
            
            return self.check_results[check_name]
            
        except asyncio.TimeoutError:
            result = {
                "status": "unhealthy",
                "error": "Timeout",
                "last_check": datetime.now()
            }
            self.check_results[check_name] = result
            return result
            
        except Exception as e:
            result = {
                "status": "unhealthy",
                "error": str(e),
                "last_check": datetime.now()
            }
            self.check_results[check_name] = result
            return result
    
    async def run_all_health_checks(self) -> Dict[str, Dict[str, Any]]:
        """모든 헬스 체크 실행"""
        tasks = []
        for check_name in self.health_checks.keys():
            task = self.run_health_check(check_name)
            tasks.append(task)
        
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        all_results = {}
        for i, (check_name, result) in enumerate(zip(self.health_checks.keys(), results)):
            if isinstance(result, Exception):
                all_results[check_name] = {
                    "status": "unhealthy",
                    "error": str(result),
                    "last_check": datetime.now()
                }
            else:
                all_results[check_name] = result
        
        return all_results
    
    async def start_health_check_loop(self):
        """헬스 체크 루프 시작"""
        while True:
            try:
                await self.run_all_health_checks()
                
                # 결과 로깅
                for check_name, result in self.check_results.items():
                    if result["status"] == "unhealthy":
                        logger.warning(f"Health check {check_name} failed: {result.get('error', 'Unknown error')}")
                
                # 가장 긴 간격으로 대기
                min_interval = min(check.interval for check in self.health_checks.values())
                await asyncio.sleep(min_interval)
                
            except Exception as e:
                logger.error(f"Health check loop error: {e}")
                await asyncio.sleep(10)
    
    def get_health_status(self, check_name: str) -> Optional[Dict[str, Any]]:
        """헬스 체크 상태 조회"""
        return self.check_results.get(check_name)
    
    def get_all_health_status(self) -> Dict[str, Dict[str, Any]]:
        """모든 헬스 체크 상태 조회"""
        return self.check_results.copy()

# 기본 헬스 체크 함수들
def check_disk_usage():
    """디스크 사용량 체크"""
    disk_usage = psutil.disk_usage('/')
    usage_percent = disk_usage.percent
    
    if usage_percent > 90:
        raise Exception(f"Disk usage too high: {usage_percent}%")
    
    return {
        "disk_usage_percent": usage_percent,
        "free_space_gb": disk_usage.free / (1024**3)
    }

def check_memory_usage():
    """메모리 사용량 체크"""
    memory = psutil.virtual_memory()
    usage_percent = memory.percent
    
    if usage_percent > 95:
        raise Exception(f"Memory usage too high: {usage_percent}%")
    
    return {
        "memory_usage_percent": usage_percent,
        "available_memory_gb": memory.available / (1024**3)
    }

def check_cpu_usage():
    """CPU 사용량 체크"""
    cpu_percent = psutil.cpu_percent(interval=1)
    
    if cpu_percent > 90:
        raise Exception(f"CPU usage too high: {cpu_percent}%")
    
    return {
        "cpu_usage_percent": cpu_percent,
        "cpu_count": psutil.cpu_count()
    }

async def check_database_connection():
    """데이터베이스 연결 체크"""
    # 실제 구현에서는 데이터베이스 연결 테스트
    await asyncio.sleep(0.1)  # 시뮬레이션
    return {"database_status": "connected"}

async def check_external_api():
    """외부 API 체크"""
    # 실제 구현에서는 외부 API 호출 테스트
    await asyncio.sleep(0.1)  # 시뮬레이션
    return {"api_status": "available"}
```

## 🔧 **서비스 디스커버리 클라이언트**

### 📦 **서비스 디스커버리 클라이언트**

```python
# service-discovery/client/service_discovery_client.py
import asyncio
import random
from typing import Dict, List, Optional, Any
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

class ServiceDiscoveryClient:
    """서비스 디스커버리 클라이언트"""
    
    def __init__(self, registry: ConsulServiceRegistry):
        self.registry = registry
        self.service_cache = {}
        self.cache_ttl = 60  # 60초
        self.last_cache_update = {}
        
        logger.info("Initialized service discovery client")
    
    async def get_service_url(self, service_name: str, 
                            load_balancing_strategy: str = "round_robin") -> Optional[str]:
        """서비스 URL 조회"""
        try:
            instances = await self.registry.get_healthy_instances(service_name)
            
            if not instances:
                logger.warning(f"No healthy instances found for service: {service_name}")
                return None
            
            # 로드 밸런싱 전략 적용
            selected_instance = self._select_instance(instances, load_balancing_strategy)
            
            if selected_instance:
                service_url = f"http://{selected_instance.address}:{selected_instance.port}"
                logger.debug(f"Selected service URL: {service_url}")
                return service_url
            
            return None
            
        except Exception as e:
            logger.error(f"Failed to get service URL: {e}")
            return None
    
    async def get_service_urls(self, service_name: str) -> List[str]:
        """모든 서비스 URL 조회"""
        try:
            instances = await self.registry.get_healthy_instances(service_name)
            
            urls = []
            for instance in instances:
                url = f"http://{instance.address}:{instance.port}"
                urls.append(url)
            
            return urls
            
        except Exception as e:
            logger.error(f"Failed to get service URLs: {e}")
            return []
    
    def _select_instance(self, instances: List[ServiceInstance], 
                        strategy: str) -> Optional[ServiceInstance]:
        """인스턴스 선택"""
        if not instances:
            return None
        
        if strategy == "round_robin":
            return self._round_robin_select(instances)
        elif strategy == "random":
            return self._random_select(instances)
        elif strategy == "least_connections":
            return self._least_connections_select(instances)
        else:
            # 기본값은 라운드 로빈
            return self._round_robin_select(instances)
    
    def _round_robin_select(self, instances: List[ServiceInstance]) -> ServiceInstance:
        """라운드 로빈 선택"""
        # 간단한 구현 (실제로는 더 정교한 로직 필요)
        return instances[0]
    
    def _random_select(self, instances: List[ServiceInstance]) -> ServiceInstance:
        """랜덤 선택"""
        return random.choice(instances)
    
    def _least_connections_select(self, instances: List[ServiceInstance]) -> ServiceInstance:
        """최소 연결 선택"""
        # 실제 구현에서는 연결 수 정보 필요
        return instances[0]
    
    async def register_service(self, service_name: str, service_id: str,
                             address: str, port: int, tags: List[str] = None,
                             meta: Dict[str, str] = None) -> bool:
        """서비스 등록"""
        try:
            success = await self.registry.register_service(
                service_name, service_id, address, port, tags, meta
            )
            
            if success:
                logger.info(f"Successfully registered service: {service_name} ({service_id})")
            else:
                logger.error(f"Failed to register service: {service_name} ({service_id})")
            
            return success
            
        except Exception as e:
            logger.error(f"Service registration failed: {e}")
            return False
    
    async def deregister_service(self, service_id: str) -> bool:
        """서비스 해제"""
        try:
            success = await self.registry.deregister_service(service_id)
            
            if success:
                logger.info(f"Successfully deregistered service: {service_id}")
            else:
                logger.error(f"Failed to deregister service: {service_id}")
            
            return success
            
        except Exception as e:
            logger.error(f"Service deregistration failed: {e}")
            return False
    
    async def get_service_health(self, service_name: str) -> Dict[str, Any]:
        """서비스 헬스 정보 조회"""
        try:
            instances = await self.registry.get_service_instances(service_name)
            
            health_info = {
                "service_name": service_name,
                "total_instances": len(instances),
                "healthy_instances": len([i for i in instances if i.status == "passing"]),
                "unhealthy_instances": len([i for i in instances if i.status != "passing"]),
                "instances": []
            }
            
            for instance in instances:
                health = await self.registry.get_service_health(instance.id)
                instance_info = {
                    "id": instance.id,
                    "address": instance.address,
                    "port": instance.port,
                    "status": instance.status,
                    "last_check": instance.last_check.isoformat(),
                    "health_details": health.__dict__ if health else None
                }
                health_info["instances"].append(instance_info)
            
            return health_info
            
        except Exception as e:
            logger.error(f"Failed to get service health: {e}")
            return {}
    
    async def list_all_services(self) -> List[str]:
        """모든 서비스 목록 조회"""
        try:
            return await self.registry.list_services()
        except Exception as e:
            logger.error(f"Failed to list services: {e}")
            return []
```

## 🎯 **다음 단계**

### 📋 **완료된 작업**
- ✅ Consul 기반 서비스 레지스트리
- ✅ HTTP 헬스 체크 시스템
- ✅ 커스텀 헬스 체크 시스템
- ✅ 서비스 디스커버리 클라이언트

### 🔄 **진행 중인 작업**
- 🔄 로드 밸런싱 구현
- 🔄 모니터링 시스템
- 🔄 장애 복구 시스템

### ⏳ **다음 단계**
1. **Phase 2.3 로드 밸런싱** 문서 생성
2. **Phase 2.4 모니터링** 문서 생성
3. **Phase 2.5 장애 복구** 문서 생성

---

**마지막 업데이트**: 2024-01-31
**다음 업데이트**: 2024-02-01 (Phase 2.3 로드 밸런싱)
**서비스 디스커버리 목표**: < 5초 등록, < 3초 해제, < 100ms 조회
**헬스 체크**: 10초 간격, < 30초 장애 감지 