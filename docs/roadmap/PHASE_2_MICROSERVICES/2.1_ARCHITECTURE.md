# ğŸ—ï¸ Phase 2.1: ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ì•„í‚¤í…ì²˜ ì„¤ê³„

## ğŸ“‹ **ê°œìš”**

### ğŸ¯ **ëª©í‘œ**
- ëª¨ë†€ë¦¬ì‹ ì•„í‚¤í…ì²˜ì—ì„œ ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ì•„í‚¤í…ì²˜ë¡œ ì „í™˜
- ì„œë¹„ìŠ¤ ê°„ ëŠìŠ¨í•œ ê²°í•© ë° ë…ë¦½ì  ë°°í¬ ê°€ëŠ¥í•œ êµ¬ì¡° êµ¬ì¶•
- í™•ì¥ì„±ê³¼ ìœ ì§€ë³´ìˆ˜ì„± í–¥ìƒ

### ğŸ“… **ê¸°ê°„**
- **ì‹œì‘ì¼**: 2025-04-01
- **ì™„ë£Œì¼**: 2025-04-15 (15ì¼)
- **ìƒíƒœ**: ë¬¸ì„œí™” ì™„ë£Œ âœ…

### ğŸ“Š **ì§„í–‰ë¥ **
- **ë¬¸ì„œí™”**: 100% âœ…
- **ì‹¤ì œ ê°œë°œ**: 0% â³ (ì‹œì‘ ì „)

## ğŸ›ï¸ **ì•„í‚¤í…ì²˜ ê°œìš”**

### ğŸ”„ **ì „í™˜ ì „í›„ ë¹„êµ**

#### **í˜„ì¬ ìƒíƒœ (ëª¨ë†€ë¦¬ì‹)**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           AutoGrowthTrading         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ Trading â”‚  User   â”‚  Order  â”‚    â”‚
â”‚  â”‚ Service â”‚ Service â”‚ Service â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚  Risk   â”‚  Data   â”‚  API    â”‚    â”‚
â”‚  â”‚ Service â”‚ Service â”‚ Gateway â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

#### **ëª©í‘œ ìƒíƒœ (ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤)**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    API Gateway                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚ Trading â”‚  User   â”‚  Order  â”‚  Risk   â”‚  Data   â”‚        â”‚
â”‚  â”‚ Service â”‚ Service â”‚ Service â”‚ Service â”‚ Service â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”‚
â”‚  â”‚  Auth   â”‚  Notif  â”‚  Audit  â”‚  Config â”‚  Health â”‚        â”‚
â”‚  â”‚ Service â”‚ Service â”‚ Service â”‚ Service â”‚ Service â”‚        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ—ï¸ **ì„œë¹„ìŠ¤ ë¶„ë¦¬ ì „ëµ**

### ğŸ“¦ **í•µì‹¬ ì„œë¹„ìŠ¤**

#### **1. Trading Service**
```python
# trading-service/main.py
from fastapi import FastAPI, HTTPException
from typing import Dict, List, Optional
from dataclasses import dataclass
from datetime import datetime
import asyncio
import logging

logger = logging.getLogger(__name__)

app = FastAPI(title="Trading Service", version="2.0.0")

@dataclass
class TradingConfig:
    """ê±°ë˜ ì„œë¹„ìŠ¤ ì„¤ì •"""
    service_name: str = "trading-service"
    version: str = "2.0.0"
    port: int = 8001
    max_orders_per_user: int = 100
    order_timeout: int = 30

class TradingService:
    """ê±°ë˜ ì„œë¹„ìŠ¤"""
    
    def __init__(self, config: TradingConfig):
        self.config = config
        self.active_orders = {}
        self.order_history = {}
        self.performance_metrics = {}
        
        logger.info(f"Trading service initialized: {config.service_name}")
    
    async def place_order(self, order_data: Dict) -> Dict:
        """ì£¼ë¬¸ ì‹¤í–‰"""
        try:
            # ì£¼ë¬¸ ê²€ì¦
            validated_order = await self._validate_order(order_data)
            
            # ì£¼ë¬¸ ì‹¤í–‰
            executed_order = await self._execute_order(validated_order)
            
            # ì´ë²¤íŠ¸ ë°œí–‰
            await self._publish_order_event(executed_order)
            
            return {
                'order_id': executed_order['order_id'],
                'status': 'executed',
                'timestamp': datetime.utcnow().isoformat()
            }
            
        except Exception as e:
            logger.error(f"Order placement failed: {e}")
            raise HTTPException(status_code=400, detail=str(e))
    
    async def get_order_status(self, order_id: str) -> Dict:
        """ì£¼ë¬¸ ìƒíƒœ ì¡°íšŒ"""
        if order_id in self.active_orders:
            return self.active_orders[order_id]
        elif order_id in self.order_history:
            return self.order_history[order_id]
        else:
            raise HTTPException(status_code=404, detail="Order not found")
    
    async def _validate_order(self, order_data: Dict) -> Dict:
        """ì£¼ë¬¸ ê²€ì¦"""
        # ì£¼ë¬¸ ë°ì´í„° ê²€ì¦ ë¡œì§
        required_fields = ['symbol', 'side', 'quantity', 'price']
        for field in required_fields:
            if field not in order_data:
                raise ValueError(f"Missing required field: {field}")
        
        return order_data
    
    async def _execute_order(self, order_data: Dict) -> Dict:
        """ì£¼ë¬¸ ì‹¤í–‰"""
        order_id = f"order_{int(datetime.utcnow().timestamp())}"
        
        executed_order = {
            'order_id': order_id,
            **order_data,
            'status': 'executed',
            'executed_at': datetime.utcnow().isoformat()
        }
        
        self.active_orders[order_id] = executed_order
        
        return executed_order
    
    async def _publish_order_event(self, order: Dict):
        """ì£¼ë¬¸ ì´ë²¤íŠ¸ ë°œí–‰"""
        # ë©”ì‹œì§€ íë¡œ ì´ë²¤íŠ¸ ë°œí–‰
        event = {
            'type': 'ORDER_EXECUTED',
            'data': order,
            'timestamp': datetime.utcnow().isoformat()
        }
        
        # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” Kafka/RabbitMQ ì‚¬ìš©
        logger.info(f"Order event published: {event}")

# ì„œë¹„ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
trading_service = TradingService(TradingConfig())

@app.post("/orders")
async def place_order(order_data: Dict):
    """ì£¼ë¬¸ ì‹¤í–‰ API"""
    return await trading_service.place_order(order_data)

@app.get("/orders/{order_id}")
async def get_order(order_id: str):
    """ì£¼ë¬¸ ì¡°íšŒ API"""
    return await trading_service.get_order_status(order_id)

@app.get("/health")
async def health_check():
    """í—¬ìŠ¤ ì²´í¬"""
    return {
        'service': 'trading-service',
        'status': 'healthy',
        'timestamp': datetime.utcnow().isoformat()
    }
```

#### **2. User Service**
```python
# user-service/main.py
from fastapi import FastAPI, HTTPException
from typing import Dict, List, Optional
from dataclasses import dataclass
from datetime import datetime
import asyncio
import logging

logger = logging.getLogger(__name__)

app = FastAPI(title="User Service", version="2.0.0")

@dataclass
class UserConfig:
    """ì‚¬ìš©ì ì„œë¹„ìŠ¤ ì„¤ì •"""
    service_name: str = "user-service"
    version: str = "2.0.0"
    port: int = 8002
    max_users: int = 10000

class UserService:
    """ì‚¬ìš©ì ì„œë¹„ìŠ¤"""
    
    def __init__(self, config: UserConfig):
        self.config = config
        self.users = {}
        self.user_sessions = {}
        
        logger.info(f"User service initialized: {config.service_name}")
    
    async def create_user(self, user_data: Dict) -> Dict:
        """ì‚¬ìš©ì ìƒì„±"""
        try:
            user_id = f"user_{int(datetime.utcnow().timestamp())}"
            
            user = {
                'user_id': user_id,
                **user_data,
                'created_at': datetime.utcnow().isoformat(),
                'status': 'active'
            }
            
            self.users[user_id] = user
            
            # ì´ë²¤íŠ¸ ë°œí–‰
            await self._publish_user_event('USER_CREATED', user)
            
            return user
            
        except Exception as e:
            logger.error(f"User creation failed: {e}")
            raise HTTPException(status_code=400, detail=str(e))
    
    async def get_user(self, user_id: str) -> Dict:
        """ì‚¬ìš©ì ì¡°íšŒ"""
        if user_id not in self.users:
            raise HTTPException(status_code=404, detail="User not found")
        
        return self.users[user_id]
    
    async def update_user(self, user_id: str, user_data: Dict) -> Dict:
        """ì‚¬ìš©ì ì •ë³´ ì—…ë°ì´íŠ¸"""
        if user_id not in self.users:
            raise HTTPException(status_code=404, detail="User not found")
        
        self.users[user_id].update(user_data)
        self.users[user_id]['updated_at'] = datetime.utcnow().isoformat()
        
        # ì´ë²¤íŠ¸ ë°œí–‰
        await self._publish_user_event('USER_UPDATED', self.users[user_id])
        
        return self.users[user_id]
    
    async def _publish_user_event(self, event_type: str, user_data: Dict):
        """ì‚¬ìš©ì ì´ë²¤íŠ¸ ë°œí–‰"""
        event = {
            'type': event_type,
            'data': user_data,
            'timestamp': datetime.utcnow().isoformat()
        }
        
        logger.info(f"User event published: {event}")

# ì„œë¹„ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
user_service = UserService(UserConfig())

@app.post("/users")
async def create_user(user_data: Dict):
    """ì‚¬ìš©ì ìƒì„± API"""
    return await user_service.create_user(user_data)

@app.get("/users/{user_id}")
async def get_user(user_id: str):
    """ì‚¬ìš©ì ì¡°íšŒ API"""
    return await user_service.get_user(user_id)

@app.put("/users/{user_id}")
async def update_user(user_id: str, user_data: Dict):
    """ì‚¬ìš©ì ì—…ë°ì´íŠ¸ API"""
    return await user_service.update_user(user_id, user_data)

@app.get("/health")
async def health_check():
    """í—¬ìŠ¤ ì²´í¬"""
    return {
        'service': 'user-service',
        'status': 'healthy',
        'timestamp': datetime.utcnow().isoformat()
    }
```

#### **3. Order Service**
```python
# order-service/main.py
from fastapi import FastAPI, HTTPException
from typing import Dict, List, Optional
from dataclasses import dataclass
from datetime import datetime
import asyncio
import logging

logger = logging.getLogger(__name__)

app = FastAPI(title="Order Service", version="2.0.0")

@dataclass
class OrderConfig:
    """ì£¼ë¬¸ ì„œë¹„ìŠ¤ ì„¤ì •"""
    service_name: str = "order-service"
    version: str = "2.0.0"
    port: int = 8003
    max_orders: int = 100000

class OrderService:
    """ì£¼ë¬¸ ì„œë¹„ìŠ¤"""
    
    def __init__(self, config: OrderConfig):
        self.config = config
        self.orders = {}
        self.order_queue = asyncio.Queue()
        
        logger.info(f"Order service initialized: {config.service_name}")
    
    async def create_order(self, order_data: Dict) -> Dict:
        """ì£¼ë¬¸ ìƒì„±"""
        try:
            order_id = f"order_{int(datetime.utcnow().timestamp())}"
            
            order = {
                'order_id': order_id,
                **order_data,
                'status': 'pending',
                'created_at': datetime.utcnow().isoformat()
            }
            
            self.orders[order_id] = order
            
            # ì£¼ë¬¸ íì— ì¶”ê°€
            await self.order_queue.put(order)
            
            # ì´ë²¤íŠ¸ ë°œí–‰
            await self._publish_order_event('ORDER_CREATED', order)
            
            return order
            
        except Exception as e:
            logger.error(f"Order creation failed: {e}")
            raise HTTPException(status_code=400, detail=str(e))
    
    async def get_order(self, order_id: str) -> Dict:
        """ì£¼ë¬¸ ì¡°íšŒ"""
        if order_id not in self.orders:
            raise HTTPException(status_code=404, detail="Order not found")
        
        return self.orders[order_id]
    
    async def update_order_status(self, order_id: str, status: str) -> Dict:
        """ì£¼ë¬¸ ìƒíƒœ ì—…ë°ì´íŠ¸"""
        if order_id not in self.orders:
            raise HTTPException(status_code=404, detail="Order not found")
        
        self.orders[order_id]['status'] = status
        self.orders[order_id]['updated_at'] = datetime.utcnow().isoformat()
        
        # ì´ë²¤íŠ¸ ë°œí–‰
        await self._publish_order_event('ORDER_STATUS_UPDATED', self.orders[order_id])
        
        return self.orders[order_id]
    
    async def _publish_order_event(self, event_type: str, order_data: Dict):
        """ì£¼ë¬¸ ì´ë²¤íŠ¸ ë°œí–‰"""
        event = {
            'type': event_type,
            'data': order_data,
            'timestamp': datetime.utcnow().isoformat()
        }
        
        logger.info(f"Order event published: {event}")

# ì„œë¹„ìŠ¤ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
order_service = OrderService(OrderConfig())

@app.post("/orders")
async def create_order(order_data: Dict):
    """ì£¼ë¬¸ ìƒì„± API"""
    return await order_service.create_order(order_data)

@app.get("/orders/{order_id}")
async def get_order(order_id: str):
    """ì£¼ë¬¸ ì¡°íšŒ API"""
    return await order_service.get_order(order_id)

@app.put("/orders/{order_id}/status")
async def update_order_status(order_id: str, status: str):
    """ì£¼ë¬¸ ìƒíƒœ ì—…ë°ì´íŠ¸ API"""
    return await order_service.update_order_status(order_id, status)

@app.get("/health")
async def health_check():
    """í—¬ìŠ¤ ì²´í¬"""
    return {
        'service': 'order-service',
        'status': 'healthy',
        'timestamp': datetime.utcnow().isoformat()
    }
```

### ğŸ”§ **ì§€ì› ì„œë¹„ìŠ¤**

#### **4. API Gateway**
```python
# api-gateway/main.py
from fastapi import FastAPI, HTTPException
from fastapi.middleware.cors import CORSMiddleware
from typing import Dict, List, Optional
from dataclasses import dataclass
from datetime import datetime
import httpx
import asyncio
import logging

logger = logging.getLogger(__name__)

app = FastAPI(title="API Gateway", version="2.0.0")

# CORS ì„¤ì •
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@dataclass
class ServiceConfig:
    """ì„œë¹„ìŠ¤ ì„¤ì •"""
    trading_service_url: str = "http://trading-service:8001"
    user_service_url: str = "http://user-service:8002"
    order_service_url: str = "http://order-service:8003"
    auth_service_url: str = "http://auth-service:8004"

class APIGateway:
    """API ê²Œì´íŠ¸ì›¨ì´"""
    
    def __init__(self, config: ServiceConfig):
        self.config = config
        self.http_client = httpx.AsyncClient()
        
        logger.info("API Gateway initialized")
    
    async def route_request(self, service: str, path: str, method: str, data: Dict = None) -> Dict:
        """ìš”ì²­ ë¼ìš°íŒ…"""
        try:
            service_url = getattr(self.config, f"{service}_service_url")
            url = f"{service_url}{path}"
            
            if method.upper() == "GET":
                response = await self.http_client.get(url)
            elif method.upper() == "POST":
                response = await self.http_client.post(url, json=data)
            elif method.upper() == "PUT":
                response = await self.http_client.put(url, json=data)
            elif method.upper() == "DELETE":
                response = await self.http_client.delete(url)
            else:
                raise HTTPException(status_code=405, detail="Method not allowed")
            
            response.raise_for_status()
            return response.json()
            
        except httpx.HTTPStatusError as e:
            logger.error(f"Service request failed: {e}")
            raise HTTPException(status_code=e.response.status_code, detail=str(e))
        except Exception as e:
            logger.error(f"Gateway error: {e}")
            raise HTTPException(status_code=500, detail="Internal server error")

# ê²Œì´íŠ¸ì›¨ì´ ì¸ìŠ¤í„´ìŠ¤ ìƒì„±
gateway = APIGateway(ServiceConfig())

# Trading Service ë¼ìš°íŒ…
@app.post("/api/trading/orders")
async def place_trading_order(order_data: Dict):
    """ê±°ë˜ ì£¼ë¬¸ API"""
    return await gateway.route_request("trading", "/orders", "POST", order_data)

@app.get("/api/trading/orders/{order_id}")
async def get_trading_order(order_id: str):
    """ê±°ë˜ ì£¼ë¬¸ ì¡°íšŒ API"""
    return await gateway.route_request("trading", f"/orders/{order_id}", "GET")

# User Service ë¼ìš°íŒ…
@app.post("/api/users")
async def create_user(user_data: Dict):
    """ì‚¬ìš©ì ìƒì„± API"""
    return await gateway.route_request("user", "/users", "POST", user_data)

@app.get("/api/users/{user_id}")
async def get_user(user_id: str):
    """ì‚¬ìš©ì ì¡°íšŒ API"""
    return await gateway.route_request("user", f"/users/{user_id}", "GET")

# Order Service ë¼ìš°íŒ…
@app.post("/api/orders")
async def create_order(order_data: Dict):
    """ì£¼ë¬¸ ìƒì„± API"""
    return await gateway.route_request("order", "/orders", "POST", order_data)

@app.get("/api/orders/{order_id}")
async def get_order(order_id: str):
    """ì£¼ë¬¸ ì¡°íšŒ API"""
    return await gateway.route_request("order", f"/orders/{order_id}", "GET")

@app.get("/health")
async def health_check():
    """í—¬ìŠ¤ ì²´í¬"""
    return {
        'service': 'api-gateway',
        'status': 'healthy',
        'timestamp': datetime.utcnow().isoformat()
    }
```

## ğŸ”„ **ì„œë¹„ìŠ¤ ê°„ í†µì‹ **

### ğŸ“¨ **ì´ë²¤íŠ¸ ê¸°ë°˜ í†µì‹ **
```python
# event-bus/main.py
import asyncio
import json
import logging
from typing import Dict, List, Callable
from dataclasses import dataclass
from datetime import datetime

logger = logging.getLogger(__name__)

@dataclass
class Event:
    """ì´ë²¤íŠ¸ ë°ì´í„° í´ë˜ìŠ¤"""
    type: str
    data: Dict
    timestamp: str
    source: str
    event_id: str

class EventBus:
    """ì´ë²¤íŠ¸ ë²„ìŠ¤"""
    
    def __init__(self):
        self.subscribers = {}
        self.event_history = []
        
        logger.info("Event bus initialized")
    
    async def publish_event(self, event: Event):
        """ì´ë²¤íŠ¸ ë°œí–‰"""
        try:
            # ì´ë²¤íŠ¸ íˆìŠ¤í† ë¦¬ì— ì €ì¥
            self.event_history.append(event)
            
            # êµ¬ë…ìë“¤ì—ê²Œ ì´ë²¤íŠ¸ ì „ì†¡
            if event.type in self.subscribers:
                for callback in self.subscribers[event.type]:
                    try:
                        await callback(event)
                    except Exception as e:
                        logger.error(f"Event callback failed: {e}")
            
            logger.info(f"Event published: {event.type}")
            
        except Exception as e:
            logger.error(f"Event publishing failed: {e}")
    
    def subscribe(self, event_type: str, callback: Callable):
        """ì´ë²¤íŠ¸ êµ¬ë…"""
        if event_type not in self.subscribers:
            self.subscribers[event_type] = []
        
        self.subscribers[event_type].append(callback)
        logger.info(f"Subscribed to event: {event_type}")
    
    def unsubscribe(self, event_type: str, callback: Callable):
        """ì´ë²¤íŠ¸ êµ¬ë… í•´ì œ"""
        if event_type in self.subscribers and callback in self.subscribers[event_type]:
            self.subscribers[event_type].remove(callback)
            logger.info(f"Unsubscribed from event: {event_type}")

# ì´ë²¤íŠ¸ ë²„ìŠ¤ ì¸ìŠ¤í„´ìŠ¤
event_bus = EventBus()

# ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ì˜ˆì‹œ
async def handle_order_created(event: Event):
    """ì£¼ë¬¸ ìƒì„± ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬"""
    logger.info(f"Handling order created event: {event.data}")
    
    # ì£¼ë¬¸ ìƒì„± ì‹œ í•„ìš”í•œ í›„ì† ì‘ì—…
    # ì˜ˆ: ì•Œë¦¼ ë°œì†¡, ë¡œê·¸ ê¸°ë¡ ë“±

async def handle_user_created(event: Event):
    """ì‚¬ìš©ì ìƒì„± ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬"""
    logger.info(f"Handling user created event: {event.data}")
    
    # ì‚¬ìš©ì ìƒì„± ì‹œ í•„ìš”í•œ í›„ì† ì‘ì—…
    # ì˜ˆ: í™˜ì˜ ì´ë©”ì¼ ë°œì†¡, ê¸°ë³¸ ì„¤ì • ìƒì„± ë“±

# ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ë“±ë¡
event_bus.subscribe("ORDER_CREATED", handle_order_created)
event_bus.subscribe("USER_CREATED", handle_user_created)
```

## ğŸ—„ï¸ **ë°ì´í„° ê´€ë¦¬**

### ğŸ“Š **ì„œë¹„ìŠ¤ë³„ ë°ì´í„°ë² ì´ìŠ¤**
```python
# database-config/microservices_db.py
from sqlalchemy import create_engine, Column, String, Integer, DateTime, JSON
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

Base = declarative_base()

# Trading Service Database
class TradingOrder(Base):
    __tablename__ = "trading_orders"
    
    id = Column(String, primary_key=True)
    user_id = Column(String, nullable=False)
    symbol = Column(String, nullable=False)
    side = Column(String, nullable=False)
    quantity = Column(Integer, nullable=False)
    price = Column(Integer, nullable=False)
    status = Column(String, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

# User Service Database
class User(Base):
    __tablename__ = "users"
    
    id = Column(String, primary_key=True)
    username = Column(String, unique=True, nullable=False)
    email = Column(String, unique=True, nullable=False)
    status = Column(String, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

# Order Service Database
class Order(Base):
    __tablename__ = "orders"
    
    id = Column(String, primary_key=True)
    user_id = Column(String, nullable=False)
    order_type = Column(String, nullable=False)
    status = Column(String, nullable=False)
    metadata = Column(JSON)
    created_at = Column(DateTime, default=datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)

# ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì„¤ì •
def create_database_engine(service_name: str):
    """ì„œë¹„ìŠ¤ë³„ ë°ì´í„°ë² ì´ìŠ¤ ì—”ì§„ ìƒì„±"""
    database_urls = {
        "trading-service": "postgresql://user:password@trading-db:5432/trading_db",
        "user-service": "postgresql://user:password@user-db:5432/user_db",
        "order-service": "postgresql://user:password@order-db:5432/order_db"
    }
    
    database_url = database_urls.get(service_name)
    if not database_url:
        raise ValueError(f"Unknown service: {service_name}")
    
    engine = create_engine(database_url)
    SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)
    
    return engine, SessionLocal

# ë°ì´í„°ë² ì´ìŠ¤ ë§ˆì´ê·¸ë ˆì´ì…˜
def run_migrations(service_name: str):
    """ë°ì´í„°ë² ì´ìŠ¤ ë§ˆì´ê·¸ë ˆì´ì…˜ ì‹¤í–‰"""
    engine, _ = create_database_engine(service_name)
    Base.metadata.create_all(bind=engine)
    logger.info(f"Database migrations completed for {service_name}")
```

## ğŸš€ **ë°°í¬ ë° ìš´ì˜**

### ğŸ³ **Docker Compose ì„¤ì •**
```yaml
# docker-compose.microservices.yml
version: '3.8'

services:
  # API Gateway
  api-gateway:
    build: ./api-gateway
    ports:
      - "8000:8000"
    environment:
      - TRADING_SERVICE_URL=http://trading-service:8001
      - USER_SERVICE_URL=http://user-service:8002
      - ORDER_SERVICE_URL=http://order-service:8003
    depends_on:
      - trading-service
      - user-service
      - order-service
    networks:
      - trading-network

  # Trading Service
  trading-service:
    build: ./trading-service
    ports:
      - "8001:8001"
    environment:
      - DATABASE_URL=postgresql://user:password@trading-db:5432/trading_db
      - REDIS_URL=redis://redis:6379
    depends_on:
      - trading-db
      - redis
    networks:
      - trading-network

  # User Service
  user-service:
    build: ./user-service
    ports:
      - "8002:8002"
    environment:
      - DATABASE_URL=postgresql://user:password@user-db:5432/user_db
      - REDIS_URL=redis://redis:6379
    depends_on:
      - user-db
      - redis
    networks:
      - trading-network

  # Order Service
  order-service:
    build: ./order-service
    ports:
      - "8003:8003"
    environment:
      - DATABASE_URL=postgresql://user:password@order-db:5432/order_db
      - REDIS_URL=redis://redis:6379
    depends_on:
      - order-db
      - redis
    networks:
      - trading-network

  # Event Bus
  event-bus:
    build: ./event-bus
    ports:
      - "8004:8004"
    environment:
      - REDIS_URL=redis://redis:6379
    depends_on:
      - redis
    networks:
      - trading-network

  # Databases
  trading-db:
    image: postgres:13
    environment:
      - POSTGRES_DB=trading_db
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
    volumes:
      - trading_data:/var/lib/postgresql/data
    networks:
      - trading-network

  user-db:
    image: postgres:13
    environment:
      - POSTGRES_DB=user_db
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
    volumes:
      - user_data:/var/lib/postgresql/data
    networks:
      - trading-network

  order-db:
    image: postgres:13
    environment:
      - POSTGRES_DB=order_db
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
    volumes:
      - order_data:/var/lib/postgresql/data
    networks:
      - trading-network

  # Redis
  redis:
    image: redis:6-alpine
    ports:
      - "6379:6379"
    networks:
      - trading-network

  # Monitoring
  prometheus:
    image: prom/prometheus
    ports:
      - "9090:9090"
    volumes:
      - ./monitoring/prometheus.yml:/etc/prometheus/prometheus.yml
    networks:
      - trading-network

  grafana:
    image: grafana/grafana
    ports:
      - "3000:3000"
    environment:
      - GF_SECURITY_ADMIN_PASSWORD=admin
    volumes:
      - grafana_data:/var/lib/grafana
    networks:
      - trading-network

volumes:
  trading_data:
  user_data:
  order_data:
  grafana_data:

networks:
  trading-network:
    driver: bridge
```

## ğŸ“Š **ëª¨ë‹ˆí„°ë§ ë° ê´€ì°°ì„±**

### ğŸ“ˆ **ë©”íŠ¸ë¦­ ìˆ˜ì§‘**
```python
# monitoring/metrics.py
from prometheus_client import Counter, Histogram, Gauge, generate_latest
from typing import Dict
import time

# ë©”íŠ¸ë¦­ ì •ì˜
REQUEST_COUNT = Counter('http_requests_total', 'Total HTTP requests', ['service', 'endpoint', 'method'])
REQUEST_DURATION = Histogram('http_request_duration_seconds', 'HTTP request duration', ['service', 'endpoint'])
ACTIVE_CONNECTIONS = Gauge('active_connections', 'Active connections', ['service'])
ERROR_COUNT = Counter('http_errors_total', 'Total HTTP errors', ['service', 'endpoint', 'error_type'])

class MetricsCollector:
    """ë©”íŠ¸ë¦­ ìˆ˜ì§‘ê¸°"""
    
    def __init__(self, service_name: str):
        self.service_name = service_name
    
    def record_request(self, endpoint: str, method: str, duration: float):
        """ìš”ì²­ ë©”íŠ¸ë¦­ ê¸°ë¡"""
        REQUEST_COUNT.labels(
            service=self.service_name,
            endpoint=endpoint,
            method=method
        ).inc()
        
        REQUEST_DURATION.labels(
            service=self.service_name,
            endpoint=endpoint
        ).observe(duration)
    
    def record_error(self, endpoint: str, error_type: str):
        """ì˜¤ë¥˜ ë©”íŠ¸ë¦­ ê¸°ë¡"""
        ERROR_COUNT.labels(
            service=self.service_name,
            endpoint=endpoint,
            error_type=error_type
        ).inc()
    
    def set_active_connections(self, count: int):
        """í™œì„± ì—°ê²° ìˆ˜ ì„¤ì •"""
        ACTIVE_CONNECTIONS.labels(service=self.service_name).set(count)
    
    def get_metrics(self):
        """ë©”íŠ¸ë¦­ ë°ì´í„° ë°˜í™˜"""
        return generate_latest()

# ë©”íŠ¸ë¦­ ìˆ˜ì§‘ê¸° ì¸ìŠ¤í„´ìŠ¤
metrics_collector = MetricsCollector("trading-service")
```

## ğŸ”§ **êµ¬í˜„ ì²´í¬ë¦¬ìŠ¤íŠ¸**

### âœ… **ì™„ë£Œëœ ì‘ì—…**
- [x] ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ì•„í‚¤í…ì²˜ ì„¤ê³„
- [x] ì„œë¹„ìŠ¤ ë¶„ë¦¬ ì „ëµ ìˆ˜ë¦½
- [x] API Gateway ì„¤ê³„
- [x] ì´ë²¤íŠ¸ ê¸°ë°˜ í†µì‹  ì„¤ê³„
- [x] ë°ì´í„°ë² ì´ìŠ¤ ë¶„ë¦¬ ì „ëµ
- [x] ëª¨ë‹ˆí„°ë§ ë° ê´€ì°°ì„± ì„¤ê³„
- [x] ë°°í¬ ë° ìš´ì˜ ì „ëµ

### ğŸ”„ **ë‹¤ìŒ ë‹¨ê³„**
- [ ] ì„œë¹„ìŠ¤ ë””ìŠ¤ì»¤ë²„ë¦¬ êµ¬í˜„ (2.2)
- [ ] ë¡œë“œ ë°¸ëŸ°ì‹± êµ¬í˜„ (2.3)
- [ ] ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ êµ¬í˜„ (2.4)
- [ ] ì‹¤ì œ ì„œë¹„ìŠ¤ ê°œë°œ ì‹œì‘

## ğŸ“‹ **ì„±ê³¼ ì§€í‘œ**

### ğŸ¯ **ëª©í‘œ**
- **ì„œë¹„ìŠ¤ ì‘ë‹µ ì‹œê°„**: P95 < 100ms
- **ì„œë¹„ìŠ¤ ê°€ìš©ì„±**: 99.9% ì´ìƒ
- **í™•ì¥ì„±**: ìˆ˜í‰ í™•ì¥ ê°€ëŠ¥
- **ìœ ì§€ë³´ìˆ˜ì„±**: ì„œë¹„ìŠ¤ë³„ ë…ë¦½ì  ë°°í¬

### ğŸ“Š **í˜„ì¬ ìƒíƒœ**
- **ì„¤ê³„ ì™„ë£Œìœ¨**: 100% âœ…
- **êµ¬í˜„ ì§„í–‰ë¥ **: 0% â³
- **í…ŒìŠ¤íŠ¸ ì§„í–‰ë¥ **: 0% â³
- **ë°°í¬ ì¤€ë¹„ìœ¨**: 0% â³

## ğŸ”— **ê´€ë ¨ ë¬¸ì„œ**

- [ì„œë¹„ìŠ¤ ë””ìŠ¤ì»¤ë²„ë¦¬](2.2_SERVICE_DISCOVERY.md)
- [ë¡œë“œ ë°¸ëŸ°ì‹±](2.3_LOAD_BALANCING.md)
- [ëª¨ë‹ˆí„°ë§](2.4_MONITORING.md)
- [Phase 2 ê°œìš”](../README.md)

---

**ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸**: 2025-07-26
**ë‹¤ìŒ ë‹¨ê³„**: ì„œë¹„ìŠ¤ ë””ìŠ¤ì»¤ë²„ë¦¬ êµ¬í˜„ (2.2)
**ìƒíƒœ**: ë¬¸ì„œí™” ì™„ë£Œ âœ… 