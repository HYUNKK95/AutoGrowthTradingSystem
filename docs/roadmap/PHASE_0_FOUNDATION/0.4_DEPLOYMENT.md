# 🚀 Phase 0.4: 배포 및 운영 시스템

## 📋 **개요**

### 🎯 **목표**
- **기본 배포 파이프라인**: 단순하고 안정적인 배포
- **개발 환경 구축**: 로컬 및 테스트 환경
- **기본 모니터링**: 시스템 상태 감시
- **수동 복구**: 장애 발생 시 수동 복구 절차

### 📊 **성능 목표**
- **배포 시간**: < 30분
- **다운타임**: < 5분 (기본 배포)
- **롤백 시간**: < 10분
- **모니터링 지연**: < 2분

## 🏗️ **배포 아키텍처**

### 📁 **배포 구조**
```
deployment/
├── docker/                          # Docker 설정
│   ├── Dockerfile                   # 메인 애플리케이션
│   ├── docker-compose.yml           # 로컬 개발 환경
│   └── docker-compose.prod.yml      # 프로덕션 환경
├── scripts/                         # 배포 스크립트
│   ├── deploy.sh                    # 배포 스크립트
│   ├── rollback.sh                  # 롤백 스크립트
│   └── health-check.sh              # 헬스 체크
├── config/                          # 설정 파일
│   ├── production.env               # 프로덕션 환경 변수
│   ├── development.env              # 개발 환경 변수
│   └── logging.conf                 # 로깅 설정
└── monitoring/                      # 모니터링 설정
    ├── basic_monitoring.py          # 기본 모니터링
    └── alerts.py                    # 알림 설정
```

## 🐳 **Docker 설정**

### 📦 **Dockerfile 최적화**

```dockerfile
# Dockerfile
FROM python:3.11-slim as base

# 시스템 패키지 설치
RUN apt-get update && apt-get install -y \
    gcc \
    g++ \
    libpq-dev \
    && rm -rf /var/lib/apt/lists/*

# Python 가상환경 설정
RUN python -m venv /opt/venv
ENV PATH="/opt/venv/bin:$PATH"

# 작업 디렉토리 설정
WORKDIR /app

# 의존성 설치
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 애플리케이션 코드 복사
COPY src/ ./src/
COPY main.py .

# 보안 설정
RUN adduser --disabled-password --gecos '' appuser
USER appuser

# 헬스 체크
HEALTHCHECK --interval=30s --timeout=10s --start-period=5s --retries=3 \
    CMD python -c "import requests; requests.get('http://localhost:8000/health')"

# 포트 설정
EXPOSE 8000

# 애플리케이션 실행
CMD ["python", "main.py"]
```

### 🐙 **Docker Compose 설정**

```yaml
# docker-compose.yml
version: '3.8'

services:
  trading-app:
    build: .
    ports:
      - "8000:8000"
    environment:
      - ENVIRONMENT=development
      - DATABASE_URL=sqlite:///./data/trading_system.db
    volumes:
      - ./data:/app/data
      - ./logs:/app/logs
    depends_on:
      - redis
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    restart: unless-stopped

  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: trading_system
      POSTGRES_USER: trading_user
      POSTGRES_PASSWORD: trading_password
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: unless-stopped

volumes:
  redis_data:
  postgres_data:
```

### 🐙 **프로덕션 Docker Compose**

```yaml
# docker-compose.prod.yml
version: '3.8'

services:
  trading-app:
    build: .
    ports:
      - "8000:8000"
    environment:
      - ENVIRONMENT=production
      - DATABASE_URL=postgresql://trading_user:trading_password@postgres:5432/trading_system
      - REDIS_URL=redis://redis:6379
    volumes:
      - ./logs:/app/logs
    depends_on:
      - redis
      - postgres
    restart: unless-stopped
    deploy:
      replicas: 2
      resources:
        limits:
          memory: 1G
          cpus: '0.5'
        reservations:
          memory: 512M
          cpus: '0.25'

  redis:
    image: redis:7-alpine
    volumes:
      - redis_data:/data
    restart: unless-stopped
    deploy:
      resources:
        limits:
          memory: 256M
          cpus: '0.25'

  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: trading_system
      POSTGRES_USER: trading_user
      POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: unless-stopped
    deploy:
      resources:
        limits:
          memory: 512M
          cpus: '0.5'

volumes:
  redis_data:
  postgres_data:
```

## 📜 **배포 스크립트**

### 🚀 **배포 스크립트**

```bash
#!/bin/bash
# scripts/deploy.sh

set -e

echo "🚀 AutoGrowth Trading System 배포 시작"
echo "======================================"

# 환경 변수 설정
ENVIRONMENT=${1:-production}
VERSION=${2:-latest}

echo "배포 환경: $ENVIRONMENT"
echo "배포 버전: $VERSION"

# 1. 코드 품질 검사
echo "1. 코드 품질 검사 중..."
pytest tests/ -v --tb=short --durations=10
if [ $? -ne 0 ]; then
    echo "❌ 테스트 실패. 배포를 중단합니다."
    exit 1
fi

# 2. Docker 이미지 빌드
echo "2. Docker 이미지 빌드 중..."
docker build -t autogrowth-trading:$VERSION .
if [ $? -ne 0 ]; then
    echo "❌ Docker 빌드 실패. 배포를 중단합니다."
    exit 1
fi

# 3. 기존 컨테이너 중지
echo "3. 기존 컨테이너 중지 중..."
docker-compose -f docker-compose.prod.yml down

# 4. 새 컨테이너 시작
echo "4. 새 컨테이너 시작 중..."
docker-compose -f docker-compose.prod.yml up -d

# 5. 헬스 체크
echo "5. 헬스 체크 중..."
sleep 30
./scripts/health-check.sh

if [ $? -eq 0 ]; then
    echo "✅ 배포 완료!"
else
    echo "❌ 헬스 체크 실패. 롤백을 시작합니다."
    ./scripts/rollback.sh
    exit 1
fi
```

### 🔄 **롤백 스크립트**

```bash
#!/bin/bash
# scripts/rollback.sh

set -e

echo "🔄 롤백 시작"
echo "============"

# 1. 현재 컨테이너 중지
echo "1. 현재 컨테이너 중지 중..."
docker-compose -f docker-compose.prod.yml down

# 2. 이전 버전으로 복원
echo "2. 이전 버전으로 복원 중..."
if [ -f "backup/docker-compose.prod.yml.backup" ]; then
    cp backup/docker-compose.prod.yml.backup docker-compose.prod.yml
fi

# 3. 이전 버전 컨테이너 시작
echo "3. 이전 버전 컨테이너 시작 중..."
docker-compose -f docker-compose.prod.yml up -d

# 4. 헬스 체크
echo "4. 헬스 체크 중..."
sleep 30
./scripts/health-check.sh

if [ $? -eq 0 ]; then
    echo "✅ 롤백 완료!"
else
    echo "❌ 롤백 실패. 수동 개입이 필요합니다."
    exit 1
fi
```

### 🏥 **헬스 체크 스크립트**

```bash
#!/bin/bash
# scripts/health-check.sh

set -e

echo "🏥 헬스 체크 시작"
echo "================"

# API 헬스 체크
echo "1. API 헬스 체크 중..."
response=$(curl -s -o /dev/null -w "%{http_code}" http://localhost:8000/health)

if [ $response -eq 200 ]; then
    echo "✅ API 헬스 체크 통과"
else
    echo "❌ API 헬스 체크 실패 (HTTP $response)"
    exit 1
fi

# 데이터베이스 연결 체크
echo "2. 데이터베이스 연결 체크 중..."
docker-compose -f docker-compose.prod.yml exec -T trading-app python -c "
import psycopg2
try:
    conn = psycopg2.connect('postgresql://trading_user:trading_password@postgres:5432/trading_system')
    conn.close()
    print('✅ 데이터베이스 연결 성공')
except Exception as e:
    print(f'❌ 데이터베이스 연결 실패: {e}')
    exit(1)
"

# Redis 연결 체크
echo "3. Redis 연결 체크 중..."
docker-compose -f docker-compose.prod.yml exec -T trading-app python -c "
import redis
try:
    r = redis.Redis(host='redis', port=6379, db=0)
    r.ping()
    print('✅ Redis 연결 성공')
except Exception as e:
    print(f'❌ Redis 연결 실패: {e}')
    exit(1)
"

echo "✅ 모든 헬스 체크 통과!"
```

## 📊 **모니터링 시스템**

### 📈 **기본 모니터링**

```python
# monitoring/basic_monitoring.py
import time
import psutil
import requests
import logging
from datetime import datetime
from typing import Dict, Any

logger = logging.getLogger(__name__)

class BasicMonitor:
    """기본 모니터링 시스템"""
    
    def __init__(self, api_url: str = "http://localhost:8000"):
        self.api_url = api_url
        self.alert_thresholds = {
            'cpu_percent': 80.0,
            'memory_percent': 80.0,
            'disk_percent': 90.0,
            'api_response_time': 2.0  # 초
        }
    
    def check_system_health(self) -> Dict[str, Any]:
        """시스템 상태 체크"""
        try:
            # CPU 사용률
            cpu_percent = psutil.cpu_percent(interval=1)
            
            # 메모리 사용률
            memory = psutil.virtual_memory()
            memory_percent = memory.percent
            
            # 디스크 사용률
            disk = psutil.disk_usage('/')
            disk_percent = disk.percent
            
            # API 응답 시간
            api_response_time = self._check_api_response_time()
            
            health_status = {
                'timestamp': datetime.now().isoformat(),
                'cpu_percent': cpu_percent,
                'memory_percent': memory_percent,
                'disk_percent': disk_percent,
                'api_response_time': api_response_time,
                'status': 'healthy'
            }
            
            # 알림 체크
            alerts = self._check_alerts(health_status)
            if alerts:
                health_status['alerts'] = alerts
                health_status['status'] = 'warning'
            
            logger.info(f"시스템 상태: {health_status}")
            return health_status
            
        except Exception as e:
            logger.error(f"시스템 상태 체크 실패: {e}")
            return {
                'timestamp': datetime.now().isoformat(),
                'status': 'error',
                'error': str(e)
            }
    
    def _check_api_response_time(self) -> float:
        """API 응답 시간 체크"""
        try:
            start_time = time.time()
            response = requests.get(f"{self.api_url}/health", timeout=5)
            response_time = time.time() - start_time
            
            if response.status_code == 200:
                return response_time
            else:
                return -1  # 에러 표시
                
        except Exception as e:
            logger.error(f"API 응답 시간 체크 실패: {e}")
            return -1
    
    def _check_alerts(self, health_status: Dict[str, Any]) -> list:
        """알림 체크"""
        alerts = []
        
        if health_status['cpu_percent'] > self.alert_thresholds['cpu_percent']:
            alerts.append(f"CPU 사용률 높음: {health_status['cpu_percent']}%")
        
        if health_status['memory_percent'] > self.alert_thresholds['memory_percent']:
            alerts.append(f"메모리 사용률 높음: {health_status['memory_percent']}%")
        
        if health_status['disk_percent'] > self.alert_thresholds['disk_percent']:
            alerts.append(f"디스크 사용률 높음: {health_status['disk_percent']}%")
        
        if (health_status['api_response_time'] > 0 and 
            health_status['api_response_time'] > self.alert_thresholds['api_response_time']):
            alerts.append(f"API 응답 시간 느림: {health_status['api_response_time']:.2f}초")
        
        if health_status['api_response_time'] == -1:
            alerts.append("API 응답 실패")
        
        return alerts
    
    def start_monitoring(self, interval: int = 60):
        """모니터링 시작"""
        logger.info(f"모니터링 시작 (간격: {interval}초)")
        
        while True:
            try:
                health_status = self.check_system_health()
                
                # 알림이 있으면 처리
                if health_status.get('alerts'):
                    self._send_alerts(health_status['alerts'])
                
                time.sleep(interval)
                
            except KeyboardInterrupt:
                logger.info("모니터링 중지")
                break
            except Exception as e:
                logger.error(f"모니터링 오류: {e}")
                time.sleep(interval)
    
    def _send_alerts(self, alerts: list):
        """알림 전송"""
        for alert in alerts:
            logger.warning(f"🚨 알림: {alert}")
            # 여기에 실제 알림 전송 로직 추가 (이메일, 슬랙 등)

if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    monitor = BasicMonitor()
    monitor.start_monitoring()
```

### 🚨 **알림 시스템**

```python
# monitoring/alerts.py
import smtplib
import logging
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from typing import List, Dict, Any

logger = logging.getLogger(__name__)

class AlertManager:
    """알림 관리자"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.email_config = config.get('email', {})
        self.slack_config = config.get('slack', {})
    
    def send_email_alert(self, subject: str, message: str, recipients: List[str]):
        """이메일 알림 전송"""
        try:
            if not self.email_config:
                logger.warning("이메일 설정이 없습니다.")
                return
            
            msg = MIMEMultipart()
            msg['From'] = self.email_config['from']
            msg['To'] = ', '.join(recipients)
            msg['Subject'] = f"[AutoGrowth Trading] {subject}"
            
            body = f"""
            AutoGrowth Trading System 알림
            
            {message}
            
            시간: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
            """
            
            msg.attach(MIMEText(body, 'plain'))
            
            # SMTP 서버 연결
            server = smtplib.SMTP(self.email_config['smtp_server'], self.email_config['smtp_port'])
            server.starttls()
            server.login(self.email_config['username'], self.email_config['password'])
            
            # 이메일 전송
            text = msg.as_string()
            server.sendmail(self.email_config['from'], recipients, text)
            server.quit()
            
            logger.info(f"이메일 알림 전송 완료: {subject}")
            
        except Exception as e:
            logger.error(f"이메일 알림 전송 실패: {e}")
    
    def send_system_alert(self, alerts: List[str]):
        """시스템 알림 전송"""
        if not alerts:
            return
        
        subject = "시스템 상태 알림"
        message = "\n".join([f"- {alert}" for alert in alerts])
        
        # 이메일 알림
        if self.email_config.get('recipients'):
            self.send_email_alert(subject, message, self.email_config['recipients'])
        
        # 로그 출력
        for alert in alerts:
            logger.warning(f"🚨 {alert}")
    
    def send_deployment_alert(self, status: str, details: str):
        """배포 알림 전송"""
        subject = f"배포 {status}"
        message = f"""
        배포 상태: {status}
        
        상세 정보:
        {details}
        """
        
        # 이메일 알림
        if self.email_config.get('recipients'):
            self.send_email_alert(subject, message, self.email_config['recipients'])
        
        # 로그 출력
        logger.info(f"배포 알림: {status} - {details}")

# 알림 설정 예시
ALERT_CONFIG = {
    'email': {
        'smtp_server': 'smtp.gmail.com',
        'smtp_port': 587,
        'username': 'your-email@gmail.com',
        'password': 'your-app-password',
        'from': 'your-email@gmail.com',
        'recipients': ['admin@example.com']
    },
    'slack': {
        'webhook_url': 'https://hooks.slack.com/services/YOUR/WEBHOOK/URL'
    }
}
```

## 📋 **운영 절차**

### 🔧 **일일 운영 체크리스트**

```python
# scripts/daily_checklist.py
import logging
from datetime import datetime
from monitoring.basic_monitoring import BasicMonitor

logger = logging.getLogger(__name__)

class DailyChecklist:
    """일일 운영 체크리스트"""
    
    def __init__(self):
        self.monitor = BasicMonitor()
    
    def run_daily_checks(self):
        """일일 체크 실행"""
        logger.info("📋 일일 운영 체크리스트 시작")
        
        checks = [
            ("시스템 상태 체크", self.check_system_health),
            ("데이터베이스 연결 체크", self.check_database),
            ("API 응답 체크", self.check_api),
            ("로그 파일 체크", self.check_logs),
            ("백업 상태 체크", self.check_backup),
        ]
        
        results = []
        for check_name, check_func in checks:
            try:
                result = check_func()
                results.append((check_name, "✅ 통과", result))
                logger.info(f"{check_name}: 통과")
            except Exception as e:
                results.append((check_name, "❌ 실패", str(e)))
                logger.error(f"{check_name}: 실패 - {e}")
        
        # 결과 요약
        self._print_summary(results)
        return results
    
    def check_system_health(self):
        """시스템 상태 체크"""
        health = self.monitor.check_system_health()
        
        if health['status'] != 'healthy':
            raise Exception(f"시스템 상태 불량: {health['status']}")
        
        return health
    
    def check_database(self):
        """데이터베이스 연결 체크"""
        # 실제 구현에서는 데이터베이스 연결 테스트
        return "데이터베이스 연결 정상"
    
    def check_api(self):
        """API 응답 체크"""
        response_time = self.monitor._check_api_response_time()
        
        if response_time == -1:
            raise Exception("API 응답 실패")
        
        if response_time > 2.0:
            raise Exception(f"API 응답 시간 느림: {response_time:.2f}초")
        
        return f"API 응답 정상 ({response_time:.2f}초)"
    
    def check_logs(self):
        """로그 파일 체크"""
        # 실제 구현에서는 로그 파일 크기 및 에러 체크
        return "로그 파일 정상"
    
    def check_backup(self):
        """백업 상태 체크"""
        # 실제 구현에서는 백업 파일 존재 여부 및 크기 체크
        return "백업 정상"
    
    def _print_summary(self, results):
        """결과 요약 출력"""
        print("\n" + "="*50)
        print("📋 일일 운영 체크리스트 결과")
        print("="*50)
        
        for check_name, status, details in results:
            print(f"{status} {check_name}")
            if isinstance(details, dict):
                for key, value in details.items():
                    print(f"  {key}: {value}")
            else:
                print(f"  {details}")
        
        print("="*50)

if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO)
    checklist = DailyChecklist()
    checklist.run_daily_checks()
```

### 🚨 **장애 대응 절차**

```python
# scripts/incident_response.py
import logging
from datetime import datetime
from typing import Dict, Any

logger = logging.getLogger(__name__)

class IncidentResponse:
    """장애 대응 절차"""
    
    def __init__(self):
        self.incident_levels = {
            'critical': '심각',
            'high': '높음',
            'medium': '보통',
            'low': '낮음'
        }
    
    def handle_incident(self, level: str, description: str, details: Dict[str, Any]):
        """장애 처리"""
        logger.error(f"🚨 장애 발생: {self.incident_levels.get(level, level)} - {description}")
        
        # 장애 로그 기록
        self._log_incident(level, description, details)
        
        # 장애 수준별 대응
        if level == 'critical':
            self._handle_critical_incident(description, details)
        elif level == 'high':
            self._handle_high_incident(description, details)
        elif level == 'medium':
            self._handle_medium_incident(description, details)
        else:
            self._handle_low_incident(description, details)
    
    def _handle_critical_incident(self, description: str, details: Dict[str, Any]):
        """심각한 장애 처리"""
        logger.critical("🔴 심각한 장애 처리 시작")
        
        # 1. 즉시 알림
        self._send_emergency_alert(description, details)
        
        # 2. 서비스 중지
        self._stop_services()
        
        # 3. 롤백 시도
        self._attempt_rollback()
        
        # 4. 수동 개입 필요
        logger.critical("수동 개입이 필요합니다!")
    
    def _handle_high_incident(self, description: str, details: Dict[str, Any]):
        """높은 수준 장애 처리"""
        logger.error("🟠 높은 수준 장애 처리 시작")
        
        # 1. 알림 전송
        self._send_alert(description, details)
        
        # 2. 자동 복구 시도
        self._attempt_auto_recovery()
        
        # 3. 모니터링 강화
        self._enhance_monitoring()
    
    def _handle_medium_incident(self, description: str, details: Dict[str, Any]):
        """보통 수준 장애 처리"""
        logger.warning("🟡 보통 수준 장애 처리 시작")
        
        # 1. 알림 전송
        self._send_alert(description, details)
        
        # 2. 자동 복구 시도
        self._attempt_auto_recovery()
    
    def _handle_low_incident(self, description: str, details: Dict[str, Any]):
        """낮은 수준 장애 처리"""
        logger.info("🟢 낮은 수준 장애 처리 시작")
        
        # 1. 로그 기록
        self._log_incident('low', description, details)
        
        # 2. 모니터링
        self._monitor_incident(description, details)
    
    def _log_incident(self, level: str, description: str, details: Dict[str, Any]):
        """장애 로그 기록"""
        incident_log = {
            'timestamp': datetime.now().isoformat(),
            'level': level,
            'description': description,
            'details': details
        }
        
        logger.error(f"장애 로그: {incident_log}")
    
    def _send_emergency_alert(self, description: str, details: Dict[str, Any]):
        """긴급 알림 전송"""
        logger.critical(f"긴급 알림: {description}")
        # 실제 구현에서는 긴급 알림 전송
    
    def _send_alert(self, description: str, details: Dict[str, Any]):
        """일반 알림 전송"""
        logger.warning(f"알림: {description}")
        # 실제 구현에서는 일반 알림 전송
    
    def _stop_services(self):
        """서비스 중지"""
        logger.critical("서비스 중지 중...")
        # 실제 구현에서는 서비스 중지
    
    def _attempt_rollback(self):
        """롤백 시도"""
        logger.critical("롤백 시도 중...")
        # 실제 구현에서는 롤백 실행
    
    def _attempt_auto_recovery(self):
        """자동 복구 시도"""
        logger.info("자동 복구 시도 중...")
        # 실제 구현에서는 자동 복구 로직
    
    def _enhance_monitoring(self):
        """모니터링 강화"""
        logger.info("모니터링 강화 중...")
        # 실제 구현에서는 모니터링 간격 단축 등
    
    def _monitor_incident(self, description: str, details: Dict[str, Any]):
        """장애 모니터링"""
        logger.info(f"장애 모니터링: {description}")
        # 실제 구현에서는 장애 상태 지속 모니터링
```

## 📊 **성능 최적화**

### 🎯 **현실적 성능 목표**
- **배포 시간**: < 30분 (기본 배포)
- **시스템 가동률**: 99% 이상
- **응답 시간**: < 200ms (API)
- **메모리 사용량**: < 1GB

### 🔧 **최적화 전략**
1. **Docker 이미지 최적화**: 멀티스테이지 빌드
2. **리소스 제한**: CPU/메모리 제한 설정
3. **로깅 최적화**: 로그 레벨 및 로테이션
4. **모니터링 효율성**: 적절한 모니터링 간격

---

**Phase 0.4 완료 기준**: 기본 배포 파이프라인 구축, 모니터링 시스템 운영, 장애 대응 절차 수립 