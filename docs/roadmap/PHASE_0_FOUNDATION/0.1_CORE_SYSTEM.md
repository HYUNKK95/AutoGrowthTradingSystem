# ğŸ”§ 0.1 í•µì‹¬ ì‹œìŠ¤í…œ

## ğŸ“‹ **ê°œìš”**

### ğŸ¯ **ëª©í‘œ**
- **ì•ˆì •ì„±**: 99% ê°€ë™ë¥  ë³´ì¥ (ê°œì¸ ê°œë°œì ê¸°ì¤€)
- **ì„±ëŠ¥**: < 200ms ì‘ë‹µ ì‹œê°„ (ë„¤íŠ¸ì›Œí¬ ì§€ì—° ê³ ë ¤)
- **í™•ì¥ì„±**: ë‹¨ê³„ì  í™•ì¥ ê°€ëŠ¥í•œ ì•„í‚¤í…ì²˜
- **ë³´ì•ˆ**: ê¸°ë³¸ ë³´ì•ˆ ìˆ˜ì¤€ (API í‚¤ ê´€ë¦¬, SSL/TLS)

### ğŸ“Š **ì„±ê³¼ ì§€í‘œ**
- **ì‹œìŠ¤í…œ ê°€ë™ë¥ **: 99% ì´ìƒ
- **ì‘ë‹µ ì‹œê°„**: P95 < 200ms
- **ì²˜ë¦¬ëŸ‰**: 100 TPS (API ì œí•œ ê³ ë ¤)
- **ì˜¤ë¥˜ìœ¨**: < 1%

## ğŸ—ï¸ **0.1.1 ì£¼ë¬¸ ê´€ë¦¬ ì‹œìŠ¤í…œ**

### ğŸ“‹ **êµ¬í˜„ ì„¸ë¶€ì‚¬í•­**

#### **ì£¼ë¬¸ ëª¨ë¸ ì„¤ê³„**
```python
from dataclasses import dataclass
from datetime import datetime, timezone
from decimal import Decimal
from enum import Enum
from typing import Optional, Dict, Any

class OrderType(Enum):
    MARKET = "MARKET"
    LIMIT = "LIMIT"
    STOP = "STOP"
    STOP_LIMIT = "STOP_LIMIT"

class OrderSide(Enum):
    BUY = "BUY"
    SELL = "SELL"

class OrderStatus(Enum):
    PENDING = "PENDING"
    PARTIALLY_FILLED = "PARTIALLY_FILLED"
    FILLED = "FILLED"
    CANCELLED = "CANCELLED"
    REJECTED = "REJECTED"
    EXPIRED = "EXPIRED"

@dataclass
class Order:
    """ì£¼ë¬¸ ë°ì´í„° ëª¨ë¸"""
    id: str
    user_id: str
    symbol: str
    side: OrderSide
    order_type: OrderType
    quantity: Decimal
    price: Optional[Decimal] = None
    stop_price: Optional[Decimal] = None
    status: OrderStatus = OrderStatus.PENDING
    filled_quantity: Decimal = Decimal('0')
    average_price: Optional[Decimal] = None
    commission: Decimal = Decimal('0')
    created_at: datetime = None
    updated_at: datetime = None
    expires_at: Optional[datetime] = None
    
    def __post_init__(self):
        if self.created_at is None:
            self.created_at = datetime.now(timezone.utc)
        if self.updated_at is None:
            self.updated_at = self.created_at
    
    @property
    def remaining_quantity(self) -> Decimal:
        """ë‚¨ì€ ìˆ˜ëŸ‰ ê³„ì‚°"""
        return self.quantity - self.filled_quantity
    
    @property
    def is_active(self) -> bool:
        """í™œì„± ì£¼ë¬¸ ì—¬ë¶€"""
        return self.status in [OrderStatus.PENDING, OrderStatus.PARTIALLY_FILLED]
    
    @property
    def total_value(self) -> Decimal:
        """ì£¼ë¬¸ ì´ ê°€ì¹˜"""
        if self.price:
            return self.quantity * self.price
        return Decimal('0')
```

#### **ì£¼ë¬¸ ê´€ë¦¬ì êµ¬í˜„**
```python
import asyncio
import logging
from typing import List, Optional, Dict, Any
from decimal import Decimal
from datetime import datetime, timezone

from .models import Order, OrderStatus, OrderType, OrderSide
from .validators import OrderValidator
from .exceptions import OrderError, ValidationError

logger = logging.getLogger(__name__)

class OrderManager:
    """ì£¼ë¬¸ ê´€ë¦¬ì - ê¸°ë³¸ ê¸°ëŠ¥ ì¤‘ì‹¬"""
    
    def __init__(self, exchange_client, validator: OrderValidator):
        self.exchange_client = exchange_client
        self.validator = validator
        self.orders: Dict[str, Order] = {}
        self.order_queue = asyncio.Queue()
        self.processing_task = None
    
    async def place_order(self, order_data: Dict[str, Any]) -> Order:
        """ì£¼ë¬¸ ì‹¤í–‰"""
        try:
            # ì£¼ë¬¸ ê²€ì¦
            self.validator.validate_order(order_data)
            
            # ì£¼ë¬¸ ìƒì„±
            order = self._create_order(order_data)
            
            # ì£¼ë¬¸ ì €ì¥
            self.orders[order.id] = order
            
            # ê±°ë˜ì†Œì— ì£¼ë¬¸ ì „ì†¡
            await self._send_to_exchange(order)
            
            logger.info(f"Order placed: {order.id}")
            return order
            
        except Exception as e:
            logger.error(f"Order placement failed: {e}")
            raise OrderError(f"ì£¼ë¬¸ ì‹¤í–‰ ì‹¤íŒ¨: {e}")
    
    async def cancel_order(self, order_id: str) -> bool:
        """ì£¼ë¬¸ ì·¨ì†Œ"""
        try:
            order = self.orders.get(order_id)
            if not order:
                raise OrderError(f"ì£¼ë¬¸ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ: {order_id}")
            
            if not order.is_active:
                raise OrderError(f"ì·¨ì†Œí•  ìˆ˜ ì—†ëŠ” ì£¼ë¬¸ ìƒíƒœ: {order.status}")
            
            # ê±°ë˜ì†Œì— ì·¨ì†Œ ìš”ì²­
            success = await self.exchange_client.cancel_order(order_id, order.symbol)
            
            if success:
                order.status = OrderStatus.CANCELLED
                order.updated_at = datetime.now(timezone.utc)
                logger.info(f"Order cancelled: {order_id}")
            
            return success
            
        except Exception as e:
            logger.error(f"Order cancellation failed: {e}")
            raise OrderError(f"ì£¼ë¬¸ ì·¨ì†Œ ì‹¤íŒ¨: {e}")
    
    async def get_order(self, order_id: str) -> Optional[Order]:
        """ì£¼ë¬¸ ì¡°íšŒ"""
        return self.orders.get(order_id)
    
    async def get_user_orders(self, user_id: str) -> List[Order]:
        """ì‚¬ìš©ì ì£¼ë¬¸ ëª©ë¡ ì¡°íšŒ"""
        return [order for order in self.orders.values() if order.user_id == user_id]
    
    def _create_order(self, order_data: Dict[str, Any]) -> Order:
        """ì£¼ë¬¸ ê°ì²´ ìƒì„±"""
        return Order(
            id=self._generate_order_id(),
            user_id=order_data['user_id'],
            symbol=order_data['symbol'],
            side=OrderSide(order_data['side']),
            order_type=OrderType(order_data['order_type']),
            quantity=Decimal(str(order_data['quantity'])),
            price=Decimal(str(order_data['price'])) if order_data.get('price') else None,
            stop_price=Decimal(str(order_data['stop_price'])) if order_data.get('stop_price') else None
        )
    
    def _generate_order_id(self) -> str:
        """ì£¼ë¬¸ ID ìƒì„±"""
        return f"order_{datetime.now(timezone.utc).strftime('%Y%m%d_%H%M%S_%f')}"
    
    async def _send_to_exchange(self, order: Order):
        """ê±°ë˜ì†Œì— ì£¼ë¬¸ ì „ì†¡"""
        try:
            # API ë ˆì´íŠ¸ ë¦¬ë°‹ ê³ ë ¤
            await asyncio.sleep(0.1)  # 100ms ì§€ì—°
            
            result = await self.exchange_client.place_order(order)
            
            if result.get('success'):
                order.status = OrderStatus.PENDING
            else:
                order.status = OrderStatus.REJECTED
                raise OrderError(f"ê±°ë˜ì†Œ ì£¼ë¬¸ ì‹¤íŒ¨: {result.get('error')}")
                
        except Exception as e:
            order.status = OrderStatus.REJECTED
            raise OrderError(f"ê±°ë˜ì†Œ ì—°ë™ ì‹¤íŒ¨: {e}")
```

## ğŸ‘¤ **0.1.2 ì‚¬ìš©ì ê´€ë¦¬ ì‹œìŠ¤í…œ**

### ğŸ“‹ **êµ¬í˜„ ì„¸ë¶€ì‚¬í•­**

#### **ì‚¬ìš©ì ëª¨ë¸ ì„¤ê³„**
```python
from dataclasses import dataclass
from datetime import datetime, timezone
from decimal import Decimal
from enum import Enum
from typing import Dict, Any, Optional

class UserStatus(Enum):
    ACTIVE = "ACTIVE"
    INACTIVE = "INACTIVE"
    SUSPENDED = "SUSPENDED"

@dataclass
class User:
    """ì‚¬ìš©ì ë°ì´í„° ëª¨ë¸"""
    id: str
    username: str
    email: str
    status: UserStatus = UserStatus.ACTIVE
    created_at: datetime = None
    updated_at: datetime = None
    last_login: Optional[datetime] = None
    
    def __post_init__(self):
        if self.created_at is None:
            self.created_at = datetime.now(timezone.utc)
        if self.updated_at is None:
            self.updated_at = self.created_at

@dataclass
class UserBalance:
    """ì‚¬ìš©ì ì”ê³  ëª¨ë¸"""
    user_id: str
    currency: str
    available: Decimal
    locked: Decimal = Decimal('0')
    total: Decimal = None
    
    def __post_init__(self):
        if self.total is None:
            self.total = self.available + self.locked
```

#### **ì‚¬ìš©ì ê´€ë¦¬ì êµ¬í˜„**
```python
import logging
from typing import Dict, List, Optional
from decimal import Decimal
from datetime import datetime, timezone

from .models import User, UserBalance, UserStatus

logger = logging.getLogger(__name__)

class UserManager:
    """ì‚¬ìš©ì ê´€ë¦¬ì - ê¸°ë³¸ ê¸°ëŠ¥ ì¤‘ì‹¬"""
    
    def __init__(self):
        self.users: Dict[str, User] = {}
        self.balances: Dict[str, Dict[str, UserBalance]] = {}
    
    def create_user(self, user_data: Dict[str, Any]) -> User:
        """ì‚¬ìš©ì ìƒì„±"""
        try:
            user = User(
                id=self._generate_user_id(),
                username=user_data['username'],
                email=user_data['email']
            )
            
            self.users[user.id] = user
            self.balances[user.id] = {}
            
            logger.info(f"User created: {user.id}")
            return user
            
        except Exception as e:
            logger.error(f"User creation failed: {e}")
            raise ValueError(f"ì‚¬ìš©ì ìƒì„± ì‹¤íŒ¨: {e}")
    
    def get_user(self, user_id: str) -> Optional[User]:
        """ì‚¬ìš©ì ì¡°íšŒ"""
        return self.users.get(user_id)
    
    def update_user_status(self, user_id: str, status: UserStatus) -> bool:
        """ì‚¬ìš©ì ìƒíƒœ ì—…ë°ì´íŠ¸"""
        user = self.users.get(user_id)
        if not user:
            return False
        
        user.status = status
        user.updated_at = datetime.now(timezone.utc)
        logger.info(f"User status updated: {user_id} -> {status}")
        return True
    
    def get_user_balance(self, user_id: str, currency: str) -> Optional[UserBalance]:
        """ì‚¬ìš©ì ì”ê³  ì¡°íšŒ"""
        user_balances = self.balances.get(user_id, {})
        return user_balances.get(currency)
    
    def update_balance(self, user_id: str, currency: str, 
                      available: Decimal, locked: Decimal = Decimal('0')):
        """ì”ê³  ì—…ë°ì´íŠ¸"""
        if user_id not in self.balances:
            self.balances[user_id] = {}
        
        self.balances[user_id][currency] = UserBalance(
            user_id=user_id,
            currency=currency,
            available=available,
            locked=locked
        )
        
        logger.info(f"Balance updated: {user_id} {currency} {available}")
    
    def _generate_user_id(self) -> str:
        """ì‚¬ìš©ì ID ìƒì„±"""
        return f"user_{datetime.now(timezone.utc).strftime('%Y%m%d_%H%M%S_%f')}"
```

## ğŸ”— **0.1.3 ê±°ë˜ì†Œ ì—°ë™ ì‹œìŠ¤í…œ**

### ğŸ“‹ **êµ¬í˜„ ì„¸ë¶€ì‚¬í•­**

#### **ê±°ë˜ì†Œ í´ë¼ì´ì–¸íŠ¸ êµ¬í˜„**
```python
import aiohttp
import asyncio
import hmac
import hashlib
import time
import logging
from typing import Dict, Any, Optional
from decimal import Decimal

logger = logging.getLogger(__name__)

class ExchangeClient:
    """ê±°ë˜ì†Œ í´ë¼ì´ì–¸íŠ¸ - Binance ì¤‘ì‹¬"""
    
    def __init__(self, api_key: str, api_secret: str, testnet: bool = True):
        self.api_key = api_key
        self.api_secret = api_secret
        self.base_url = "https://testnet.binance.vision" if testnet else "https://api.binance.com"
        self.session = None
        self.rate_limit_delay = 0.1  # 100ms (API ì œí•œ ê³ ë ¤)
    
    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
    
    async def place_order(self, order) -> Dict[str, Any]:
        """ì£¼ë¬¸ ì‹¤í–‰"""
        try:
            # API ë ˆì´íŠ¸ ë¦¬ë°‹ ê³ ë ¤
            await asyncio.sleep(self.rate_limit_delay)
            
            params = {
                'symbol': order.symbol,
                'side': order.side.value,
                'type': order.order_type.value,
                'quantity': str(order.quantity)
            }
            
            if order.price:
                params['price'] = str(order.price)
            if order.stop_price:
                params['stopPrice'] = str(order.stop_price)
            
            # ì„œëª… ìƒì„±
            signature = self._create_signature(params)
            params['signature'] = signature
            
            headers = {'X-MBX-APIKEY': self.api_key}
            
            async with self.session.post(
                f"{self.base_url}/api/v3/order",
                params=params,
                headers=headers
            ) as response:
                result = await response.json()
                
                if response.status == 200:
                    return {'success': True, 'data': result}
                else:
                    return {'success': False, 'error': result.get('msg', 'Unknown error')}
                    
        except Exception as e:
            logger.error(f"Order placement failed: {e}")
            return {'success': False, 'error': str(e)}
    
    async def cancel_order(self, order_id: str, symbol: str) -> bool:
        """ì£¼ë¬¸ ì·¨ì†Œ"""
        try:
            await asyncio.sleep(self.rate_limit_delay)
            
            params = {
                'symbol': symbol,
                'orderId': order_id
            }
            
            signature = self._create_signature(params)
            params['signature'] = signature
            
            headers = {'X-MBX-APIKEY': self.api_key}
            
            async with self.session.delete(
                f"{self.base_url}/api/v3/order",
                params=params,
                headers=headers
            ) as response:
                result = await response.json()
                return response.status == 200
                
        except Exception as e:
            logger.error(f"Order cancellation failed: {e}")
            return False
    
    async def get_account_info(self) -> Dict[str, Any]:
        """ê³„ì • ì •ë³´ ì¡°íšŒ"""
        try:
            await asyncio.sleep(self.rate_limit_delay)
            
            params = {}
            signature = self._create_signature(params)
            params['signature'] = signature
            
            headers = {'X-MBX-APIKEY': self.api_key}
            
            async with self.session.get(
                f"{self.base_url}/api/v3/account",
                params=params,
                headers=headers
            ) as response:
                return await response.json()
                
        except Exception as e:
            logger.error(f"Account info fetch failed: {e}")
            return {}
    
    def _create_signature(self, params: Dict[str, Any]) -> str:
        """API ì„œëª… ìƒì„±"""
        query_string = '&'.join([f"{k}={v}" for k, v in params.items()])
        return hmac.new(
            self.api_secret.encode('utf-8'),
            query_string.encode('utf-8'),
            hashlib.sha256
        ).hexdigest()
```

## ğŸ—„ï¸ **0.1.4 ë°ì´í„°ë² ì´ìŠ¤ ì„¤ê³„**

### ğŸ“‹ **êµ¬í˜„ ì„¸ë¶€ì‚¬í•­**

#### **SQLite ê¸°ë°˜ ë°ì´í„°ë² ì´ìŠ¤ ì„¤ê³„**
```python
import sqlite3
import logging
from typing import Dict, Any, List, Optional
from datetime import datetime, timezone
from decimal import Decimal

logger = logging.getLogger(__name__)

class DatabaseManager:
    """ë°ì´í„°ë² ì´ìŠ¤ ê´€ë¦¬ì - SQLite ê¸°ë°˜"""
    
    def __init__(self, db_path: str = "data/trading_system.db"):
        self.db_path = db_path
        self.init_database()
    
    def init_database(self):
        """ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™”"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                
                # ì‚¬ìš©ì í…Œì´ë¸”
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS users (
                        id TEXT PRIMARY KEY,
                        username TEXT UNIQUE NOT NULL,
                        email TEXT UNIQUE NOT NULL,
                        status TEXT NOT NULL,
                        created_at TIMESTAMP NOT NULL,
                        updated_at TIMESTAMP NOT NULL,
                        last_login TIMESTAMP
                    )
                """)
                
                # ì£¼ë¬¸ í…Œì´ë¸”
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS orders (
                        id TEXT PRIMARY KEY,
                        user_id TEXT NOT NULL,
                        symbol TEXT NOT NULL,
                        side TEXT NOT NULL,
                        order_type TEXT NOT NULL,
                        quantity DECIMAL(20,8) NOT NULL,
                        price DECIMAL(20,8),
                        stop_price DECIMAL(20,8),
                        status TEXT NOT NULL,
                        filled_quantity DECIMAL(20,8) DEFAULT 0,
                        average_price DECIMAL(20,8),
                        commission DECIMAL(20,8) DEFAULT 0,
                        created_at TIMESTAMP NOT NULL,
                        updated_at TIMESTAMP NOT NULL,
                        expires_at TIMESTAMP,
                        FOREIGN KEY (user_id) REFERENCES users (id)
                    )
                """)
                
                # ì”ê³  í…Œì´ë¸”
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS balances (
                        user_id TEXT NOT NULL,
                        currency TEXT NOT NULL,
                        available DECIMAL(20,8) NOT NULL,
                        locked DECIMAL(20,8) DEFAULT 0,
                        total DECIMAL(20,8) NOT NULL,
                        updated_at TIMESTAMP NOT NULL,
                        PRIMARY KEY (user_id, currency),
                        FOREIGN KEY (user_id) REFERENCES users (id)
                    )
                """)
                
                # ì¸ë±ìŠ¤ ìƒì„±
                cursor.execute("CREATE INDEX IF NOT EXISTS idx_orders_user_id ON orders (user_id)")
                cursor.execute("CREATE INDEX IF NOT EXISTS idx_orders_status ON orders (status)")
                cursor.execute("CREATE INDEX IF NOT EXISTS idx_orders_symbol ON orders (symbol)")
                
                conn.commit()
                logger.info("Database initialized successfully")
                
        except Exception as e:
            logger.error(f"Database initialization failed: {e}")
            raise
    
    def save_user(self, user) -> bool:
        """ì‚¬ìš©ì ì €ì¥"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute("""
                    INSERT OR REPLACE INTO users 
                    (id, username, email, status, created_at, updated_at, last_login)
                    VALUES (?, ?, ?, ?, ?, ?, ?)
                """, (
                    user.id, user.username, user.email, user.status.value,
                    user.created_at, user.updated_at, user.last_login
                ))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"User save failed: {e}")
            return False
    
    def get_user(self, user_id: str) -> Optional[Dict[str, Any]]:
        """ì‚¬ìš©ì ì¡°íšŒ"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT * FROM users WHERE id = ?", (user_id,))
                row = cursor.fetchone()
                
                if row:
                    return {
                        'id': row[0], 'username': row[1], 'email': row[2],
                        'status': row[3], 'created_at': row[4],
                        'updated_at': row[5], 'last_login': row[6]
                    }
                return None
        except Exception as e:
            logger.error(f"User fetch failed: {e}")
            return None
    
    def save_order(self, order) -> bool:
        """ì£¼ë¬¸ ì €ì¥"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute("""
                    INSERT OR REPLACE INTO orders 
                    (id, user_id, symbol, side, order_type, quantity, price, 
                     stop_price, status, filled_quantity, average_price, 
                     commission, created_at, updated_at, expires_at)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    order.id, order.user_id, order.symbol, order.side.value,
                    order.order_type.value, order.quantity, order.price,
                    order.stop_price, order.status.value, order.filled_quantity,
                    order.average_price, order.commission, order.created_at,
                    order.updated_at, order.expires_at
                ))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"Order save failed: {e}")
            return False
    
    def get_user_orders(self, user_id: str) -> List[Dict[str, Any]]:
        """ì‚¬ìš©ì ì£¼ë¬¸ ëª©ë¡ ì¡°íšŒ"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT * FROM orders WHERE user_id = ? ORDER BY created_at DESC", (user_id,))
                rows = cursor.fetchall()
                
                orders = []
                for row in rows:
                    orders.append({
                        'id': row[0], 'user_id': row[1], 'symbol': row[2],
                        'side': row[3], 'order_type': row[4], 'quantity': row[5],
                        'price': row[6], 'stop_price': row[7], 'status': row[8],
                        'filled_quantity': row[9], 'average_price': row[10],
                        'commission': row[11], 'created_at': row[12],
                        'updated_at': row[13], 'expires_at': row[14]
                    })
                return orders
        except Exception as e:
            logger.error(f"User orders fetch failed: {e}")
            return []
```

## ğŸ“Š **ì„±ëŠ¥ ìµœì í™”**

### ğŸ¯ **í˜„ì‹¤ì  ì„±ëŠ¥ ëª©í‘œ**
- **ì‘ë‹µ ì‹œê°„**: < 200ms (ë„¤íŠ¸ì›Œí¬ ì§€ì—° ê³ ë ¤)
- **ì²˜ë¦¬ëŸ‰**: 100 TPS (API ì œí•œ ê³ ë ¤)
- **ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰**: < 1GB
- **CPU ì‚¬ìš©ë¥ **: < 70%

### ğŸ”§ **ìµœì í™” ì „ëµ**
1. **API ë ˆì´íŠ¸ ë¦¬ë°‹ ì¤€ìˆ˜**: 100ms ì§€ì—° ì¶”ê°€
2. **ë¹„ë™ê¸° ì²˜ë¦¬**: asyncio í™œìš©
3. **ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±**: ì ì ˆí•œ ë°ì´í„° êµ¬ì¡° ì‚¬ìš©
4. **ì—ëŸ¬ ì²˜ë¦¬**: ê²¬ê³ í•œ ì˜ˆì™¸ ì²˜ë¦¬

## ğŸ”’ **ë³´ì•ˆ ê³ ë ¤ì‚¬í•­**

### ğŸ›¡ï¸ **ê¸°ë³¸ ë³´ì•ˆ ìš”êµ¬ì‚¬í•­**
1. **API í‚¤ ê´€ë¦¬**: í™˜ê²½ ë³€ìˆ˜ ì‚¬ìš©
2. **ë°ì´í„° ê²€ì¦**: ì…ë ¥ê°’ ê²€ì¦ í•„ìˆ˜
3. **ë¡œê¹…**: ë³´ì•ˆ ì´ë²¤íŠ¸ ë¡œê¹…
4. **ì—ëŸ¬ ì²˜ë¦¬**: ë¯¼ê°í•œ ì •ë³´ ë…¸ì¶œ ë°©ì§€

### ğŸ“ **êµ¬í˜„ ì˜ˆì‹œ**
```python
import os
from typing import Optional

class SecurityManager:
    """ë³´ì•ˆ ê´€ë¦¬ì - ê¸°ë³¸ ê¸°ëŠ¥"""
    
    def __init__(self):
        self.api_key = os.getenv('BINANCE_API_KEY')
        self.api_secret = os.getenv('BINANCE_API_SECRET')
        
        if not self.api_key or not self.api_secret:
            raise ValueError("API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")
    
    def validate_api_key(self) -> bool:
        """API í‚¤ ìœ íš¨ì„± ê²€ì¦"""
        return len(self.api_key) > 0 and len(self.api_secret) > 0
    
    def mask_sensitive_data(self, data: str) -> str:
        """ë¯¼ê°í•œ ë°ì´í„° ë§ˆìŠ¤í‚¹"""
        if len(data) > 8:
            return data[:4] + '*' * (len(data) - 8) + data[-4:]
        return '*' * len(data)
```

## ğŸ“‹ **í…ŒìŠ¤íŠ¸ ê³„íš**

### ğŸ§ª **ë‹¨ìœ„ í…ŒìŠ¤íŠ¸**
- ì£¼ë¬¸ ëª¨ë¸ ê²€ì¦
- ì‚¬ìš©ì ê´€ë¦¬ ê¸°ëŠ¥
- ê±°ë˜ì†Œ ì—°ë™ ëª¨ë“ˆ
- ë°ì´í„°ë² ì´ìŠ¤ ì‘ì—…

### ğŸ”— **í†µí•© í…ŒìŠ¤íŠ¸**
- ì „ì²´ ì£¼ë¬¸ í”Œë¡œìš°
- ì‚¬ìš©ì-ì£¼ë¬¸ ì—°ë™
- ê±°ë˜ì†Œ-ì‹œìŠ¤í…œ ì—°ë™

### âš¡ **ì„±ëŠ¥ í…ŒìŠ¤íŠ¸**
- 100 TPS ë¶€í•˜ í…ŒìŠ¤íŠ¸
- 200ms ì‘ë‹µ ì‹œê°„ ê²€ì¦
- ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§

---

**Phase 0.1 ì™„ë£Œ ê¸°ì¤€**: ê¸°ë³¸ ì£¼ë¬¸ ê´€ë¦¬, ì‚¬ìš©ì ê´€ë¦¬, ê±°ë˜ì†Œ ì—°ë™, ë°ì´í„°ë² ì´ìŠ¤ ì„¤ê³„ ì™„ë£Œ 