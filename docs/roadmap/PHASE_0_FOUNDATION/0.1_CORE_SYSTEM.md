# 🔧 0.1 핵심 시스템

## 📋 **개요**

### 🎯 **목표**
- **안정성**: 99% 가동률 보장 (개인 개발자 기준)
- **성능**: < 200ms 응답 시간 (네트워크 지연 고려)
- **확장성**: 단계적 확장 가능한 아키텍처
- **보안**: 기본 보안 수준 (API 키 관리, SSL/TLS)

### 📊 **성과 지표**
- **시스템 가동률**: 99% 이상
- **응답 시간**: P95 < 200ms
- **처리량**: 100 TPS (API 제한 고려)
- **오류율**: < 1%

## 🏗️ **0.1.1 주문 관리 시스템**

### 📋 **구현 세부사항**

#### **주문 모델 설계**
```python
from dataclasses import dataclass
from datetime import datetime, timezone
from decimal import Decimal
from enum import Enum
from typing import Optional, Dict, Any

class OrderType(Enum):
    MARKET = "MARKET"
    LIMIT = "LIMIT"
    STOP = "STOP"
    STOP_LIMIT = "STOP_LIMIT"

class OrderSide(Enum):
    BUY = "BUY"
    SELL = "SELL"

class OrderStatus(Enum):
    PENDING = "PENDING"
    PARTIALLY_FILLED = "PARTIALLY_FILLED"
    FILLED = "FILLED"
    CANCELLED = "CANCELLED"
    REJECTED = "REJECTED"
    EXPIRED = "EXPIRED"

@dataclass
class Order:
    """주문 데이터 모델"""
    id: str
    user_id: str
    symbol: str
    side: OrderSide
    order_type: OrderType
    quantity: Decimal
    price: Optional[Decimal] = None
    stop_price: Optional[Decimal] = None
    status: OrderStatus = OrderStatus.PENDING
    filled_quantity: Decimal = Decimal('0')
    average_price: Optional[Decimal] = None
    commission: Decimal = Decimal('0')
    created_at: datetime = None
    updated_at: datetime = None
    expires_at: Optional[datetime] = None
    
    def __post_init__(self):
        if self.created_at is None:
            self.created_at = datetime.now(timezone.utc)
        if self.updated_at is None:
            self.updated_at = self.created_at
    
    @property
    def remaining_quantity(self) -> Decimal:
        """남은 수량 계산"""
        return self.quantity - self.filled_quantity
    
    @property
    def is_active(self) -> bool:
        """활성 주문 여부"""
        return self.status in [OrderStatus.PENDING, OrderStatus.PARTIALLY_FILLED]
    
    @property
    def total_value(self) -> Decimal:
        """주문 총 가치"""
        if self.price:
            return self.quantity * self.price
        return Decimal('0')
```

#### **주문 관리자 구현**
```python
import asyncio
import logging
from typing import List, Optional, Dict, Any
from decimal import Decimal
from datetime import datetime, timezone

from .models import Order, OrderStatus, OrderType, OrderSide
from .validators import OrderValidator
from .exceptions import OrderError, ValidationError

logger = logging.getLogger(__name__)

class OrderManager:
    """주문 관리자 - 기본 기능 중심"""
    
    def __init__(self, exchange_client, validator: OrderValidator):
        self.exchange_client = exchange_client
        self.validator = validator
        self.orders: Dict[str, Order] = {}
        self.order_queue = asyncio.Queue()
        self.processing_task = None
    
    async def place_order(self, order_data: Dict[str, Any]) -> Order:
        """주문 실행"""
        try:
            # 주문 검증
            self.validator.validate_order(order_data)
            
            # 주문 생성
            order = self._create_order(order_data)
            
            # 주문 저장
            self.orders[order.id] = order
            
            # 거래소에 주문 전송
            await self._send_to_exchange(order)
            
            logger.info(f"Order placed: {order.id}")
            return order
            
        except Exception as e:
            logger.error(f"Order placement failed: {e}")
            raise OrderError(f"주문 실행 실패: {e}")
    
    async def cancel_order(self, order_id: str) -> bool:
        """주문 취소"""
        try:
            order = self.orders.get(order_id)
            if not order:
                raise OrderError(f"주문을 찾을 수 없음: {order_id}")
            
            if not order.is_active:
                raise OrderError(f"취소할 수 없는 주문 상태: {order.status}")
            
            # 거래소에 취소 요청
            success = await self.exchange_client.cancel_order(order_id, order.symbol)
            
            if success:
                order.status = OrderStatus.CANCELLED
                order.updated_at = datetime.now(timezone.utc)
                logger.info(f"Order cancelled: {order_id}")
            
            return success
            
        except Exception as e:
            logger.error(f"Order cancellation failed: {e}")
            raise OrderError(f"주문 취소 실패: {e}")
    
    async def get_order(self, order_id: str) -> Optional[Order]:
        """주문 조회"""
        return self.orders.get(order_id)
    
    async def get_user_orders(self, user_id: str) -> List[Order]:
        """사용자 주문 목록 조회"""
        return [order for order in self.orders.values() if order.user_id == user_id]
    
    def _create_order(self, order_data: Dict[str, Any]) -> Order:
        """주문 객체 생성"""
        return Order(
            id=self._generate_order_id(),
            user_id=order_data['user_id'],
            symbol=order_data['symbol'],
            side=OrderSide(order_data['side']),
            order_type=OrderType(order_data['order_type']),
            quantity=Decimal(str(order_data['quantity'])),
            price=Decimal(str(order_data['price'])) if order_data.get('price') else None,
            stop_price=Decimal(str(order_data['stop_price'])) if order_data.get('stop_price') else None
        )
    
    def _generate_order_id(self) -> str:
        """주문 ID 생성"""
        return f"order_{datetime.now(timezone.utc).strftime('%Y%m%d_%H%M%S_%f')}"
    
    async def _send_to_exchange(self, order: Order):
        """거래소에 주문 전송"""
        try:
            # API 레이트 리밋 고려
            await asyncio.sleep(0.1)  # 100ms 지연
            
            result = await self.exchange_client.place_order(order)
            
            if result.get('success'):
                order.status = OrderStatus.PENDING
            else:
                order.status = OrderStatus.REJECTED
                raise OrderError(f"거래소 주문 실패: {result.get('error')}")
                
        except Exception as e:
            order.status = OrderStatus.REJECTED
            raise OrderError(f"거래소 연동 실패: {e}")
```

## 👤 **0.1.2 사용자 관리 시스템**

### 📋 **구현 세부사항**

#### **사용자 모델 설계**
```python
from dataclasses import dataclass
from datetime import datetime, timezone
from decimal import Decimal
from enum import Enum
from typing import Dict, Any, Optional

class UserStatus(Enum):
    ACTIVE = "ACTIVE"
    INACTIVE = "INACTIVE"
    SUSPENDED = "SUSPENDED"

@dataclass
class User:
    """사용자 데이터 모델"""
    id: str
    username: str
    email: str
    status: UserStatus = UserStatus.ACTIVE
    created_at: datetime = None
    updated_at: datetime = None
    last_login: Optional[datetime] = None
    
    def __post_init__(self):
        if self.created_at is None:
            self.created_at = datetime.now(timezone.utc)
        if self.updated_at is None:
            self.updated_at = self.created_at

@dataclass
class UserBalance:
    """사용자 잔고 모델"""
    user_id: str
    currency: str
    available: Decimal
    locked: Decimal = Decimal('0')
    total: Decimal = None
    
    def __post_init__(self):
        if self.total is None:
            self.total = self.available + self.locked
```

#### **사용자 관리자 구현**
```python
import logging
from typing import Dict, List, Optional
from decimal import Decimal
from datetime import datetime, timezone

from .models import User, UserBalance, UserStatus

logger = logging.getLogger(__name__)

class UserManager:
    """사용자 관리자 - 기본 기능 중심"""
    
    def __init__(self):
        self.users: Dict[str, User] = {}
        self.balances: Dict[str, Dict[str, UserBalance]] = {}
    
    def create_user(self, user_data: Dict[str, Any]) -> User:
        """사용자 생성"""
        try:
            user = User(
                id=self._generate_user_id(),
                username=user_data['username'],
                email=user_data['email']
            )
            
            self.users[user.id] = user
            self.balances[user.id] = {}
            
            logger.info(f"User created: {user.id}")
            return user
            
        except Exception as e:
            logger.error(f"User creation failed: {e}")
            raise ValueError(f"사용자 생성 실패: {e}")
    
    def get_user(self, user_id: str) -> Optional[User]:
        """사용자 조회"""
        return self.users.get(user_id)
    
    def update_user_status(self, user_id: str, status: UserStatus) -> bool:
        """사용자 상태 업데이트"""
        user = self.users.get(user_id)
        if not user:
            return False
        
        user.status = status
        user.updated_at = datetime.now(timezone.utc)
        logger.info(f"User status updated: {user_id} -> {status}")
        return True
    
    def get_user_balance(self, user_id: str, currency: str) -> Optional[UserBalance]:
        """사용자 잔고 조회"""
        user_balances = self.balances.get(user_id, {})
        return user_balances.get(currency)
    
    def update_balance(self, user_id: str, currency: str, 
                      available: Decimal, locked: Decimal = Decimal('0')):
        """잔고 업데이트"""
        if user_id not in self.balances:
            self.balances[user_id] = {}
        
        self.balances[user_id][currency] = UserBalance(
            user_id=user_id,
            currency=currency,
            available=available,
            locked=locked
        )
        
        logger.info(f"Balance updated: {user_id} {currency} {available}")
    
    def _generate_user_id(self) -> str:
        """사용자 ID 생성"""
        return f"user_{datetime.now(timezone.utc).strftime('%Y%m%d_%H%M%S_%f')}"
```

## 🔗 **0.1.3 거래소 연동 시스템**

### 📋 **구현 세부사항**

#### **거래소 클라이언트 구현**
```python
import aiohttp
import asyncio
import hmac
import hashlib
import time
import logging
from typing import Dict, Any, Optional
from decimal import Decimal

logger = logging.getLogger(__name__)

class ExchangeClient:
    """거래소 클라이언트 - Binance 중심"""
    
    def __init__(self, api_key: str, api_secret: str, testnet: bool = True):
        self.api_key = api_key
        self.api_secret = api_secret
        self.base_url = "https://testnet.binance.vision" if testnet else "https://api.binance.com"
        self.session = None
        self.rate_limit_delay = 0.1  # 100ms (API 제한 고려)
    
    async def __aenter__(self):
        self.session = aiohttp.ClientSession()
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if self.session:
            await self.session.close()
    
    async def place_order(self, order) -> Dict[str, Any]:
        """주문 실행"""
        try:
            # API 레이트 리밋 고려
            await asyncio.sleep(self.rate_limit_delay)
            
            params = {
                'symbol': order.symbol,
                'side': order.side.value,
                'type': order.order_type.value,
                'quantity': str(order.quantity)
            }
            
            if order.price:
                params['price'] = str(order.price)
            if order.stop_price:
                params['stopPrice'] = str(order.stop_price)
            
            # 서명 생성
            signature = self._create_signature(params)
            params['signature'] = signature
            
            headers = {'X-MBX-APIKEY': self.api_key}
            
            async with self.session.post(
                f"{self.base_url}/api/v3/order",
                params=params,
                headers=headers
            ) as response:
                result = await response.json()
                
                if response.status == 200:
                    return {'success': True, 'data': result}
                else:
                    return {'success': False, 'error': result.get('msg', 'Unknown error')}
                    
        except Exception as e:
            logger.error(f"Order placement failed: {e}")
            return {'success': False, 'error': str(e)}
    
    async def cancel_order(self, order_id: str, symbol: str) -> bool:
        """주문 취소"""
        try:
            await asyncio.sleep(self.rate_limit_delay)
            
            params = {
                'symbol': symbol,
                'orderId': order_id
            }
            
            signature = self._create_signature(params)
            params['signature'] = signature
            
            headers = {'X-MBX-APIKEY': self.api_key}
            
            async with self.session.delete(
                f"{self.base_url}/api/v3/order",
                params=params,
                headers=headers
            ) as response:
                result = await response.json()
                return response.status == 200
                
        except Exception as e:
            logger.error(f"Order cancellation failed: {e}")
            return False
    
    async def get_account_info(self) -> Dict[str, Any]:
        """계정 정보 조회"""
        try:
            await asyncio.sleep(self.rate_limit_delay)
            
            params = {}
            signature = self._create_signature(params)
            params['signature'] = signature
            
            headers = {'X-MBX-APIKEY': self.api_key}
            
            async with self.session.get(
                f"{self.base_url}/api/v3/account",
                params=params,
                headers=headers
            ) as response:
                return await response.json()
                
        except Exception as e:
            logger.error(f"Account info fetch failed: {e}")
            return {}
    
    def _create_signature(self, params: Dict[str, Any]) -> str:
        """API 서명 생성"""
        query_string = '&'.join([f"{k}={v}" for k, v in params.items()])
        return hmac.new(
            self.api_secret.encode('utf-8'),
            query_string.encode('utf-8'),
            hashlib.sha256
        ).hexdigest()
```

## 🗄️ **0.1.4 데이터베이스 설계**

### 📋 **구현 세부사항**

#### **SQLite 기반 데이터베이스 설계**
```python
import sqlite3
import logging
from typing import Dict, Any, List, Optional
from datetime import datetime, timezone
from decimal import Decimal

logger = logging.getLogger(__name__)

class DatabaseManager:
    """데이터베이스 관리자 - SQLite 기반"""
    
    def __init__(self, db_path: str = "data/trading_system.db"):
        self.db_path = db_path
        self.init_database()
    
    def init_database(self):
        """데이터베이스 초기화"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                
                # 사용자 테이블
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS users (
                        id TEXT PRIMARY KEY,
                        username TEXT UNIQUE NOT NULL,
                        email TEXT UNIQUE NOT NULL,
                        status TEXT NOT NULL,
                        created_at TIMESTAMP NOT NULL,
                        updated_at TIMESTAMP NOT NULL,
                        last_login TIMESTAMP
                    )
                """)
                
                # 주문 테이블
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS orders (
                        id TEXT PRIMARY KEY,
                        user_id TEXT NOT NULL,
                        symbol TEXT NOT NULL,
                        side TEXT NOT NULL,
                        order_type TEXT NOT NULL,
                        quantity DECIMAL(20,8) NOT NULL,
                        price DECIMAL(20,8),
                        stop_price DECIMAL(20,8),
                        status TEXT NOT NULL,
                        filled_quantity DECIMAL(20,8) DEFAULT 0,
                        average_price DECIMAL(20,8),
                        commission DECIMAL(20,8) DEFAULT 0,
                        created_at TIMESTAMP NOT NULL,
                        updated_at TIMESTAMP NOT NULL,
                        expires_at TIMESTAMP,
                        FOREIGN KEY (user_id) REFERENCES users (id)
                    )
                """)
                
                # 잔고 테이블
                cursor.execute("""
                    CREATE TABLE IF NOT EXISTS balances (
                        user_id TEXT NOT NULL,
                        currency TEXT NOT NULL,
                        available DECIMAL(20,8) NOT NULL,
                        locked DECIMAL(20,8) DEFAULT 0,
                        total DECIMAL(20,8) NOT NULL,
                        updated_at TIMESTAMP NOT NULL,
                        PRIMARY KEY (user_id, currency),
                        FOREIGN KEY (user_id) REFERENCES users (id)
                    )
                """)
                
                # 인덱스 생성
                cursor.execute("CREATE INDEX IF NOT EXISTS idx_orders_user_id ON orders (user_id)")
                cursor.execute("CREATE INDEX IF NOT EXISTS idx_orders_status ON orders (status)")
                cursor.execute("CREATE INDEX IF NOT EXISTS idx_orders_symbol ON orders (symbol)")
                
                conn.commit()
                logger.info("Database initialized successfully")
                
        except Exception as e:
            logger.error(f"Database initialization failed: {e}")
            raise
    
    def save_user(self, user) -> bool:
        """사용자 저장"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute("""
                    INSERT OR REPLACE INTO users 
                    (id, username, email, status, created_at, updated_at, last_login)
                    VALUES (?, ?, ?, ?, ?, ?, ?)
                """, (
                    user.id, user.username, user.email, user.status.value,
                    user.created_at, user.updated_at, user.last_login
                ))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"User save failed: {e}")
            return False
    
    def get_user(self, user_id: str) -> Optional[Dict[str, Any]]:
        """사용자 조회"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT * FROM users WHERE id = ?", (user_id,))
                row = cursor.fetchone()
                
                if row:
                    return {
                        'id': row[0], 'username': row[1], 'email': row[2],
                        'status': row[3], 'created_at': row[4],
                        'updated_at': row[5], 'last_login': row[6]
                    }
                return None
        except Exception as e:
            logger.error(f"User fetch failed: {e}")
            return None
    
    def save_order(self, order) -> bool:
        """주문 저장"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute("""
                    INSERT OR REPLACE INTO orders 
                    (id, user_id, symbol, side, order_type, quantity, price, 
                     stop_price, status, filled_quantity, average_price, 
                     commission, created_at, updated_at, expires_at)
                    VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
                """, (
                    order.id, order.user_id, order.symbol, order.side.value,
                    order.order_type.value, order.quantity, order.price,
                    order.stop_price, order.status.value, order.filled_quantity,
                    order.average_price, order.commission, order.created_at,
                    order.updated_at, order.expires_at
                ))
                conn.commit()
                return True
        except Exception as e:
            logger.error(f"Order save failed: {e}")
            return False
    
    def get_user_orders(self, user_id: str) -> List[Dict[str, Any]]:
        """사용자 주문 목록 조회"""
        try:
            with sqlite3.connect(self.db_path) as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT * FROM orders WHERE user_id = ? ORDER BY created_at DESC", (user_id,))
                rows = cursor.fetchall()
                
                orders = []
                for row in rows:
                    orders.append({
                        'id': row[0], 'user_id': row[1], 'symbol': row[2],
                        'side': row[3], 'order_type': row[4], 'quantity': row[5],
                        'price': row[6], 'stop_price': row[7], 'status': row[8],
                        'filled_quantity': row[9], 'average_price': row[10],
                        'commission': row[11], 'created_at': row[12],
                        'updated_at': row[13], 'expires_at': row[14]
                    })
                return orders
        except Exception as e:
            logger.error(f"User orders fetch failed: {e}")
            return []
```

## 📊 **성능 최적화**

### 🎯 **현실적 성능 목표**
- **응답 시간**: < 200ms (네트워크 지연 고려)
- **처리량**: 100 TPS (API 제한 고려)
- **메모리 사용량**: < 1GB
- **CPU 사용률**: < 70%

### 🔧 **최적화 전략**
1. **API 레이트 리밋 준수**: 100ms 지연 추가
2. **비동기 처리**: asyncio 활용
3. **메모리 효율성**: 적절한 데이터 구조 사용
4. **에러 처리**: 견고한 예외 처리

## 🔒 **보안 고려사항**

### 🛡️ **기본 보안 요구사항**
1. **API 키 관리**: 환경 변수 사용
2. **데이터 검증**: 입력값 검증 필수
3. **로깅**: 보안 이벤트 로깅
4. **에러 처리**: 민감한 정보 노출 방지

### 📝 **구현 예시**
```python
import os
from typing import Optional

class SecurityManager:
    """보안 관리자 - 기본 기능"""
    
    def __init__(self):
        self.api_key = os.getenv('BINANCE_API_KEY')
        self.api_secret = os.getenv('BINANCE_API_SECRET')
        
        if not self.api_key or not self.api_secret:
            raise ValueError("API 키가 설정되지 않았습니다")
    
    def validate_api_key(self) -> bool:
        """API 키 유효성 검증"""
        return len(self.api_key) > 0 and len(self.api_secret) > 0
    
    def mask_sensitive_data(self, data: str) -> str:
        """민감한 데이터 마스킹"""
        if len(data) > 8:
            return data[:4] + '*' * (len(data) - 8) + data[-4:]
        return '*' * len(data)
```

## 📋 **테스트 계획**

### 🧪 **단위 테스트**
- 주문 모델 검증
- 사용자 관리 기능
- 거래소 연동 모듈
- 데이터베이스 작업

### 🔗 **통합 테스트**
- 전체 주문 플로우
- 사용자-주문 연동
- 거래소-시스템 연동

### ⚡ **성능 테스트**
- 100 TPS 부하 테스트
- 200ms 응답 시간 검증
- 메모리 사용량 모니터링

---

**Phase 0.1 완료 기준**: 기본 주문 관리, 사용자 관리, 거래소 연동, 데이터베이스 설계 완료 