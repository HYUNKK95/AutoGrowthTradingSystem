# ğŸ’° 0.2 ê¸°ë³¸ ê±°ë˜ ê¸°ëŠ¥

## ğŸ“‹ **ê°œìš”**

### ğŸ¯ **ëª©í‘œ**
- **ì•ˆì •ì„±**: 99% ê±°ë˜ ì„±ê³µë¥  (ê°œì¸ ê°œë°œì ê¸°ì¤€)
- **ì„±ëŠ¥**: < 200ms ì£¼ë¬¸ ì‹¤í–‰ ì‹œê°„ (ë„¤íŠ¸ì›Œí¬ ì§€ì—° ê³ ë ¤)
- **ì •í™•ì„±**: 99% í¬ì§€ì…˜ ê³„ì‚° ì •í™•ë„
- **ì•ˆì „ì„±**: ê¸°ë³¸ ë¦¬ìŠ¤í¬ ê´€ë¦¬ ì‹œìŠ¤í…œ êµ¬ì¶•

### ğŸ“Š **ì„±ê³¼ ì§€í‘œ**
- **ì£¼ë¬¸ ì‹¤í–‰ ì‹œê°„**: P95 < 200ms
- **ê±°ë˜ ì„±ê³µë¥ **: 99% ì´ìƒ
- **í¬ì§€ì…˜ ê³„ì‚° ì •í™•ë„**: 99%
- **ë¦¬ìŠ¤í¬ ê´€ë¦¬ íš¨ìœ¨ì„±**: 90% ì´ìƒ

## ğŸš€ **0.2.1 ì£¼ë¬¸ ì‹¤í–‰ ì—”ì§„**

### ğŸ“‹ **êµ¬í˜„ ì„¸ë¶€ì‚¬í•­**

#### **ì£¼ë¬¸ ì‹¤í–‰ ì—”ì§„ ì„¤ê³„**
```python
import asyncio
import logging
from typing import Dict, Any, Optional, List
from decimal import Decimal
from datetime import datetime, timezone
from enum import Enum

from .models import Order, OrderType, OrderSide, OrderStatus
from .exceptions import OrderExecutionError, InsufficientBalanceError

logger = logging.getLogger(__name__)

class ExecutionEngine:
    """ì£¼ë¬¸ ì‹¤í–‰ ì—”ì§„ - ê¸°ë³¸ ê¸°ëŠ¥ ì¤‘ì‹¬"""
    
    def __init__(self, exchange_client, balance_manager, risk_manager):
        self.exchange_client = exchange_client
        self.balance_manager = balance_manager
        self.risk_manager = risk_manager
        self.execution_queue = asyncio.Queue()
        self.execution_task = None
        self._running = False
        self.rate_limit_delay = 0.1  # 100ms (API ì œí•œ ê³ ë ¤)
    
    async def start(self):
        """ì‹¤í–‰ ì—”ì§„ ì‹œì‘"""
        if not self._running:
            self._running = True
            self.execution_task = asyncio.create_task(self._execution_loop())
            logger.info("Order execution engine started")
    
    async def stop(self):
        """ì‹¤í–‰ ì—”ì§„ ì¤‘ì§€"""
        if self._running:
            self._running = False
            if self.execution_task:
                self.execution_task.cancel()
                try:
                    await self.execution_task
                except asyncio.CancelledError:
                    pass
            logger.info("Order execution engine stopped")
    
    async def submit_order(self, order: Order) -> bool:
        """ì£¼ë¬¸ ì œì¶œ"""
        try:
            # 1. ì£¼ë¬¸ ê²€ì¦
            if not await self._validate_order(order):
                return False
            
            # 2. ì”ê³  í™•ì¸
            if not await self._check_balance(order):
                return False
            
            # 3. ë¦¬ìŠ¤í¬ ê²€ì¦
            if not await self._check_risk(order):
                return False
            
            # 4. ì‹¤í–‰ íì— ì¶”ê°€
            await self.execution_queue.put(order)
            logger.info(f"Order submitted for execution: {order.id}")
            return True
            
        except Exception as e:
            logger.error(f"Order submission failed: {order.id}, error: {e}")
            return False
    
    async def _execution_loop(self):
        """ì£¼ë¬¸ ì‹¤í–‰ ë£¨í”„"""
        while self._running:
            try:
                # íì—ì„œ ì£¼ë¬¸ ê°€ì ¸ì˜¤ê¸° (1ì´ˆ íƒ€ì„ì•„ì›ƒ)
                order = await asyncio.wait_for(self.execution_queue.get(), timeout=1.0)
                
                # API ë ˆì´íŠ¸ ë¦¬ë°‹ ê³ ë ¤
                await asyncio.sleep(self.rate_limit_delay)
                
                # ì£¼ë¬¸ ì‹¤í–‰
                success = await self._execute_order(order)
                
                if success:
                    logger.info(f"Order executed successfully: {order.id}")
                else:
                    logger.error(f"Order execution failed: {order.id}")
                    
            except asyncio.TimeoutError:
                continue
            except Exception as e:
                logger.error(f"Execution loop error: {e}")
    
    async def _validate_order(self, order: Order) -> bool:
        """ì£¼ë¬¸ ê²€ì¦"""
        try:
            # ê¸°ë³¸ ê²€ì¦
            if not order.symbol or not order.quantity or order.quantity <= 0:
                logger.error(f"Invalid order data: {order.id}")
                return False
            
            # ì£¼ë¬¸ íƒ€ì…ë³„ ê²€ì¦
            if order.order_type == OrderType.LIMIT and not order.price:
                logger.error(f"Limit order without price: {order.id}")
                return False
            
            if order.order_type == OrderType.STOP and not order.stop_price:
                logger.error(f"Stop order without stop price: {order.id}")
                return False
            
            return True
            
        except Exception as e:
            logger.error(f"Order validation failed: {e}")
            return False
    
    async def _check_balance(self, order: Order) -> bool:
        """ì”ê³  í™•ì¸"""
        try:
            # í•„ìš”í•œ ì”ê³  ê³„ì‚°
            required_balance = await self.balance_manager.calculate_required_balance(order)
            
            # ì‚¬ìš© ê°€ëŠ¥í•œ ì”ê³  í™•ì¸
            available_balance = await self.balance_manager.get_available_balance(
                order.user_id, order.symbol.split('/')[1]  # USDT, BTC ë“±
            )
            
            if available_balance < required_balance:
                logger.error(f"Insufficient balance: {order.id}")
                return False
            
            return True
            
        except Exception as e:
            logger.error(f"Balance check failed: {e}")
            return False
    
    async def _check_risk(self, order: Order) -> bool:
        """ë¦¬ìŠ¤í¬ ê²€ì¦"""
        try:
            # ê¸°ë³¸ ë¦¬ìŠ¤í¬ ê²€ì¦
            risk_check = await self.risk_manager.validate_order(order)
            
            if not risk_check['valid']:
                logger.error(f"Risk validation failed: {order.id}, reason: {risk_check['reason']}")
                return False
            
            return True
            
        except Exception as e:
            logger.error(f"Risk check failed: {e}")
            return False
    
    async def _execute_order(self, order: Order) -> bool:
        """ì£¼ë¬¸ ì‹¤í–‰"""
        try:
            # ê±°ë˜ì†Œì— ì£¼ë¬¸ ì „ì†¡
            result = await self.exchange_client.place_order(order)
            
            if result.get('success'):
                # ì£¼ë¬¸ ìƒíƒœ ì—…ë°ì´íŠ¸
                order.status = OrderStatus.PENDING
                order.updated_at = datetime.now(timezone.utc)
                
                # ì”ê³  ì—…ë°ì´íŠ¸
                await self.balance_manager.lock_balance(order)
                
                logger.info(f"Order placed successfully: {order.id}")
                return True
            else:
                # ì£¼ë¬¸ ì‹¤íŒ¨ ì²˜ë¦¬
                order.status = OrderStatus.REJECTED
                order.updated_at = datetime.now(timezone.utc)
                
                logger.error(f"Order placement failed: {order.id}, error: {result.get('error')}")
                return False
                
        except Exception as e:
            logger.error(f"Order execution failed: {order.id}, error: {e}")
            return False
```

## ğŸ“Š **0.2.2 í¬ì§€ì…˜ ê´€ë¦¬**

### ğŸ“‹ **êµ¬í˜„ ì„¸ë¶€ì‚¬í•­**

#### **í¬ì§€ì…˜ ê´€ë¦¬ì êµ¬í˜„**
```python
import logging
from typing import Dict, List, Optional
from decimal import Decimal
from datetime import datetime, timezone

from .models import Order, OrderSide, OrderStatus

logger = logging.getLogger(__name__)

class PositionManager:
    """í¬ì§€ì…˜ ê´€ë¦¬ì - ê¸°ë³¸ ê¸°ëŠ¥ ì¤‘ì‹¬"""
    
    def __init__(self):
        self.positions: Dict[str, Dict[str, 'Position']] = {}  # user_id -> symbol -> Position
    
    async def update_position(self, order: Order, fill_quantity: Decimal, 
                            fill_price: Decimal) -> bool:
        """í¬ì§€ì…˜ ì—…ë°ì´íŠ¸"""
        try:
            user_id = order.user_id
            symbol = order.symbol
            
            # ì‚¬ìš©ì í¬ì§€ì…˜ ì´ˆê¸°í™”
            if user_id not in self.positions:
                self.positions[user_id] = {}
            
            if symbol not in self.positions[user_id]:
                self.positions[user_id][symbol] = Position(user_id, symbol)
            
            position = self.positions[user_id][symbol]
            
            # í¬ì§€ì…˜ ì—…ë°ì´íŠ¸
            if order.side == OrderSide.BUY:
                position.add_long(fill_quantity, fill_price)
            else:
                position.add_short(fill_quantity, fill_price)
            
            # ì£¼ë¬¸ ìƒíƒœ ì—…ë°ì´íŠ¸
            order.filled_quantity += fill_quantity
            if order.filled_quantity >= order.quantity:
                order.status = OrderStatus.FILLED
            else:
                order.status = OrderStatus.PARTIALLY_FILLED
            
            order.updated_at = datetime.now(timezone.utc)
            
            logger.info(f"Position updated: {user_id} {symbol} {fill_quantity} @ {fill_price}")
            return True
            
        except Exception as e:
            logger.error(f"Position update failed: {e}")
            return False
    
    async def get_position(self, user_id: str, symbol: str) -> Optional['Position']:
        """í¬ì§€ì…˜ ì¡°íšŒ"""
        try:
            user_positions = self.positions.get(user_id, {})
            return user_positions.get(symbol)
        except Exception as e:
            logger.error(f"Position retrieval failed: {e}")
            return None
    
    async def get_user_positions(self, user_id: str) -> List['Position']:
        """ì‚¬ìš©ì í¬ì§€ì…˜ ëª©ë¡ ì¡°íšŒ"""
        try:
            user_positions = self.positions.get(user_id, {})
            return list(user_positions.values())
        except Exception as e:
            logger.error(f"User positions retrieval failed: {e}")
            return []
    
    async def calculate_pnl(self, user_id: str, symbol: str, 
                          current_price: Decimal) -> Dict[str, Decimal]:
        """ì†ìµ ê³„ì‚°"""
        try:
            position = await self.get_position(user_id, symbol)
            if not position:
                return {'unrealized_pnl': Decimal('0'), 'realized_pnl': Decimal('0')}
            
            return position.calculate_pnl(current_price)
            
        except Exception as e:
            logger.error(f"PnL calculation failed: {e}")
            return {'unrealized_pnl': Decimal('0'), 'realized_pnl': Decimal('0')}

class Position:
    """í¬ì§€ì…˜ ëª¨ë¸"""
    
    def __init__(self, user_id: str, symbol: str):
        self.user_id = user_id
        self.symbol = symbol
        self.long_quantity = Decimal('0')
        self.short_quantity = Decimal('0')
        self.long_avg_price = Decimal('0')
        self.short_avg_price = Decimal('0')
        self.realized_pnl = Decimal('0')
        self.created_at = datetime.now(timezone.utc)
        self.updated_at = datetime.now(timezone.utc)
    
    def add_long(self, quantity: Decimal, price: Decimal):
        """ë¡± í¬ì§€ì…˜ ì¶”ê°€"""
        if self.long_quantity == 0:
            self.long_avg_price = price
        else:
            # í‰ê·  ê°€ê²© ê³„ì‚°
            total_value = self.long_quantity * self.long_avg_price + quantity * price
            self.long_avg_price = total_value / (self.long_quantity + quantity)
        
        self.long_quantity += quantity
        self.updated_at = datetime.now(timezone.utc)
    
    def add_short(self, quantity: Decimal, price: Decimal):
        """ìˆ í¬ì§€ì…˜ ì¶”ê°€"""
        if self.short_quantity == 0:
            self.short_avg_price = price
        else:
            # í‰ê·  ê°€ê²© ê³„ì‚°
            total_value = self.short_quantity * self.short_avg_price + quantity * price
            self.short_avg_price = total_value / (self.short_quantity + quantity)
        
        self.short_quantity += quantity
        self.updated_at = datetime.now(timezone.utc)
    
    def calculate_pnl(self, current_price: Decimal) -> Dict[str, Decimal]:
        """ì†ìµ ê³„ì‚°"""
        # ë¯¸ì‹¤í˜„ ì†ìµ
        long_pnl = (current_price - self.long_avg_price) * self.long_quantity if self.long_quantity > 0 else Decimal('0')
        short_pnl = (self.short_avg_price - current_price) * self.short_quantity if self.short_quantity > 0 else Decimal('0')
        
        unrealized_pnl = long_pnl + short_pnl
        
        return {
            'unrealized_pnl': unrealized_pnl,
            'realized_pnl': self.realized_pnl,
            'total_pnl': unrealized_pnl + self.realized_pnl
        }
    
    @property
    def net_quantity(self) -> Decimal:
        """ìˆœ í¬ì§€ì…˜ ìˆ˜ëŸ‰"""
        return self.long_quantity - self.short_quantity
    
    @property
    def is_long(self) -> bool:
        """ë¡± í¬ì§€ì…˜ ì—¬ë¶€"""
        return self.net_quantity > 0
    
    @property
    def is_short(self) -> bool:
        """ìˆ í¬ì§€ì…˜ ì—¬ë¶€"""
        return self.net_quantity < 0
    
    @property
    def is_flat(self) -> bool:
        """í‰í¬ì§€ì…˜ ì—¬ë¶€"""
        return self.net_quantity == 0
```

## ğŸ›¡ï¸ **0.2.3 ë¦¬ìŠ¤í¬ ê´€ë¦¬**

### ğŸ“‹ **êµ¬í˜„ ì„¸ë¶€ì‚¬í•­**

#### **ë¦¬ìŠ¤í¬ ê´€ë¦¬ì êµ¬í˜„**
```python
import logging
from typing import Dict, Any, Optional
from decimal import Decimal
from datetime import datetime, timezone

from .models import Order, OrderSide

logger = logging.getLogger(__name__)

class RiskManager:
    """ë¦¬ìŠ¤í¬ ê´€ë¦¬ì - ê¸°ë³¸ ê¸°ëŠ¥ ì¤‘ì‹¬"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.max_position_size = Decimal(str(config.get('max_position_size', '100000')))
        self.max_daily_loss = Decimal(str(config.get('max_daily_loss', '10000')))
        self.stop_loss_pct = Decimal(str(config.get('stop_loss_pct', '0.05')))  # 5%
        self.take_profit_pct = Decimal(str(config.get('take_profit_pct', '0.10')))  # 10%
        
        # ì¼ì¼ ê±°ë˜ ê¸°ë¡
        self.daily_trades: Dict[str, Dict[str, Any]] = {}
        self.daily_pnl: Dict[str, Decimal] = {}
    
    async def validate_order(self, order: Order) -> Dict[str, Any]:
        """ì£¼ë¬¸ ë¦¬ìŠ¤í¬ ê²€ì¦"""
        try:
            user_id = order.user_id
            
            # 1. í¬ì§€ì…˜ í¬ê¸° ê²€ì¦
            position_check = await self._check_position_size(order)
            if not position_check['valid']:
                return {
                    'valid': False,
                    'reason': f"Position size exceeds limit: {position_check['reason']}"
                }
            
            # 2. ì¼ì¼ ì†ì‹¤ í•œë„ ê²€ì¦
            daily_loss_check = await self._check_daily_loss(user_id, order)
            if not daily_loss_check['valid']:
                return {
                    'valid': False,
                    'reason': f"Daily loss limit exceeded: {daily_loss_check['reason']}"
                }
            
            # 3. ì£¼ë¬¸ í¬ê¸° ê²€ì¦
            order_size_check = await self._check_order_size(order)
            if not order_size_check['valid']:
                return {
                    'valid': False,
                    'reason': f"Order size exceeds limit: {order_size_check['reason']}"
                }
            
            return {'valid': True, 'reason': 'Risk validation passed'}
            
        except Exception as e:
            logger.error(f"Risk validation failed: {e}")
            return {'valid': False, 'reason': f'Risk validation error: {e}'}
    
    async def _check_position_size(self, order: Order) -> Dict[str, Any]:
        """í¬ì§€ì…˜ í¬ê¸° ê²€ì¦"""
        try:
            # ì£¼ë¬¸ ê°€ì¹˜ ê³„ì‚°
            if order.price:
                order_value = order.quantity * order.price
            else:
                # ì‹œì¥ê°€ ì£¼ë¬¸ì˜ ê²½ìš° ì¶”ì • ê°€ì¹˜ ì‚¬ìš©
                order_value = order.quantity * Decimal('50000')  # ì˜ˆì‹œ ê°€ê²©
            
            if order_value > self.max_position_size:
                return {
                    'valid': False,
                    'reason': f"Order value {order_value} exceeds max position size {self.max_position_size}"
                }
            
            return {'valid': True}
            
        except Exception as e:
            logger.error(f"Position size check failed: {e}")
            return {'valid': False, 'reason': str(e)}
    
    async def _check_daily_loss(self, user_id: str, order: Order) -> Dict[str, Any]:
        """ì¼ì¼ ì†ì‹¤ í•œë„ ê²€ì¦"""
        try:
            today = datetime.now(timezone.utc).date().isoformat()
            
            # ì˜¤ëŠ˜ì˜ ì†ìµ ì¡°íšŒ
            daily_pnl = self.daily_pnl.get(f"{user_id}_{today}", Decimal('0'))
            
            # ì˜ˆìƒ ì†ì‹¤ ê³„ì‚° (ë§¤ìˆ˜ ì£¼ë¬¸ì˜ ê²½ìš°)
            if order.side == OrderSide.BUY:
                estimated_loss = order.quantity * order.price * self.stop_loss_pct
            else:
                estimated_loss = Decimal('0')  # ë§¤ë„ëŠ” ì†ì‹¤ ìœ„í—˜ì´ ë‚®ìŒ
            
            if daily_pnl - estimated_loss < -self.max_daily_loss:
                return {
                    'valid': False,
                    'reason': f"Daily loss would exceed limit: {daily_pnl - estimated_loss}"
                }
            
            return {'valid': True}
            
        except Exception as e:
            logger.error(f"Daily loss check failed: {e}")
            return {'valid': False, 'reason': str(e)}
    
    async def _check_order_size(self, order: Order) -> Dict[str, Any]:
        """ì£¼ë¬¸ í¬ê¸° ê²€ì¦"""
        try:
            # ìµœì†Œ ì£¼ë¬¸ í¬ê¸° ê²€ì¦
            min_order_size = Decimal(str(self.config.get('min_order_size', '10')))
            
            if order.quantity < min_order_size:
                return {
                    'valid': False,
                    'reason': f"Order quantity {order.quantity} below minimum {min_order_size}"
                }
            
            return {'valid': True}
            
        except Exception as e:
            logger.error(f"Order size check failed: {e}")
            return {'valid': False, 'reason': str(e)}
    
    async def update_daily_pnl(self, user_id: str, pnl: Decimal):
        """ì¼ì¼ ì†ìµ ì—…ë°ì´íŠ¸"""
        try:
            today = datetime.now(timezone.utc).date().isoformat()
            key = f"{user_id}_{today}"
            
            current_pnl = self.daily_pnl.get(key, Decimal('0'))
            self.daily_pnl[key] = current_pnl + pnl
            
            logger.info(f"Daily PnL updated: {user_id} {today} {self.daily_pnl[key]}")
            
        except Exception as e:
            logger.error(f"Daily PnL update failed: {e}")
    
    async def check_stop_loss(self, user_id: str, symbol: str, 
                            current_price: Decimal, position: 'Position') -> bool:
        """ìŠ¤íƒ‘ë¡œìŠ¤ ê²€ì¦"""
        try:
            if position.is_long:
                # ë¡± í¬ì§€ì…˜ ìŠ¤íƒ‘ë¡œìŠ¤
                stop_price = position.long_avg_price * (1 - self.stop_loss_pct)
                if current_price <= stop_price:
                    logger.warning(f"Stop loss triggered: {user_id} {symbol} {current_price}")
                    return True
            elif position.is_short:
                # ìˆ í¬ì§€ì…˜ ìŠ¤íƒ‘ë¡œìŠ¤
                stop_price = position.short_avg_price * (1 + self.stop_loss_pct)
                if current_price >= stop_price:
                    logger.warning(f"Stop loss triggered: {user_id} {symbol} {current_price}")
                    return True
            
            return False
            
        except Exception as e:
            logger.error(f"Stop loss check failed: {e}")
            return False
    
    async def check_take_profit(self, user_id: str, symbol: str, 
                              current_price: Decimal, position: 'Position') -> bool:
        """í…Œì´í¬í”„ë¡œí• ê²€ì¦"""
        try:
            if position.is_long:
                # ë¡± í¬ì§€ì…˜ í…Œì´í¬í”„ë¡œí•
                take_profit_price = position.long_avg_price * (1 + self.take_profit_pct)
                if current_price >= take_profit_price:
                    logger.info(f"Take profit triggered: {user_id} {symbol} {current_price}")
                    return True
            elif position.is_short:
                # ìˆ í¬ì§€ì…˜ í…Œì´í¬í”„ë¡œí•
                take_profit_price = position.short_avg_price * (1 - self.take_profit_pct)
                if current_price <= take_profit_price:
                    logger.info(f"Take profit triggered: {user_id} {symbol} {current_price}")
                    return True
            
            return False
            
        except Exception as e:
            logger.error(f"Take profit check failed: {e}")
            return False
```

## ğŸ“ˆ **0.2.4 ìˆ˜ìµë¥  ê³„ì‚°**

### ğŸ“‹ **êµ¬í˜„ ì„¸ë¶€ì‚¬í•­**

#### **ìˆ˜ìµë¥  ê³„ì‚°ê¸° êµ¬í˜„**
```python
import logging
from typing import Dict, List, Optional
from decimal import Decimal
from datetime import datetime, timezone, timedelta

logger = logging.getLogger(__name__)

class PerformanceCalculator:
    """ìˆ˜ìµë¥  ê³„ì‚°ê¸° - ê¸°ë³¸ ê¸°ëŠ¥ ì¤‘ì‹¬"""
    
    def __init__(self):
        self.trade_history: List[Dict[str, Any]] = []
    
    async def calculate_returns(self, user_id: str, 
                              start_date: datetime, 
                              end_date: datetime) -> Dict[str, Any]:
        """ìˆ˜ìµë¥  ê³„ì‚°"""
        try:
            # ê¸°ê°„ ë‚´ ê±°ë˜ í•„í„°ë§
            period_trades = [
                trade for trade in self.trade_history
                if (trade['user_id'] == user_id and
                    start_date <= trade['timestamp'] <= end_date)
            ]
            
            if not period_trades:
                return {
                    'total_return': Decimal('0'),
                    'total_pnl': Decimal('0'),
                    'win_rate': Decimal('0'),
                    'avg_win': Decimal('0'),
                    'avg_loss': Decimal('0'),
                    'max_drawdown': Decimal('0'),
                    'sharpe_ratio': Decimal('0'),
                    'trade_count': 0
                }
            
            # ê¸°ë³¸ ì§€í‘œ ê³„ì‚°
            total_pnl = sum(trade['pnl'] for trade in period_trades)
            winning_trades = [t for t in period_trades if t['pnl'] > 0]
            losing_trades = [t for t in period_trades if t['pnl'] < 0]
            
            win_rate = len(winning_trades) / len(period_trades) if period_trades else 0
            avg_win = sum(t['pnl'] for t in winning_trades) / len(winning_trades) if winning_trades else Decimal('0')
            avg_loss = sum(t['pnl'] for t in losing_trades) / len(losing_trades) if losing_trades else Decimal('0')
            
            # ìµœëŒ€ ë‚™í­ ê³„ì‚°
            max_drawdown = await self._calculate_max_drawdown(period_trades)
            
            # ìƒ¤í”„ ë¹„ìœ¨ ê³„ì‚°
            sharpe_ratio = await self._calculate_sharpe_ratio(period_trades)
            
            # ì´ ìˆ˜ìµë¥  ê³„ì‚° (ì´ˆê¸° ìë³¸ ëŒ€ë¹„)
            initial_capital = Decimal('100000')  # ì˜ˆì‹œ ì´ˆê¸° ìë³¸
            total_return = (total_pnl / initial_capital) * 100 if initial_capital > 0 else Decimal('0')
            
            return {
                'total_return': total_return,
                'total_pnl': total_pnl,
                'win_rate': Decimal(str(win_rate)),
                'avg_win': avg_win,
                'avg_loss': avg_loss,
                'max_drawdown': max_drawdown,
                'sharpe_ratio': sharpe_ratio,
                'trade_count': len(period_trades)
            }
            
        except Exception as e:
            logger.error(f"Returns calculation failed: {e}")
            return {
                'total_return': Decimal('0'),
                'total_pnl': Decimal('0'),
                'win_rate': Decimal('0'),
                'avg_win': Decimal('0'),
                'avg_loss': Decimal('0'),
                'max_drawdown': Decimal('0'),
                'sharpe_ratio': Decimal('0'),
                'trade_count': 0
            }
    
    async def _calculate_max_drawdown(self, trades: List[Dict[str, Any]]) -> Decimal:
        """ìµœëŒ€ ë‚™í­ ê³„ì‚°"""
        try:
            if not trades:
                return Decimal('0')
            
            # ëˆ„ì  ìˆ˜ìµë¥  ê³„ì‚°
            cumulative_pnl = []
            running_pnl = Decimal('0')
            
            for trade in trades:
                running_pnl += trade['pnl']
                cumulative_pnl.append(running_pnl)
            
            # ìµœëŒ€ ë‚™í­ ê³„ì‚°
            max_drawdown = Decimal('0')
            peak = cumulative_pnl[0]
            
            for pnl in cumulative_pnl:
                if pnl > peak:
                    peak = pnl
                drawdown = (peak - pnl) / peak if peak > 0 else Decimal('0')
                if drawdown > max_drawdown:
                    max_drawdown = drawdown
            
            return max_drawdown * 100  # í¼ì„¼íŠ¸ë¡œ ë³€í™˜
            
        except Exception as e:
            logger.error(f"Max drawdown calculation failed: {e}")
            return Decimal('0')
    
    async def _calculate_sharpe_ratio(self, trades: List[Dict[str, Any]]) -> Decimal:
        """ìƒ¤í”„ ë¹„ìœ¨ ê³„ì‚°"""
        try:
            if len(trades) < 2:
                return Decimal('0')
            
            # ì¼ë³„ ìˆ˜ìµë¥  ê³„ì‚°
            daily_returns = {}
            for trade in trades:
                date = trade['timestamp'].date().isoformat()
                if date not in daily_returns:
                    daily_returns[date] = Decimal('0')
                daily_returns[date] += trade['pnl']
            
            returns_list = list(daily_returns.values())
            
            # í‰ê·  ìˆ˜ìµë¥ 
            avg_return = sum(returns_list) / len(returns_list)
            
            # í‘œì¤€í¸ì°¨ ê³„ì‚°
            variance = sum((r - avg_return) ** 2 for r in returns_list) / len(returns_list)
            std_dev = variance.sqrt()
            
            # ìƒ¤í”„ ë¹„ìœ¨ (ë¬´ìœ„í—˜ ìˆ˜ìµë¥  0% ê°€ì •)
            sharpe_ratio = avg_return / std_dev if std_dev > 0 else Decimal('0')
            
            return sharpe_ratio
            
        except Exception as e:
            logger.error(f"Sharpe ratio calculation failed: {e}")
            return Decimal('0')
    
    async def add_trade(self, trade_data: Dict[str, Any]):
        """ê±°ë˜ ê¸°ë¡ ì¶”ê°€"""
        try:
            trade_data['timestamp'] = datetime.now(timezone.utc)
            self.trade_history.append(trade_data)
            
            logger.info(f"Trade recorded: {trade_data['user_id']} {trade_data['symbol']} {trade_data['pnl']}")
            
        except Exception as e:
            logger.error(f"Trade recording failed: {e}")
    
    async def get_trade_summary(self, user_id: str, 
                              days: int = 30) -> Dict[str, Any]:
        """ê±°ë˜ ìš”ì•½ ì¡°íšŒ"""
        try:
            end_date = datetime.now(timezone.utc)
            start_date = end_date - timedelta(days=days)
            
            return await self.calculate_returns(user_id, start_date, end_date)
            
        except Exception as e:
            logger.error(f"Trade summary calculation failed: {e}")
            return {
                'total_return': Decimal('0'),
                'total_pnl': Decimal('0'),
                'win_rate': Decimal('0'),
                'avg_win': Decimal('0'),
                'avg_loss': Decimal('0'),
                'max_drawdown': Decimal('0'),
                'sharpe_ratio': Decimal('0'),
                'trade_count': 0
            }
```

## ğŸ“Š **ì„±ëŠ¥ ìµœì í™”**

### ğŸ¯ **í˜„ì‹¤ì  ì„±ëŠ¥ ëª©í‘œ**
- **ì£¼ë¬¸ ì‹¤í–‰ ì‹œê°„**: < 200ms (ë„¤íŠ¸ì›Œí¬ ì§€ì—° ê³ ë ¤)
- **í¬ì§€ì…˜ ê³„ì‚° ì •í™•ë„**: 99%
- **ë¦¬ìŠ¤í¬ ê²€ì¦ ì‹œê°„**: < 50ms
- **ìˆ˜ìµë¥  ê³„ì‚° ì‹œê°„**: < 100ms

### ğŸ”§ **ìµœì í™” ì „ëµ**
1. **API ë ˆì´íŠ¸ ë¦¬ë°‹ ì¤€ìˆ˜**: 100ms ì§€ì—° ì¶”ê°€
2. **ë¹„ë™ê¸° ì²˜ë¦¬**: asyncio í™œìš©
3. **ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±**: ì ì ˆí•œ ë°ì´í„° êµ¬ì¡° ì‚¬ìš©
4. **ìºì‹±**: ìì£¼ ì‚¬ìš©ë˜ëŠ” ê³„ì‚° ê²°ê³¼ ìºì‹±

## ğŸ”’ **ë³´ì•ˆ ê³ ë ¤ì‚¬í•­**

### ğŸ›¡ï¸ **ê¸°ë³¸ ë³´ì•ˆ ìš”êµ¬ì‚¬í•­**
1. **ì…ë ¥ ê²€ì¦**: ëª¨ë“  ì£¼ë¬¸ ë°ì´í„° ê²€ì¦
2. **ê¶Œí•œ í™•ì¸**: ì‚¬ìš©ìë³„ ì£¼ë¬¸ ê¶Œí•œ í™•ì¸
3. **ë¡œê¹…**: ëª¨ë“  ê±°ë˜ ì´ë²¤íŠ¸ ë¡œê¹…
4. **ì—ëŸ¬ ì²˜ë¦¬**: ë¯¼ê°í•œ ì •ë³´ ë…¸ì¶œ ë°©ì§€

## ğŸ“‹ **í…ŒìŠ¤íŠ¸ ê³„íš**

### ğŸ§ª **ë‹¨ìœ„ í…ŒìŠ¤íŠ¸**
- ì£¼ë¬¸ ì‹¤í–‰ ì—”ì§„ ê²€ì¦
- í¬ì§€ì…˜ ê´€ë¦¬ ê¸°ëŠ¥
- ë¦¬ìŠ¤í¬ ê´€ë¦¬ ëª¨ë“ˆ
- ìˆ˜ìµë¥  ê³„ì‚° ë¡œì§

### ğŸ”— **í†µí•© í…ŒìŠ¤íŠ¸**
- ì „ì²´ ê±°ë˜ í”Œë¡œìš°
- í¬ì§€ì…˜-ë¦¬ìŠ¤í¬ ì—°ë™
- ìˆ˜ìµë¥ -ê±°ë˜ ì´ë ¥ ì—°ë™

### âš¡ **ì„±ëŠ¥ í…ŒìŠ¤íŠ¸**
- 100 TPS ë¶€í•˜ í…ŒìŠ¤íŠ¸
- 200ms ì‘ë‹µ ì‹œê°„ ê²€ì¦
- ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ëª¨ë‹ˆí„°ë§

---

**Phase 0.2 ì™„ë£Œ ê¸°ì¤€**: ê¸°ë³¸ ì£¼ë¬¸ ì‹¤í–‰, í¬ì§€ì…˜ ê´€ë¦¬, ë¦¬ìŠ¤í¬ ê´€ë¦¬, ìˆ˜ìµë¥  ê³„ì‚° ì™„ë£Œ 