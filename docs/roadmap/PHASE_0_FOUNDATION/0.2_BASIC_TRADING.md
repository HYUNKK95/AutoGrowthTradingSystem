# 💰 0.2 기본 거래 기능

## 📋 **개요**

### 🎯 **목표**
- **안정성**: 99% 거래 성공률 (개인 개발자 기준)
- **성능**: < 200ms 주문 실행 시간 (네트워크 지연 고려)
- **정확성**: 99% 포지션 계산 정확도
- **안전성**: 기본 리스크 관리 시스템 구축

### 📊 **성과 지표**
- **주문 실행 시간**: P95 < 200ms
- **거래 성공률**: 99% 이상
- **포지션 계산 정확도**: 99%
- **리스크 관리 효율성**: 90% 이상

## 🚀 **0.2.1 주문 실행 엔진**

### 📋 **구현 세부사항**

#### **주문 실행 엔진 설계**
```python
import asyncio
import logging
from typing import Dict, Any, Optional, List
from decimal import Decimal
from datetime import datetime, timezone
from enum import Enum

from .models import Order, OrderType, OrderSide, OrderStatus
from .exceptions import OrderExecutionError, InsufficientBalanceError

logger = logging.getLogger(__name__)

class ExecutionEngine:
    """주문 실행 엔진 - 기본 기능 중심"""
    
    def __init__(self, exchange_client, balance_manager, risk_manager):
        self.exchange_client = exchange_client
        self.balance_manager = balance_manager
        self.risk_manager = risk_manager
        self.execution_queue = asyncio.Queue()
        self.execution_task = None
        self._running = False
        self.rate_limit_delay = 0.1  # 100ms (API 제한 고려)
    
    async def start(self):
        """실행 엔진 시작"""
        if not self._running:
            self._running = True
            self.execution_task = asyncio.create_task(self._execution_loop())
            logger.info("Order execution engine started")
    
    async def stop(self):
        """실행 엔진 중지"""
        if self._running:
            self._running = False
            if self.execution_task:
                self.execution_task.cancel()
                try:
                    await self.execution_task
                except asyncio.CancelledError:
                    pass
            logger.info("Order execution engine stopped")
    
    async def submit_order(self, order: Order) -> bool:
        """주문 제출"""
        try:
            # 1. 주문 검증
            if not await self._validate_order(order):
                return False
            
            # 2. 잔고 확인
            if not await self._check_balance(order):
                return False
            
            # 3. 리스크 검증
            if not await self._check_risk(order):
                return False
            
            # 4. 실행 큐에 추가
            await self.execution_queue.put(order)
            logger.info(f"Order submitted for execution: {order.id}")
            return True
            
        except Exception as e:
            logger.error(f"Order submission failed: {order.id}, error: {e}")
            return False
    
    async def _execution_loop(self):
        """주문 실행 루프"""
        while self._running:
            try:
                # 큐에서 주문 가져오기 (1초 타임아웃)
                order = await asyncio.wait_for(self.execution_queue.get(), timeout=1.0)
                
                # API 레이트 리밋 고려
                await asyncio.sleep(self.rate_limit_delay)
                
                # 주문 실행
                success = await self._execute_order(order)
                
                if success:
                    logger.info(f"Order executed successfully: {order.id}")
                else:
                    logger.error(f"Order execution failed: {order.id}")
                    
            except asyncio.TimeoutError:
                continue
            except Exception as e:
                logger.error(f"Execution loop error: {e}")
    
    async def _validate_order(self, order: Order) -> bool:
        """주문 검증"""
        try:
            # 기본 검증
            if not order.symbol or not order.quantity or order.quantity <= 0:
                logger.error(f"Invalid order data: {order.id}")
                return False
            
            # 주문 타입별 검증
            if order.order_type == OrderType.LIMIT and not order.price:
                logger.error(f"Limit order without price: {order.id}")
                return False
            
            if order.order_type == OrderType.STOP and not order.stop_price:
                logger.error(f"Stop order without stop price: {order.id}")
                return False
            
            return True
            
        except Exception as e:
            logger.error(f"Order validation failed: {e}")
            return False
    
    async def _check_balance(self, order: Order) -> bool:
        """잔고 확인"""
        try:
            # 필요한 잔고 계산
            required_balance = await self.balance_manager.calculate_required_balance(order)
            
            # 사용 가능한 잔고 확인
            available_balance = await self.balance_manager.get_available_balance(
                order.user_id, order.symbol.split('/')[1]  # USDT, BTC 등
            )
            
            if available_balance < required_balance:
                logger.error(f"Insufficient balance: {order.id}")
                return False
            
            return True
            
        except Exception as e:
            logger.error(f"Balance check failed: {e}")
            return False
    
    async def _check_risk(self, order: Order) -> bool:
        """리스크 검증"""
        try:
            # 기본 리스크 검증
            risk_check = await self.risk_manager.validate_order(order)
            
            if not risk_check['valid']:
                logger.error(f"Risk validation failed: {order.id}, reason: {risk_check['reason']}")
                return False
            
            return True
            
        except Exception as e:
            logger.error(f"Risk check failed: {e}")
            return False
    
    async def _execute_order(self, order: Order) -> bool:
        """주문 실행"""
        try:
            # 거래소에 주문 전송
            result = await self.exchange_client.place_order(order)
            
            if result.get('success'):
                # 주문 상태 업데이트
                order.status = OrderStatus.PENDING
                order.updated_at = datetime.now(timezone.utc)
                
                # 잔고 업데이트
                await self.balance_manager.lock_balance(order)
                
                logger.info(f"Order placed successfully: {order.id}")
                return True
            else:
                # 주문 실패 처리
                order.status = OrderStatus.REJECTED
                order.updated_at = datetime.now(timezone.utc)
                
                logger.error(f"Order placement failed: {order.id}, error: {result.get('error')}")
                return False
                
        except Exception as e:
            logger.error(f"Order execution failed: {order.id}, error: {e}")
            return False
```

## 📊 **0.2.2 포지션 관리**

### 📋 **구현 세부사항**

#### **포지션 관리자 구현**
```python
import logging
from typing import Dict, List, Optional
from decimal import Decimal
from datetime import datetime, timezone

from .models import Order, OrderSide, OrderStatus

logger = logging.getLogger(__name__)

class PositionManager:
    """포지션 관리자 - 기본 기능 중심"""
    
    def __init__(self):
        self.positions: Dict[str, Dict[str, 'Position']] = {}  # user_id -> symbol -> Position
    
    async def update_position(self, order: Order, fill_quantity: Decimal, 
                            fill_price: Decimal) -> bool:
        """포지션 업데이트"""
        try:
            user_id = order.user_id
            symbol = order.symbol
            
            # 사용자 포지션 초기화
            if user_id not in self.positions:
                self.positions[user_id] = {}
            
            if symbol not in self.positions[user_id]:
                self.positions[user_id][symbol] = Position(user_id, symbol)
            
            position = self.positions[user_id][symbol]
            
            # 포지션 업데이트
            if order.side == OrderSide.BUY:
                position.add_long(fill_quantity, fill_price)
            else:
                position.add_short(fill_quantity, fill_price)
            
            # 주문 상태 업데이트
            order.filled_quantity += fill_quantity
            if order.filled_quantity >= order.quantity:
                order.status = OrderStatus.FILLED
            else:
                order.status = OrderStatus.PARTIALLY_FILLED
            
            order.updated_at = datetime.now(timezone.utc)
            
            logger.info(f"Position updated: {user_id} {symbol} {fill_quantity} @ {fill_price}")
            return True
            
        except Exception as e:
            logger.error(f"Position update failed: {e}")
            return False
    
    async def get_position(self, user_id: str, symbol: str) -> Optional['Position']:
        """포지션 조회"""
        try:
            user_positions = self.positions.get(user_id, {})
            return user_positions.get(symbol)
        except Exception as e:
            logger.error(f"Position retrieval failed: {e}")
            return None
    
    async def get_user_positions(self, user_id: str) -> List['Position']:
        """사용자 포지션 목록 조회"""
        try:
            user_positions = self.positions.get(user_id, {})
            return list(user_positions.values())
        except Exception as e:
            logger.error(f"User positions retrieval failed: {e}")
            return []
    
    async def calculate_pnl(self, user_id: str, symbol: str, 
                          current_price: Decimal) -> Dict[str, Decimal]:
        """손익 계산"""
        try:
            position = await self.get_position(user_id, symbol)
            if not position:
                return {'unrealized_pnl': Decimal('0'), 'realized_pnl': Decimal('0')}
            
            return position.calculate_pnl(current_price)
            
        except Exception as e:
            logger.error(f"PnL calculation failed: {e}")
            return {'unrealized_pnl': Decimal('0'), 'realized_pnl': Decimal('0')}

class Position:
    """포지션 모델"""
    
    def __init__(self, user_id: str, symbol: str):
        self.user_id = user_id
        self.symbol = symbol
        self.long_quantity = Decimal('0')
        self.short_quantity = Decimal('0')
        self.long_avg_price = Decimal('0')
        self.short_avg_price = Decimal('0')
        self.realized_pnl = Decimal('0')
        self.created_at = datetime.now(timezone.utc)
        self.updated_at = datetime.now(timezone.utc)
    
    def add_long(self, quantity: Decimal, price: Decimal):
        """롱 포지션 추가"""
        if self.long_quantity == 0:
            self.long_avg_price = price
        else:
            # 평균 가격 계산
            total_value = self.long_quantity * self.long_avg_price + quantity * price
            self.long_avg_price = total_value / (self.long_quantity + quantity)
        
        self.long_quantity += quantity
        self.updated_at = datetime.now(timezone.utc)
    
    def add_short(self, quantity: Decimal, price: Decimal):
        """숏 포지션 추가"""
        if self.short_quantity == 0:
            self.short_avg_price = price
        else:
            # 평균 가격 계산
            total_value = self.short_quantity * self.short_avg_price + quantity * price
            self.short_avg_price = total_value / (self.short_quantity + quantity)
        
        self.short_quantity += quantity
        self.updated_at = datetime.now(timezone.utc)
    
    def calculate_pnl(self, current_price: Decimal) -> Dict[str, Decimal]:
        """손익 계산"""
        # 미실현 손익
        long_pnl = (current_price - self.long_avg_price) * self.long_quantity if self.long_quantity > 0 else Decimal('0')
        short_pnl = (self.short_avg_price - current_price) * self.short_quantity if self.short_quantity > 0 else Decimal('0')
        
        unrealized_pnl = long_pnl + short_pnl
        
        return {
            'unrealized_pnl': unrealized_pnl,
            'realized_pnl': self.realized_pnl,
            'total_pnl': unrealized_pnl + self.realized_pnl
        }
    
    @property
    def net_quantity(self) -> Decimal:
        """순 포지션 수량"""
        return self.long_quantity - self.short_quantity
    
    @property
    def is_long(self) -> bool:
        """롱 포지션 여부"""
        return self.net_quantity > 0
    
    @property
    def is_short(self) -> bool:
        """숏 포지션 여부"""
        return self.net_quantity < 0
    
    @property
    def is_flat(self) -> bool:
        """평포지션 여부"""
        return self.net_quantity == 0
```

## 🛡️ **0.2.3 리스크 관리**

### 📋 **구현 세부사항**

#### **리스크 관리자 구현**
```python
import logging
from typing import Dict, Any, Optional
from decimal import Decimal
from datetime import datetime, timezone

from .models import Order, OrderSide

logger = logging.getLogger(__name__)

class RiskManager:
    """리스크 관리자 - 기본 기능 중심"""
    
    def __init__(self, config: Dict[str, Any]):
        self.config = config
        self.max_position_size = Decimal(str(config.get('max_position_size', '100000')))
        self.max_daily_loss = Decimal(str(config.get('max_daily_loss', '10000')))
        self.stop_loss_pct = Decimal(str(config.get('stop_loss_pct', '0.05')))  # 5%
        self.take_profit_pct = Decimal(str(config.get('take_profit_pct', '0.10')))  # 10%
        
        # 일일 거래 기록
        self.daily_trades: Dict[str, Dict[str, Any]] = {}
        self.daily_pnl: Dict[str, Decimal] = {}
    
    async def validate_order(self, order: Order) -> Dict[str, Any]:
        """주문 리스크 검증"""
        try:
            user_id = order.user_id
            
            # 1. 포지션 크기 검증
            position_check = await self._check_position_size(order)
            if not position_check['valid']:
                return {
                    'valid': False,
                    'reason': f"Position size exceeds limit: {position_check['reason']}"
                }
            
            # 2. 일일 손실 한도 검증
            daily_loss_check = await self._check_daily_loss(user_id, order)
            if not daily_loss_check['valid']:
                return {
                    'valid': False,
                    'reason': f"Daily loss limit exceeded: {daily_loss_check['reason']}"
                }
            
            # 3. 주문 크기 검증
            order_size_check = await self._check_order_size(order)
            if not order_size_check['valid']:
                return {
                    'valid': False,
                    'reason': f"Order size exceeds limit: {order_size_check['reason']}"
                }
            
            return {'valid': True, 'reason': 'Risk validation passed'}
            
        except Exception as e:
            logger.error(f"Risk validation failed: {e}")
            return {'valid': False, 'reason': f'Risk validation error: {e}'}
    
    async def _check_position_size(self, order: Order) -> Dict[str, Any]:
        """포지션 크기 검증"""
        try:
            # 주문 가치 계산
            if order.price:
                order_value = order.quantity * order.price
            else:
                # 시장가 주문의 경우 추정 가치 사용
                order_value = order.quantity * Decimal('50000')  # 예시 가격
            
            if order_value > self.max_position_size:
                return {
                    'valid': False,
                    'reason': f"Order value {order_value} exceeds max position size {self.max_position_size}"
                }
            
            return {'valid': True}
            
        except Exception as e:
            logger.error(f"Position size check failed: {e}")
            return {'valid': False, 'reason': str(e)}
    
    async def _check_daily_loss(self, user_id: str, order: Order) -> Dict[str, Any]:
        """일일 손실 한도 검증"""
        try:
            today = datetime.now(timezone.utc).date().isoformat()
            
            # 오늘의 손익 조회
            daily_pnl = self.daily_pnl.get(f"{user_id}_{today}", Decimal('0'))
            
            # 예상 손실 계산 (매수 주문의 경우)
            if order.side == OrderSide.BUY:
                estimated_loss = order.quantity * order.price * self.stop_loss_pct
            else:
                estimated_loss = Decimal('0')  # 매도는 손실 위험이 낮음
            
            if daily_pnl - estimated_loss < -self.max_daily_loss:
                return {
                    'valid': False,
                    'reason': f"Daily loss would exceed limit: {daily_pnl - estimated_loss}"
                }
            
            return {'valid': True}
            
        except Exception as e:
            logger.error(f"Daily loss check failed: {e}")
            return {'valid': False, 'reason': str(e)}
    
    async def _check_order_size(self, order: Order) -> Dict[str, Any]:
        """주문 크기 검증"""
        try:
            # 최소 주문 크기 검증
            min_order_size = Decimal(str(self.config.get('min_order_size', '10')))
            
            if order.quantity < min_order_size:
                return {
                    'valid': False,
                    'reason': f"Order quantity {order.quantity} below minimum {min_order_size}"
                }
            
            return {'valid': True}
            
        except Exception as e:
            logger.error(f"Order size check failed: {e}")
            return {'valid': False, 'reason': str(e)}
    
    async def update_daily_pnl(self, user_id: str, pnl: Decimal):
        """일일 손익 업데이트"""
        try:
            today = datetime.now(timezone.utc).date().isoformat()
            key = f"{user_id}_{today}"
            
            current_pnl = self.daily_pnl.get(key, Decimal('0'))
            self.daily_pnl[key] = current_pnl + pnl
            
            logger.info(f"Daily PnL updated: {user_id} {today} {self.daily_pnl[key]}")
            
        except Exception as e:
            logger.error(f"Daily PnL update failed: {e}")
    
    async def check_stop_loss(self, user_id: str, symbol: str, 
                            current_price: Decimal, position: 'Position') -> bool:
        """스탑로스 검증"""
        try:
            if position.is_long:
                # 롱 포지션 스탑로스
                stop_price = position.long_avg_price * (1 - self.stop_loss_pct)
                if current_price <= stop_price:
                    logger.warning(f"Stop loss triggered: {user_id} {symbol} {current_price}")
                    return True
            elif position.is_short:
                # 숏 포지션 스탑로스
                stop_price = position.short_avg_price * (1 + self.stop_loss_pct)
                if current_price >= stop_price:
                    logger.warning(f"Stop loss triggered: {user_id} {symbol} {current_price}")
                    return True
            
            return False
            
        except Exception as e:
            logger.error(f"Stop loss check failed: {e}")
            return False
    
    async def check_take_profit(self, user_id: str, symbol: str, 
                              current_price: Decimal, position: 'Position') -> bool:
        """테이크프로핏 검증"""
        try:
            if position.is_long:
                # 롱 포지션 테이크프로핏
                take_profit_price = position.long_avg_price * (1 + self.take_profit_pct)
                if current_price >= take_profit_price:
                    logger.info(f"Take profit triggered: {user_id} {symbol} {current_price}")
                    return True
            elif position.is_short:
                # 숏 포지션 테이크프로핏
                take_profit_price = position.short_avg_price * (1 - self.take_profit_pct)
                if current_price <= take_profit_price:
                    logger.info(f"Take profit triggered: {user_id} {symbol} {current_price}")
                    return True
            
            return False
            
        except Exception as e:
            logger.error(f"Take profit check failed: {e}")
            return False
```

## 📈 **0.2.4 수익률 계산**

### 📋 **구현 세부사항**

#### **수익률 계산기 구현**
```python
import logging
from typing import Dict, List, Optional
from decimal import Decimal
from datetime import datetime, timezone, timedelta

logger = logging.getLogger(__name__)

class PerformanceCalculator:
    """수익률 계산기 - 기본 기능 중심"""
    
    def __init__(self):
        self.trade_history: List[Dict[str, Any]] = []
    
    async def calculate_returns(self, user_id: str, 
                              start_date: datetime, 
                              end_date: datetime) -> Dict[str, Any]:
        """수익률 계산"""
        try:
            # 기간 내 거래 필터링
            period_trades = [
                trade for trade in self.trade_history
                if (trade['user_id'] == user_id and
                    start_date <= trade['timestamp'] <= end_date)
            ]
            
            if not period_trades:
                return {
                    'total_return': Decimal('0'),
                    'total_pnl': Decimal('0'),
                    'win_rate': Decimal('0'),
                    'avg_win': Decimal('0'),
                    'avg_loss': Decimal('0'),
                    'max_drawdown': Decimal('0'),
                    'sharpe_ratio': Decimal('0'),
                    'trade_count': 0
                }
            
            # 기본 지표 계산
            total_pnl = sum(trade['pnl'] for trade in period_trades)
            winning_trades = [t for t in period_trades if t['pnl'] > 0]
            losing_trades = [t for t in period_trades if t['pnl'] < 0]
            
            win_rate = len(winning_trades) / len(period_trades) if period_trades else 0
            avg_win = sum(t['pnl'] for t in winning_trades) / len(winning_trades) if winning_trades else Decimal('0')
            avg_loss = sum(t['pnl'] for t in losing_trades) / len(losing_trades) if losing_trades else Decimal('0')
            
            # 최대 낙폭 계산
            max_drawdown = await self._calculate_max_drawdown(period_trades)
            
            # 샤프 비율 계산
            sharpe_ratio = await self._calculate_sharpe_ratio(period_trades)
            
            # 총 수익률 계산 (초기 자본 대비)
            initial_capital = Decimal('100000')  # 예시 초기 자본
            total_return = (total_pnl / initial_capital) * 100 if initial_capital > 0 else Decimal('0')
            
            return {
                'total_return': total_return,
                'total_pnl': total_pnl,
                'win_rate': Decimal(str(win_rate)),
                'avg_win': avg_win,
                'avg_loss': avg_loss,
                'max_drawdown': max_drawdown,
                'sharpe_ratio': sharpe_ratio,
                'trade_count': len(period_trades)
            }
            
        except Exception as e:
            logger.error(f"Returns calculation failed: {e}")
            return {
                'total_return': Decimal('0'),
                'total_pnl': Decimal('0'),
                'win_rate': Decimal('0'),
                'avg_win': Decimal('0'),
                'avg_loss': Decimal('0'),
                'max_drawdown': Decimal('0'),
                'sharpe_ratio': Decimal('0'),
                'trade_count': 0
            }
    
    async def _calculate_max_drawdown(self, trades: List[Dict[str, Any]]) -> Decimal:
        """최대 낙폭 계산"""
        try:
            if not trades:
                return Decimal('0')
            
            # 누적 수익률 계산
            cumulative_pnl = []
            running_pnl = Decimal('0')
            
            for trade in trades:
                running_pnl += trade['pnl']
                cumulative_pnl.append(running_pnl)
            
            # 최대 낙폭 계산
            max_drawdown = Decimal('0')
            peak = cumulative_pnl[0]
            
            for pnl in cumulative_pnl:
                if pnl > peak:
                    peak = pnl
                drawdown = (peak - pnl) / peak if peak > 0 else Decimal('0')
                if drawdown > max_drawdown:
                    max_drawdown = drawdown
            
            return max_drawdown * 100  # 퍼센트로 변환
            
        except Exception as e:
            logger.error(f"Max drawdown calculation failed: {e}")
            return Decimal('0')
    
    async def _calculate_sharpe_ratio(self, trades: List[Dict[str, Any]]) -> Decimal:
        """샤프 비율 계산"""
        try:
            if len(trades) < 2:
                return Decimal('0')
            
            # 일별 수익률 계산
            daily_returns = {}
            for trade in trades:
                date = trade['timestamp'].date().isoformat()
                if date not in daily_returns:
                    daily_returns[date] = Decimal('0')
                daily_returns[date] += trade['pnl']
            
            returns_list = list(daily_returns.values())
            
            # 평균 수익률
            avg_return = sum(returns_list) / len(returns_list)
            
            # 표준편차 계산
            variance = sum((r - avg_return) ** 2 for r in returns_list) / len(returns_list)
            std_dev = variance.sqrt()
            
            # 샤프 비율 (무위험 수익률 0% 가정)
            sharpe_ratio = avg_return / std_dev if std_dev > 0 else Decimal('0')
            
            return sharpe_ratio
            
        except Exception as e:
            logger.error(f"Sharpe ratio calculation failed: {e}")
            return Decimal('0')
    
    async def add_trade(self, trade_data: Dict[str, Any]):
        """거래 기록 추가"""
        try:
            trade_data['timestamp'] = datetime.now(timezone.utc)
            self.trade_history.append(trade_data)
            
            logger.info(f"Trade recorded: {trade_data['user_id']} {trade_data['symbol']} {trade_data['pnl']}")
            
        except Exception as e:
            logger.error(f"Trade recording failed: {e}")
    
    async def get_trade_summary(self, user_id: str, 
                              days: int = 30) -> Dict[str, Any]:
        """거래 요약 조회"""
        try:
            end_date = datetime.now(timezone.utc)
            start_date = end_date - timedelta(days=days)
            
            return await self.calculate_returns(user_id, start_date, end_date)
            
        except Exception as e:
            logger.error(f"Trade summary calculation failed: {e}")
            return {
                'total_return': Decimal('0'),
                'total_pnl': Decimal('0'),
                'win_rate': Decimal('0'),
                'avg_win': Decimal('0'),
                'avg_loss': Decimal('0'),
                'max_drawdown': Decimal('0'),
                'sharpe_ratio': Decimal('0'),
                'trade_count': 0
            }
```

## 📊 **성능 최적화**

### 🎯 **현실적 성능 목표**
- **주문 실행 시간**: < 200ms (네트워크 지연 고려)
- **포지션 계산 정확도**: 99%
- **리스크 검증 시간**: < 50ms
- **수익률 계산 시간**: < 100ms

### 🔧 **최적화 전략**
1. **API 레이트 리밋 준수**: 100ms 지연 추가
2. **비동기 처리**: asyncio 활용
3. **메모리 효율성**: 적절한 데이터 구조 사용
4. **캐싱**: 자주 사용되는 계산 결과 캐싱

## 🔒 **보안 고려사항**

### 🛡️ **기본 보안 요구사항**
1. **입력 검증**: 모든 주문 데이터 검증
2. **권한 확인**: 사용자별 주문 권한 확인
3. **로깅**: 모든 거래 이벤트 로깅
4. **에러 처리**: 민감한 정보 노출 방지

## 📋 **테스트 계획**

### 🧪 **단위 테스트**
- 주문 실행 엔진 검증
- 포지션 관리 기능
- 리스크 관리 모듈
- 수익률 계산 로직

### 🔗 **통합 테스트**
- 전체 거래 플로우
- 포지션-리스크 연동
- 수익률-거래 이력 연동

### ⚡ **성능 테스트**
- 100 TPS 부하 테스트
- 200ms 응답 시간 검증
- 메모리 사용량 모니터링

---

**Phase 0.2 완료 기준**: 기본 주문 실행, 포지션 관리, 리스크 관리, 수익률 계산 완료 