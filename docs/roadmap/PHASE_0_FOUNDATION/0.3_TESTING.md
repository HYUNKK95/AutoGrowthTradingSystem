# ğŸ§ª Phase 0.3: í…ŒìŠ¤íŠ¸ ë° ê²€ì¦ ì‹œìŠ¤í…œ

## ğŸ“‹ **ê°œìš”**

### ğŸ¯ **ëª©í‘œ**
- **ê¸°ë³¸ í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€**: 80% ì´ìƒ ë‹¬ì„±
- **í•µì‹¬ ê¸°ëŠ¥ ê²€ì¦**: ì£¼ìš” ê¸°ëŠ¥ ì•ˆì •ì„± í™•ì¸
- **ì„±ëŠ¥ ê²€ì¦**: í˜„ì‹¤ì  ì„±ëŠ¥ ëª©í‘œ ì¶©ì¡±
- **í’ˆì§ˆ ë³´ì¥**: ê¸°ë³¸ í’ˆì§ˆ ê¸°ì¤€ ë‹¬ì„±

### ğŸ“Š **ì„±ëŠ¥ ëª©í‘œ**
- **ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ì‹œê°„**: < 60ì´ˆ
- **í†µí•© í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ì‹œê°„**: < 10ë¶„
- **í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€**: 80% ì´ìƒ
- **ì½”ë“œ í’ˆì§ˆ ì ìˆ˜**: B+ ë“±ê¸‰ ì´ìƒ

## ğŸ—ï¸ **í…ŒìŠ¤íŠ¸ ì•„í‚¤í…ì²˜**

### ğŸ“ **í…ŒìŠ¤íŠ¸ êµ¬ì¡°**
```
tests/
â”œâ”€â”€ unit/                          # ë‹¨ìœ„ í…ŒìŠ¤íŠ¸
â”‚   â”œâ”€â”€ models/                    # ëª¨ë¸ í…ŒìŠ¤íŠ¸
â”‚   â”œâ”€â”€ services/                  # ì„œë¹„ìŠ¤ í…ŒìŠ¤íŠ¸
â”‚   â”œâ”€â”€ validators/                # ê²€ì¦ê¸° í…ŒìŠ¤íŠ¸
â”‚   â””â”€â”€ utils/                     # ìœ í‹¸ë¦¬í‹° í…ŒìŠ¤íŠ¸
â”œâ”€â”€ integration/                   # í†µí•© í…ŒìŠ¤íŠ¸
â”‚   â”œâ”€â”€ api/                       # API í…ŒìŠ¤íŠ¸
â”‚   â”œâ”€â”€ database/                  # ë°ì´í„°ë² ì´ìŠ¤ í…ŒìŠ¤íŠ¸
â”‚   â””â”€â”€ external/                  # ì™¸ë¶€ ì„œë¹„ìŠ¤ í…ŒìŠ¤íŠ¸
â”œâ”€â”€ performance/                   # ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
â”‚   â”œâ”€â”€ load/                      # ë¶€í•˜ í…ŒìŠ¤íŠ¸
â”‚   â”œâ”€â”€ stress/                    # ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸
â”‚   â””â”€â”€ benchmark/                 # ë²¤ì¹˜ë§ˆí¬ í…ŒìŠ¤íŠ¸
â”œâ”€â”€ e2e/                          # ì—”ë“œíˆ¬ì—”ë“œ í…ŒìŠ¤íŠ¸
â”‚   â”œâ”€â”€ trading/                   # ê±°ë˜ ì‹œë‚˜ë¦¬ì˜¤
â”‚   â”œâ”€â”€ user/                      # ì‚¬ìš©ì ì‹œë‚˜ë¦¬ì˜¤
â”‚   â””â”€â”€ admin/                     # ê´€ë¦¬ì ì‹œë‚˜ë¦¬ì˜¤
â””â”€â”€ fixtures/                     # í…ŒìŠ¤íŠ¸ ë°ì´í„°
    â”œâ”€â”€ orders.json               # ì£¼ë¬¸ í…ŒìŠ¤íŠ¸ ë°ì´í„°
    â”œâ”€â”€ users.json                # ì‚¬ìš©ì í…ŒìŠ¤íŠ¸ ë°ì´í„°
    â””â”€â”€ markets.json              # ì‹œì¥ í…ŒìŠ¤íŠ¸ ë°ì´í„°
```

## ğŸ§ª **ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ êµ¬í˜„**

### ğŸ“¦ **í…ŒìŠ¤íŠ¸ í”„ë ˆì„ì›Œí¬ ì„¤ì •**

```python
# tests/conftest.py
import pytest
import asyncio
from unittest.mock import Mock, patch
from decimal import Decimal
from datetime import datetime, timezone

# í…ŒìŠ¤íŠ¸ ì„¤ì •
@pytest.fixture(scope="session")
def event_loop():
    """ì´ë²¤íŠ¸ ë£¨í”„ ì„¤ì •"""
    loop = asyncio.get_event_loop_policy().new_event_loop()
    yield loop
    loop.close()

@pytest.fixture
def sample_order_data():
    """ìƒ˜í”Œ ì£¼ë¬¸ ë°ì´í„°"""
    return {
        'id': 'test_order_001',
        'user_id': 'user_001',
        'symbol': 'BTC/USDT',
        'side': 'BUY',
        'type': 'LIMIT',
        'quantity': Decimal('1.0'),
        'price': Decimal('50000.0'),
        'status': 'PENDING',
        'created_at': datetime.now(timezone.utc),
        'updated_at': datetime.now(timezone.utc)
    }

@pytest.fixture
def sample_user_data():
    """ìƒ˜í”Œ ì‚¬ìš©ì ë°ì´í„°"""
    return {
        'id': 'user_001',
        'username': 'testuser',
        'email': 'test@example.com',
        'balance': {
            'BTC': Decimal('10.0'),
            'USDT': Decimal('100000.0')
        },
        'created_at': datetime.now(timezone.utc)
    }

@pytest.fixture
def mock_exchange_api():
    """ê±°ë˜ì†Œ API Mock"""
    mock = Mock()
    mock.get_ticker.return_value = {
        'symbol': 'BTC/USDT',
        'last': '50000.0',
        'bid': '49999.0',
        'ask': '50001.0',
        'volume': '1000.0'
    }
    mock.place_order.return_value = {
        'order_id': 'exchange_order_001',
        'status': 'filled',
        'filled_quantity': '1.0',
        'filled_price': '50000.0'
    }
    return mock
```

### ğŸ§ª **ëª¨ë¸ í…ŒìŠ¤íŠ¸**

```python
# tests/unit/models/test_order.py
import pytest
from decimal import Decimal
from datetime import datetime, timezone
from src.models.order import Order, OrderType, OrderSide, OrderStatus

class TestOrder:
    """ì£¼ë¬¸ ëª¨ë¸ í…ŒìŠ¤íŠ¸"""
    
    def test_order_creation(self, sample_order_data):
        """ì£¼ë¬¸ ìƒì„± í…ŒìŠ¤íŠ¸"""
        order = Order(**sample_order_data)
        
        assert order.id == 'test_order_001'
        assert order.user_id == 'user_001'
        assert order.symbol == 'BTC/USDT'
        assert order.side == OrderSide.BUY
        assert order.type == OrderType.LIMIT
        assert order.quantity == Decimal('1.0')
        assert order.price == Decimal('50000.0')
        assert order.status == OrderStatus.PENDING
    
    def test_order_validation(self):
        """ì£¼ë¬¸ ìœ íš¨ì„± ê²€ì¦ í…ŒìŠ¤íŠ¸"""
        # ìœ íš¨í•œ ì£¼ë¬¸
        valid_order = Order(
            id='test_001',
            user_id='user_001',
            symbol='BTC/USDT',
            side='BUY',
            type='LIMIT',
            quantity=Decimal('1.0'),
            price=Decimal('50000.0')
        )
        assert valid_order.is_valid()
        
        # ë¬´íš¨í•œ ì£¼ë¬¸ (ìŒìˆ˜ ìˆ˜ëŸ‰)
        with pytest.raises(ValueError):
            Order(
                id='test_002',
                user_id='user_001',
                symbol='BTC/USDT',
                side='BUY',
                type='LIMIT',
                quantity=Decimal('-1.0'),
                price=Decimal('50000.0')
            )
    
    def test_order_status_transitions(self, sample_order_data):
        """ì£¼ë¬¸ ìƒíƒœ ì „í™˜ í…ŒìŠ¤íŠ¸"""
        order = Order(**sample_order_data)
        
        # PENDING -> FILLED
        order.update_status(OrderStatus.FILLED)
        assert order.status == OrderStatus.FILLED
        assert order.filled_at is not None
        
        # FILLED -> CANCELLED (ë¶ˆê°€ëŠ¥)
        with pytest.raises(ValueError):
            order.update_status(OrderStatus.CANCELLED)
    
    def test_order_calculation(self, sample_order_data):
        """ì£¼ë¬¸ ê³„ì‚° í…ŒìŠ¤íŠ¸"""
        order = Order(**sample_order_data)
        
        # ì´ ì£¼ë¬¸ ê¸ˆì•¡ ê³„ì‚°
        total_value = order.calculate_total_value()
        expected_value = Decimal('1.0') * Decimal('50000.0')
        assert total_value == expected_value
        
        # ìˆ˜ìˆ˜ë£Œ ê³„ì‚° (0.1% ê°€ì •)
        fee = order.calculate_fee(Decimal('0.001'))
        expected_fee = total_value * Decimal('0.001')
        assert fee == expected_fee
    
    def test_order_serialization(self, sample_order_data):
        """ì£¼ë¬¸ ì§ë ¬í™” í…ŒìŠ¤íŠ¸"""
        order = Order(**sample_order_data)
        
        # JSON ì§ë ¬í™”
        json_data = order.to_json()
        assert isinstance(json_data, dict)
        assert json_data['id'] == 'test_order_001'
        assert json_data['symbol'] == 'BTC/USDT'
        
        # JSON ì—­ì§ë ¬í™”
        new_order = Order.from_json(json_data)
        assert new_order.id == order.id
        assert new_order.symbol == order.symbol
        assert new_order.quantity == order.quantity
```

### ğŸ§ª **ì„œë¹„ìŠ¤ í…ŒìŠ¤íŠ¸**

```python
# tests/unit/services/test_order_service.py
import pytest
from unittest.mock import Mock, patch
from decimal import Decimal
from src.services.order_service import OrderService
from src.models.order import Order, OrderStatus

class TestOrderService:
    """ì£¼ë¬¸ ì„œë¹„ìŠ¤ í…ŒìŠ¤íŠ¸"""
    
    @pytest.fixture
    def order_service(self, mock_exchange_api):
        """ì£¼ë¬¸ ì„œë¹„ìŠ¤ ì¸ìŠ¤í„´ìŠ¤"""
        return OrderService(exchange_api=mock_exchange_api)
    
    def test_create_order(self, order_service, sample_order_data):
        """ì£¼ë¬¸ ìƒì„± í…ŒìŠ¤íŠ¸"""
        order_data = {
            'user_id': 'user_001',
            'symbol': 'BTC/USDT',
            'side': 'BUY',
            'type': 'LIMIT',
            'quantity': Decimal('1.0'),
            'price': Decimal('50000.0')
        }
        
        order = order_service.create_order(order_data)
        
        assert order.id is not None
        assert order.user_id == 'user_001'
        assert order.status == OrderStatus.PENDING
        assert order.created_at is not None
    
    def test_place_order_success(self, order_service, sample_order_data):
        """ì£¼ë¬¸ ì‹¤í–‰ ì„±ê³µ í…ŒìŠ¤íŠ¸"""
        order = Order(**sample_order_data)
        
        with patch.object(order_service.exchange_api, 'place_order') as mock_place:
            mock_place.return_value = {
                'order_id': 'exchange_001',
                'status': 'filled',
                'filled_quantity': '1.0',
                'filled_price': '50000.0'
            }
            
            result = order_service.place_order(order)
            
            assert result['success'] is True
            assert result['exchange_order_id'] == 'exchange_001'
            assert order.status == OrderStatus.FILLED
    
    def test_place_order_failure(self, order_service, sample_order_data):
        """ì£¼ë¬¸ ì‹¤í–‰ ì‹¤íŒ¨ í…ŒìŠ¤íŠ¸"""
        order = Order(**sample_order_data)
        
        with patch.object(order_service.exchange_api, 'place_order') as mock_place:
            mock_place.side_effect = Exception("Exchange error")
            
            result = order_service.place_order(order)
            
            assert result['success'] is False
            assert 'error' in result
            assert order.status == OrderStatus.PENDING
    
    def test_cancel_order(self, order_service, sample_order_data):
        """ì£¼ë¬¸ ì·¨ì†Œ í…ŒìŠ¤íŠ¸"""
        order = Order(**sample_order_data)
        
        with patch.object(order_service.exchange_api, 'cancel_order') as mock_cancel:
            mock_cancel.return_value = {'status': 'cancelled'}
            
            result = order_service.cancel_order(order)
            
            assert result['success'] is True
            assert order.status == OrderStatus.CANCELLED
    
    def test_get_order_status(self, order_service, sample_order_data):
        """ì£¼ë¬¸ ìƒíƒœ ì¡°íšŒ í…ŒìŠ¤íŠ¸"""
        order = Order(**sample_order_data)
        order.exchange_order_id = 'exchange_001'
        
        with patch.object(order_service.exchange_api, 'get_order') as mock_get:
            mock_get.return_value = {
                'status': 'filled',
                'filled_quantity': '1.0',
                'filled_price': '50000.0'
            }
            
            status = order_service.get_order_status(order)
            
            assert status['status'] == 'filled'
            assert status['filled_quantity'] == '1.0'
```

### ğŸ§ª **ê²€ì¦ê¸° í…ŒìŠ¤íŠ¸**

```python
# tests/unit/validators/test_order_validator.py
import pytest
from decimal import Decimal
from src.validators.order_validator import OrderValidator
from src.models.order import Order

class TestOrderValidator:
    """ì£¼ë¬¸ ê²€ì¦ê¸° í…ŒìŠ¤íŠ¸"""
    
    @pytest.fixture
    def validator(self, mock_exchange_api):
        """ê²€ì¦ê¸° ì¸ìŠ¤í„´ìŠ¤"""
        return OrderValidator(exchange_api=mock_exchange_api)
    
    def test_validate_order_data_valid(self, validator):
        """ìœ íš¨í•œ ì£¼ë¬¸ ë°ì´í„° ê²€ì¦"""
        order_data = {
            'user_id': 'user_001',
            'symbol': 'BTC/USDT',
            'side': 'BUY',
            'type': 'LIMIT',
            'quantity': Decimal('1.0'),
            'price': Decimal('50000.0')
        }
        
        result = validator.validate_order_data(order_data)
        assert result['valid'] is True
        assert 'errors' not in result
    
    def test_validate_order_data_invalid(self, validator):
        """ë¬´íš¨í•œ ì£¼ë¬¸ ë°ì´í„° ê²€ì¦"""
        order_data = {
            'user_id': '',  # ë¹ˆ ì‚¬ìš©ì ID
            'symbol': 'INVALID/PAIR',  # ë¬´íš¨í•œ ì‹¬ë³¼
            'side': 'INVALID',  # ë¬´íš¨í•œ ë°©í–¥
            'type': 'INVALID',  # ë¬´íš¨í•œ íƒ€ì…
            'quantity': Decimal('-1.0'),  # ìŒìˆ˜ ìˆ˜ëŸ‰
            'price': Decimal('0.0')  # 0 ê°€ê²©
        }
        
        result = validator.validate_order_data(order_data)
        assert result['valid'] is False
        assert len(result['errors']) > 0
    
    def test_validate_balance_sufficient(self, validator):
        """ì”ê³  ì¶©ë¶„ì„± ê²€ì¦"""
        order_data = {
            'user_id': 'user_001',
            'symbol': 'BTC/USDT',
            'side': 'BUY',
            'type': 'LIMIT',
            'quantity': Decimal('1.0'),
            'price': Decimal('50000.0')
        }
        
        user_balance = {
            'USDT': Decimal('100000.0')  # ì¶©ë¶„í•œ ì”ê³ 
        }
        
        result = validator.validate_balance(order_data, user_balance)
        assert result['valid'] is True
    
    def test_validate_balance_insufficient(self, validator):
        """ì”ê³  ë¶€ì¡± ê²€ì¦"""
        order_data = {
            'user_id': 'user_001',
            'symbol': 'BTC/USDT',
            'side': 'BUY',
            'type': 'LIMIT',
            'quantity': Decimal('1.0'),
            'price': Decimal('50000.0')
        }
        
        user_balance = {
            'USDT': Decimal('10000.0')  # ë¶€ì¡±í•œ ì”ê³ 
        }
        
        result = validator.validate_balance(order_data, user_balance)
        assert result['valid'] is False
        assert 'insufficient_balance' in result['errors']
    
    def test_validate_market_order(self, validator):
        """ì‹œì¥ê°€ ì£¼ë¬¸ ê²€ì¦"""
        order_data = {
            'user_id': 'user_001',
            'symbol': 'BTC/USDT',
            'side': 'BUY',
            'type': 'MARKET',
            'quantity': Decimal('1.0')
        }
        
        with patch.object(validator, '_get_current_price') as mock_price:
            mock_price.return_value = Decimal('50000.0')
            
            result = validator.validate_market_order(order_data)
            assert result['valid'] is True
            assert result['estimated_price'] == Decimal('50000.0')
```

## ğŸ”— **í†µí•© í…ŒìŠ¤íŠ¸ êµ¬í˜„**

### ğŸ§ª **API í†µí•© í…ŒìŠ¤íŠ¸**

```python
# tests/integration/api/test_trading_api.py
import pytest
import json
from decimal import Decimal
from fastapi.testclient import TestClient
from src.main import app

class TestTradingAPI:
    """ê±°ë˜ API í†µí•© í…ŒìŠ¤íŠ¸"""
    
    @pytest.fixture
    def client(self):
        """í…ŒìŠ¤íŠ¸ í´ë¼ì´ì–¸íŠ¸"""
        return TestClient(app)
    
    @pytest.fixture
    def auth_headers(self):
        """ì¸ì¦ í—¤ë”"""
        return {"Authorization": "Bearer test_token"}
    
    def test_create_order_endpoint(self, client, auth_headers):
        """ì£¼ë¬¸ ìƒì„± ì—”ë“œí¬ì¸íŠ¸ í…ŒìŠ¤íŠ¸"""
        order_data = {
            "symbol": "BTC/USDT",
            "side": "BUY",
            "type": "LIMIT",
            "quantity": "1.0",
            "price": "50000.0"
        }
        
        response = client.post(
            "/api/v1/orders",
            json=order_data,
            headers=auth_headers
        )
        
        assert response.status_code == 201
        data = response.json()
        assert data["success"] is True
        assert "order_id" in data
        assert data["order"]["symbol"] == "BTC/USDT"
    
    def test_get_orders_endpoint(self, client, auth_headers):
        """ì£¼ë¬¸ ì¡°íšŒ ì—”ë“œí¬ì¸íŠ¸ í…ŒìŠ¤íŠ¸"""
        response = client.get("/api/v1/orders", headers=auth_headers)
        
        assert response.status_code == 200
        data = response.json()
        assert "orders" in data
        assert isinstance(data["orders"], list)
    
    def test_get_order_detail(self, client, auth_headers):
        """ì£¼ë¬¸ ìƒì„¸ ì¡°íšŒ í…ŒìŠ¤íŠ¸"""
        # ë¨¼ì € ì£¼ë¬¸ ìƒì„±
        order_data = {
            "symbol": "BTC/USDT",
            "side": "BUY",
            "type": "LIMIT",
            "quantity": "1.0",
            "price": "50000.0"
        }
        
        create_response = client.post(
            "/api/v1/orders",
            json=order_data,
            headers=auth_headers
        )
        
        order_id = create_response.json()["order_id"]
        
        # ì£¼ë¬¸ ìƒì„¸ ì¡°íšŒ
        response = client.get(
            f"/api/v1/orders/{order_id}",
            headers=auth_headers
        )
        
        assert response.status_code == 200
        data = response.json()
        assert data["order"]["id"] == order_id
        assert data["order"]["symbol"] == "BTC/USDT"
    
    def test_cancel_order_endpoint(self, client, auth_headers):
        """ì£¼ë¬¸ ì·¨ì†Œ ì—”ë“œí¬ì¸íŠ¸ í…ŒìŠ¤íŠ¸"""
        # ë¨¼ì € ì£¼ë¬¸ ìƒì„±
        order_data = {
            "symbol": "BTC/USDT",
            "side": "BUY",
            "type": "LIMIT",
            "quantity": "1.0",
            "price": "50000.0"
        }
        
        create_response = client.post(
            "/api/v1/orders",
            json=order_data,
            headers=auth_headers
        )
        
        order_id = create_response.json()["order_id"]
        
        # ì£¼ë¬¸ ì·¨ì†Œ
        response = client.delete(
            f"/api/v1/orders/{order_id}",
            headers=auth_headers
        )
        
        assert response.status_code == 200
        data = response.json()
        assert data["success"] is True
    
    def test_unauthorized_access(self, client):
        """ì¸ì¦ë˜ì§€ ì•Šì€ ì ‘ê·¼ í…ŒìŠ¤íŠ¸"""
        response = client.get("/api/v1/orders")
        assert response.status_code == 401
    
    def test_invalid_order_data(self, client, auth_headers):
        """ë¬´íš¨í•œ ì£¼ë¬¸ ë°ì´í„° í…ŒìŠ¤íŠ¸"""
        invalid_order_data = {
            "symbol": "INVALID/PAIR",
            "side": "INVALID",
            "type": "INVALID",
            "quantity": "-1.0",
            "price": "0.0"
        }
        
        response = client.post(
            "/api/v1/orders",
            json=invalid_order_data,
            headers=auth_headers
        )
        
        assert response.status_code == 400
        data = response.json()
        assert data["success"] is False
        assert "errors" in data
```

### ğŸ§ª **ë°ì´í„°ë² ì´ìŠ¤ í†µí•© í…ŒìŠ¤íŠ¸**

```python
# tests/integration/database/test_order_repository.py
import pytest
from decimal import Decimal
from datetime import datetime, timezone
from src.repositories.order_repository import OrderRepository
from src.models.order import Order, OrderStatus

class TestOrderRepository:
    """ì£¼ë¬¸ ì €ì¥ì†Œ í†µí•© í…ŒìŠ¤íŠ¸"""
    
    @pytest.fixture
    def repository(self, test_db):
        """ì €ì¥ì†Œ ì¸ìŠ¤í„´ìŠ¤"""
        return OrderRepository(test_db)
    
    @pytest.fixture
    def sample_order(self):
        """ìƒ˜í”Œ ì£¼ë¬¸"""
        return Order(
            id='test_order_001',
            user_id='user_001',
            symbol='BTC/USDT',
            side='BUY',
            type='LIMIT',
            quantity=Decimal('1.0'),
            price=Decimal('50000.0'),
            status=OrderStatus.PENDING,
            created_at=datetime.now(timezone.utc)
        )
    
    async def test_create_order(self, repository, sample_order):
        """ì£¼ë¬¸ ìƒì„± í…ŒìŠ¤íŠ¸"""
        created_order = await repository.create(sample_order)
        
        assert created_order.id == 'test_order_001'
        assert created_order.user_id == 'user_001'
        assert created_order.status == OrderStatus.PENDING
    
    async def test_get_order_by_id(self, repository, sample_order):
        """IDë¡œ ì£¼ë¬¸ ì¡°íšŒ í…ŒìŠ¤íŠ¸"""
        await repository.create(sample_order)
        
        retrieved_order = await repository.get_by_id('test_order_001')
        
        assert retrieved_order is not None
        assert retrieved_order.id == 'test_order_001'
        assert retrieved_order.symbol == 'BTC/USDT'
    
    async def test_get_orders_by_user(self, repository, sample_order):
        """ì‚¬ìš©ìë³„ ì£¼ë¬¸ ì¡°íšŒ í…ŒìŠ¤íŠ¸"""
        await repository.create(sample_order)
        
        # ë‘ ë²ˆì§¸ ì£¼ë¬¸ ìƒì„±
        second_order = Order(
            id='test_order_002',
            user_id='user_001',
            symbol='ETH/USDT',
            side='SELL',
            type='MARKET',
            quantity=Decimal('10.0'),
            price=Decimal('3000.0'),
            status=OrderStatus.PENDING,
            created_at=datetime.now(timezone.utc)
        )
        await repository.create(second_order)
        
        user_orders = await repository.get_by_user_id('user_001')
        
        assert len(user_orders) == 2
        assert any(order.symbol == 'BTC/USDT' for order in user_orders)
        assert any(order.symbol == 'ETH/USDT' for order in user_orders)
    
    async def test_update_order_status(self, repository, sample_order):
        """ì£¼ë¬¸ ìƒíƒœ ì—…ë°ì´íŠ¸ í…ŒìŠ¤íŠ¸"""
        await repository.create(sample_order)
        
        updated_order = await repository.update_status(
            'test_order_001',
            OrderStatus.FILLED
        )
        
        assert updated_order.status == OrderStatus.FILLED
        assert updated_order.filled_at is not None
    
    async def test_delete_order(self, repository, sample_order):
        """ì£¼ë¬¸ ì‚­ì œ í…ŒìŠ¤íŠ¸"""
        await repository.create(sample_order)
        
        await repository.delete('test_order_001')
        
        deleted_order = await repository.get_by_id('test_order_001')
        assert deleted_order is None
```

## âš¡ **ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ êµ¬í˜„**

### ğŸ§ª **ë¶€í•˜ í…ŒìŠ¤íŠ¸**

```python
# tests/performance/load/test_order_processing.py
import pytest
import asyncio
import time
from concurrent.futures import ThreadPoolExecutor
from decimal import Decimal
from src.services.order_service import OrderService

class TestOrderProcessingPerformance:
    """ì£¼ë¬¸ ì²˜ë¦¬ ì„±ëŠ¥ í…ŒìŠ¤íŠ¸"""
    
    @pytest.fixture
    def order_service(self, mock_exchange_api):
        """ì£¼ë¬¸ ì„œë¹„ìŠ¤ ì¸ìŠ¤í„´ìŠ¤"""
        return OrderService(exchange_api=mock_exchange_api)
    
    def test_single_order_processing_time(self, order_service):
        """ë‹¨ì¼ ì£¼ë¬¸ ì²˜ë¦¬ ì‹œê°„ í…ŒìŠ¤íŠ¸"""
        order_data = {
            'user_id': 'user_001',
            'symbol': 'BTC/USDT',
            'side': 'BUY',
            'type': 'LIMIT',
            'quantity': Decimal('1.0'),
            'price': Decimal('50000.0')
        }
        
        start_time = time.perf_counter()
        order = order_service.create_order(order_data)
        end_time = time.perf_counter()
        
        processing_time = end_time - start_time
        
        assert processing_time < 0.1  # 100ms ì´ë‚´
        assert order is not None
    
    def test_concurrent_order_processing(self, order_service):
        """ë™ì‹œ ì£¼ë¬¸ ì²˜ë¦¬ í…ŒìŠ¤íŠ¸"""
        def create_order(user_id):
            order_data = {
                'user_id': user_id,
                'symbol': 'BTC/USDT',
                'side': 'BUY',
                'type': 'LIMIT',
                'quantity': Decimal('1.0'),
                'price': Decimal('50000.0')
            }
            return order_service.create_order(order_data)
        
        start_time = time.perf_counter()
        
        with ThreadPoolExecutor(max_workers=10) as executor:
            futures = [
                executor.submit(create_order, f'user_{i}')
                for i in range(100)
            ]
            orders = [future.result() for future in futures]
        
        end_time = time.perf_counter()
        total_time = end_time - start_time
        
        assert len(orders) == 100
        assert total_time < 5.0  # 5ì´ˆ ì´ë‚´
        assert all(order is not None for order in orders)
    
    def test_order_validation_performance(self, order_service):
        """ì£¼ë¬¸ ê²€ì¦ ì„±ëŠ¥ í…ŒìŠ¤íŠ¸"""
        order_data = {
            'user_id': 'user_001',
            'symbol': 'BTC/USDT',
            'side': 'BUY',
            'type': 'LIMIT',
            'quantity': Decimal('1.0'),
            'price': Decimal('50000.0')
        }
        
        start_time = time.perf_counter()
        
        for _ in range(1000):
            order_service.validate_order(order_data)
        
        end_time = time.perf_counter()
        total_time = end_time - start_time
        
        assert total_time < 1.0  # 1ì´ˆ ì´ë‚´ (1000íšŒ ê²€ì¦)
    
    def test_database_operation_performance(self, order_repository, sample_order):
        """ë°ì´í„°ë² ì´ìŠ¤ ì‘ì—… ì„±ëŠ¥ í…ŒìŠ¤íŠ¸"""
        start_time = time.perf_counter()
        
        # 100ê°œ ì£¼ë¬¸ ìƒì„±
        for i in range(100):
            order = Order(
                id=f'perf_test_{i}',
                user_id=f'user_{i % 10}',
                symbol='BTC/USDT',
                side='BUY',
                type='LIMIT',
                quantity=Decimal('1.0'),
                price=Decimal('50000.0'),
                status=OrderStatus.PENDING,
                created_at=datetime.now(timezone.utc)
            )
            order_repository.create(order)
        
        end_time = time.perf_counter()
        total_time = end_time - start_time
        
        assert total_time < 2.0  # 2ì´ˆ ì´ë‚´ (100ê°œ ìƒì„±)
```

### ğŸ§ª **ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸**

```python
# tests/performance/stress/test_system_stress.py
import pytest
import asyncio
import time
from concurrent.futures import ThreadPoolExecutor
from decimal import Decimal
from src.services.order_service import OrderService

class TestSystemStress:
    """ì‹œìŠ¤í…œ ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸"""
    
    @pytest.fixture
    def order_service(self, mock_exchange_api):
        """ì£¼ë¬¸ ì„œë¹„ìŠ¤ ì¸ìŠ¤í„´ìŠ¤"""
        return OrderService(exchange_api=mock_exchange_api)
    
    def test_high_concurrency_order_creation(self, order_service):
        """ê³ ë™ì‹œì„± ì£¼ë¬¸ ìƒì„± í…ŒìŠ¤íŠ¸"""
        def create_order(user_id):
            order_data = {
                'user_id': user_id,
                'symbol': 'BTC/USDT',
                'side': 'BUY',
                'type': 'LIMIT',
                'quantity': Decimal('1.0'),
                'price': Decimal('50000.0')
            }
            return order_service.create_order(order_data)
        
        start_time = time.perf_counter()
        
        with ThreadPoolExecutor(max_workers=50) as executor:
            futures = [
                executor.submit(create_order, f'user_{i}')
                for i in range(1000)
            ]
            orders = [future.result() for future in futures]
        
        end_time = time.perf_counter()
        total_time = end_time - start_time
        
        assert len(orders) == 1000
        assert total_time < 30.0  # 30ì´ˆ ì´ë‚´
        assert all(order is not None for order in orders)
    
    def test_memory_usage_under_load(self, order_service):
        """ë¶€í•˜ í•˜ì—ì„œì˜ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ í…ŒìŠ¤íŠ¸"""
        import psutil
        import os
        
        process = psutil.Process(os.getpid())
        initial_memory = process.memory_info().rss / 1024 / 1024  # MB
        
        # ëŒ€ëŸ‰ì˜ ì£¼ë¬¸ ìƒì„±
        orders = []
        for i in range(10000):
            order_data = {
                'user_id': f'user_{i % 100}',
                'symbol': 'BTC/USDT',
                'side': 'BUY',
                'type': 'LIMIT',
                'quantity': Decimal('1.0'),
                'price': Decimal('50000.0')
            }
            order = order_service.create_order(order_data)
            orders.append(order)
        
        final_memory = process.memory_info().rss / 1024 / 1024  # MB
        memory_increase = final_memory - initial_memory
        
        assert memory_increase < 100  # 100MB ì´ë‚´ ì¦ê°€
        assert len(orders) == 10000
    
    def test_error_handling_under_stress(self, order_service):
        """ìŠ¤íŠ¸ë ˆìŠ¤ í•˜ì—ì„œì˜ ì˜¤ë¥˜ ì²˜ë¦¬ í…ŒìŠ¤íŠ¸"""
        def create_order_with_error(user_id):
            try:
                order_data = {
                    'user_id': user_id,
                    'symbol': 'INVALID/PAIR',  # ë¬´íš¨í•œ ì‹¬ë³¼
                    'side': 'BUY',
                    'type': 'LIMIT',
                    'quantity': Decimal('1.0'),
                    'price': Decimal('50000.0')
                }
                return order_service.create_order(order_data)
            except Exception as e:
                return {'error': str(e)}
        
        with ThreadPoolExecutor(max_workers=20) as executor:
            futures = [
                executor.submit(create_order_with_error, f'user_{i}')
                for i in range(500)
            ]
            results = [future.result() for future in futures]
        
        # ì¼ë¶€ëŠ” ì„±ê³µ, ì¼ë¶€ëŠ” ì‹¤íŒ¨í•´ì•¼ í•¨
        success_count = sum(1 for r in results if 'error' not in r)
        error_count = sum(1 for r in results if 'error' in r)
        
        assert success_count > 0
        assert error_count > 0
        assert success_count + error_count == 500
```

## ğŸ¯ **ì—”ë“œíˆ¬ì—”ë“œ í…ŒìŠ¤íŠ¸ êµ¬í˜„**

### ğŸ§ª **ê±°ë˜ ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸**

```python
# tests/e2e/trading/test_trading_scenarios.py
import pytest
from decimal import Decimal
from src.services.trading_service import TradingService
from src.models.order import OrderStatus

class TestTradingScenarios:
    """ê±°ë˜ ì‹œë‚˜ë¦¬ì˜¤ ì—”ë“œíˆ¬ì—”ë“œ í…ŒìŠ¤íŠ¸"""
    
    @pytest.fixture
    def trading_service(self, mock_exchange_api):
        """ê±°ë˜ ì„œë¹„ìŠ¤ ì¸ìŠ¤í„´ìŠ¤"""
        return TradingService(exchange_api=mock_exchange_api)
    
    def test_complete_buy_order_scenario(self, trading_service):
        """ì™„ì „í•œ ë§¤ìˆ˜ ì£¼ë¬¸ ì‹œë‚˜ë¦¬ì˜¤"""
        # 1. ì‚¬ìš©ì ì”ê³  í™•ì¸
        balance = trading_service.get_user_balance('user_001')
        assert balance['USDT'] >= Decimal('50000.0')
        
        # 2. ì£¼ë¬¸ ìƒì„±
        order_data = {
            'user_id': 'user_001',
            'symbol': 'BTC/USDT',
            'side': 'BUY',
            'type': 'LIMIT',
            'quantity': Decimal('1.0'),
            'price': Decimal('50000.0')
        }
        
        order = trading_service.create_order(order_data)
        assert order.status == OrderStatus.PENDING
        
        # 3. ì£¼ë¬¸ ì‹¤í–‰
        result = trading_service.execute_order(order)
        assert result['success'] is True
        
        # 4. ì£¼ë¬¸ ìƒíƒœ í™•ì¸
        updated_order = trading_service.get_order(order.id)
        assert updated_order.status == OrderStatus.FILLED
        
        # 5. ì”ê³  ì—…ë°ì´íŠ¸ í™•ì¸
        new_balance = trading_service.get_user_balance('user_001')
        assert new_balance['USDT'] < balance['USDT']
        assert new_balance['BTC'] > balance.get('BTC', Decimal('0'))
    
    def test_order_cancellation_scenario(self, trading_service):
        """ì£¼ë¬¸ ì·¨ì†Œ ì‹œë‚˜ë¦¬ì˜¤"""
        # 1. ì£¼ë¬¸ ìƒì„±
        order_data = {
            'user_id': 'user_001',
            'symbol': 'BTC/USDT',
            'side': 'BUY',
            'type': 'LIMIT',
            'quantity': Decimal('1.0'),
            'price': Decimal('50000.0')
        }
        
        order = trading_service.create_order(order_data)
        assert order.status == OrderStatus.PENDING
        
        # 2. ì£¼ë¬¸ ì·¨ì†Œ
        result = trading_service.cancel_order(order)
        assert result['success'] is True
        
        # 3. ì·¨ì†Œ ìƒíƒœ í™•ì¸
        updated_order = trading_service.get_order(order.id)
        assert updated_order.status == OrderStatus.CANCELLED
    
    def test_market_order_scenario(self, trading_service):
        """ì‹œì¥ê°€ ì£¼ë¬¸ ì‹œë‚˜ë¦¬ì˜¤"""
        # 1. ì‹œì¥ê°€ ì£¼ë¬¸ ìƒì„±
        order_data = {
            'user_id': 'user_001',
            'symbol': 'BTC/USDT',
            'side': 'BUY',
            'type': 'MARKET',
            'quantity': Decimal('1.0')
        }
        
        order = trading_service.create_order(order_data)
        assert order.type == 'MARKET'
        
        # 2. ì‹œì¥ê°€ ì£¼ë¬¸ ì‹¤í–‰
        result = trading_service.execute_market_order(order)
        assert result['success'] is True
        
        # 3. ì²´ê²° í™•ì¸
        updated_order = trading_service.get_order(order.id)
        assert updated_order.status == OrderStatus.FILLED
        assert updated_order.filled_price is not None
```

## ğŸ“Š **í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ ë° í’ˆì§ˆ ê´€ë¦¬**

### ğŸ“ˆ **ì»¤ë²„ë¦¬ì§€ ì„¤ì •**

```python
# pytest.ini
[tool:pytest]
testpaths = tests
python_files = test_*.py
python_classes = Test*
python_functions = test_*
addopts = 
    --cov=src
    --cov-report=html
    --cov-report=term-missing
    --cov-fail-under=95
    --strict-markers
    --disable-warnings
markers =
    unit: Unit tests
    integration: Integration tests
    performance: Performance tests
    e2e: End-to-end tests
    slow: Slow running tests
```

### ğŸ“Š **í’ˆì§ˆ ë©”íŠ¸ë¦­**

```python
# tests/conftest.py - í’ˆì§ˆ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
import pytest
import time
from typing import Dict, Any

class QualityMetrics:
    """í’ˆì§ˆ ë©”íŠ¸ë¦­ ìˆ˜ì§‘ê¸°"""
    
    def __init__(self):
        self.metrics = {
            'test_execution_time': {},
            'test_success_rate': {},
            'test_coverage': {},
            'performance_metrics': {}
        }
    
    def record_test_time(self, test_name: str, execution_time: float):
        """í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ì‹œê°„ ê¸°ë¡"""
        self.metrics['test_execution_time'][test_name] = execution_time
    
    def record_test_result(self, test_name: str, success: bool):
        """í…ŒìŠ¤íŠ¸ ê²°ê³¼ ê¸°ë¡"""
        if 'test_results' not in self.metrics:
            self.metrics['test_results'] = {}
        self.metrics['test_results'][test_name] = success
    
    def get_success_rate(self) -> float:
        """ì„±ê³µë¥  ê³„ì‚°"""
        if 'test_results' not in self.metrics:
            return 0.0
        
        results = self.metrics['test_results'].values()
        if not results:
            return 0.0
        
        return sum(results) / len(results) * 100

@pytest.fixture(scope="session")
def quality_metrics():
    """í’ˆì§ˆ ë©”íŠ¸ë¦­ ì¸ìŠ¤í„´ìŠ¤"""
    return QualityMetrics()

@pytest.fixture(autouse=True)
def record_test_metrics(request, quality_metrics):
    """í…ŒìŠ¤íŠ¸ ë©”íŠ¸ë¦­ ìë™ ê¸°ë¡"""
    start_time = time.perf_counter()
    
    yield
    
    end_time = time.perf_counter()
    execution_time = end_time - start_time
    
    test_name = request.node.name
    quality_metrics.record_test_time(test_name, execution_time)
    quality_metrics.record_test_result(test_name, True)  # pytestê°€ ì‹¤íŒ¨í•˜ë©´ ì˜ˆì™¸ ë°œìƒ
```

## ğŸš€ **CI/CD í†µí•©**

### ğŸ“‹ **GitHub Actions ì„¤ì •**

```yaml
# .github/workflows/test.yml
name: Test Suite

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:13
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
    
    steps:
    - uses: actions/checkout@v2
    
    - name: Set up Python
      uses: actions/setup-python@v2
      with:
        python-version: '3.9'
    
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install -r requirements-dev.txt
    
    - name: Run tests
      env:
        DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test_db
      run: |
        pytest tests/ --cov=src --cov-report=xml --cov-report=html
    
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v1
      with:
        file: ./coverage.xml
        flags: unittests
        name: codecov-umbrella
    
    - name: Performance test
      run: |
        pytest tests/performance/ -v
    
    - name: E2E test
      run: |
        pytest tests/e2e/ -v
```

## ğŸ“Š **í…ŒìŠ¤íŠ¸ ê²°ê³¼ ëŒ€ì‹œë³´ë“œ**

### ğŸ“ˆ **ì„±ëŠ¥ ì§€í‘œ**

```python
# tests/reports/performance_report.py
import json
from datetime import datetime
from typing import Dict, List, Any

class PerformanceReport:
    """ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ ë¦¬í¬íŠ¸"""
    
    def __init__(self):
        self.report_data = {
            'timestamp': datetime.now().isoformat(),
            'test_results': {},
            'performance_metrics': {},
            'quality_metrics': {}
        }
    
    def add_test_result(self, test_name: str, result: Dict[str, Any]):
        """í…ŒìŠ¤íŠ¸ ê²°ê³¼ ì¶”ê°€"""
        self.report_data['test_results'][test_name] = result
    
    def add_performance_metric(self, metric_name: str, value: float):
        """ì„±ëŠ¥ ë©”íŠ¸ë¦­ ì¶”ê°€"""
        self.report_data['performance_metrics'][metric_name] = value
    
    def generate_report(self) -> str:
        """ë¦¬í¬íŠ¸ ìƒì„±"""
        return json.dumps(self.report_data, indent=2)
    
    def save_report(self, filename: str):
        """ë¦¬í¬íŠ¸ ì €ì¥"""
        with open(filename, 'w') as f:
            json.dump(self.report_data, f, indent=2)

# ì‚¬ìš© ì˜ˆì‹œ
def test_performance_reporting():
    """ì„±ëŠ¥ ë¦¬í¬íŠ¸ í…ŒìŠ¤íŠ¸"""
    report = PerformanceReport()
    
    # í…ŒìŠ¤íŠ¸ ê²°ê³¼ ì¶”ê°€
    report.add_test_result('order_creation', {
        'execution_time': 0.05,
        'success': True,
        'memory_usage': 10.5
    })
    
    # ì„±ëŠ¥ ë©”íŠ¸ë¦­ ì¶”ê°€
    report.add_performance_metric('orders_per_second', 1000)
    report.add_performance_metric('average_response_time', 0.1)
    
    # ë¦¬í¬íŠ¸ ìƒì„±
    report_content = report.generate_report()
    assert 'order_creation' in report_content
    assert 'orders_per_second' in report_content
```

## ğŸ¯ **ë‹¤ìŒ ë‹¨ê³„**

### ğŸ“‹ **ì™„ë£Œëœ ì‘ì—…**
- âœ… ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ í”„ë ˆì„ì›Œí¬ êµ¬ì¶•
- âœ… í†µí•© í…ŒìŠ¤íŠ¸ êµ¬ì¡° ì„¤ê³„
- âœ… ì„±ëŠ¥ í…ŒìŠ¤íŠ¸ êµ¬í˜„
- âœ… ì—”ë“œíˆ¬ì—”ë“œ í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤
- âœ… CI/CD í†µí•© ì„¤ì •

### ğŸ”„ **ì§„í–‰ ì¤‘ì¸ ì‘ì—…**
- ğŸ”„ í…ŒìŠ¤íŠ¸ ë°ì´í„° ê´€ë¦¬ ì‹œìŠ¤í…œ
- ğŸ”„ ìë™í™”ëœ í…ŒìŠ¤íŠ¸ ì‹¤í–‰ ìŠ¤í¬ë¦½íŠ¸
- ğŸ”„ ì‹¤ì‹œê°„ í…ŒìŠ¤íŠ¸ ëª¨ë‹ˆí„°ë§

### â³ **ë‹¤ìŒ ë‹¨ê³„**
1. **Phase 0.4 ë°°í¬ ë° ìš´ì˜** ë¬¸ì„œ ìƒì„±
2. **Phase 1 í™•ì¥** ë¬¸ì„œë“¤ ìƒì„±
3. **ê³µí†µ ì»´í¬ë„ŒíŠ¸** ë¬¸ì„œë“¤ ìƒì„±

---

**ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸**: 2024-01-31
**ë‹¤ìŒ ì—…ë°ì´íŠ¸**: 2024-02-01 (Phase 0.4 ë°°í¬ ë° ìš´ì˜)
**í…ŒìŠ¤íŠ¸ ì»¤ë²„ë¦¬ì§€ ëª©í‘œ**: 95% ì´ìƒ
**ì„±ëŠ¥ ëª©í‘œ**: ëª¨ë“  ì„±ëŠ¥ ìš”êµ¬ì‚¬í•­ ì¶©ì¡± 