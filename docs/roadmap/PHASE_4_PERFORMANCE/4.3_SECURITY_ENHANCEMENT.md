# ğŸ”’ Phase 4.3: ì—”í„°í”„ë¼ì´ì¦ˆ ë³´ì•ˆ ê°•í™” ì‹œìŠ¤í…œ

## ğŸ“‹ **ê°œìš”**

### ğŸ¯ **ëª©í‘œ**
- **ì œë¡œ íŠ¸ëŸ¬ìŠ¤íŠ¸**: ëª¨ë“  ì ‘ê·¼ ê²€ì¦, ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ë„¤íŠ¸ì›Œí¬ ì—†ìŒ
- **HSM (Hardware Security Module)**: í‚¤ ê´€ë¦¬ ë° ì•”í˜¸í™” ì—°ì‚°
- **ìƒì²´ì¸ì‹**: ë‹¤ì¤‘ ì¸ì¦ í•„ìˆ˜, ë³´ì•ˆì„± ê·¹ëŒ€í™”
- **ë„¤íŠ¸ì›Œí¬ ë¶„ë¦¬**: DMZ, ì„œë¸Œë„· ë¶„ë¦¬, ë°©í™”ë²½ ì •ì±…
- **ì¹¨ì… íƒì§€**: ì‹¤ì‹œê°„ ë³´ì•ˆ ëª¨ë‹ˆí„°ë§ ë° ëŒ€ì‘
- **ì·¨ì•½ì  ìŠ¤ìº”**: ì •ê¸°ì  ìë™ ìŠ¤ìº” ë° íŒ¨ì¹˜ ê´€ë¦¬

### ğŸ“Š **ë³´ì•ˆ ëª©í‘œ**
- **ì œë¡œ íŠ¸ëŸ¬ìŠ¤íŠ¸ ì¤€ìˆ˜**: 100% ëª¨ë“  ì ‘ê·¼ ê²€ì¦
- **HSM í‚¤ ê´€ë¦¬**: 100% í•˜ë“œì›¨ì–´ ê¸°ë°˜ í‚¤ ë³´í˜¸
- **ìƒì²´ì¸ì‹ ì •í™•ë„**: > 99.9% ì¸ì¦ ì •í™•ë„
- **ì¹¨ì… íƒì§€ ì •í™•ë„**: > 95% íƒì§€ìœ¨, < 1% ì˜¤íƒìœ¨
- **ì·¨ì•½ì  ëŒ€ì‘ ì‹œê°„**: < 1ì‹œê°„ íŒ¨ì¹˜ ì ìš©
- **ë³´ì•ˆ ì‚¬ê³  ëŒ€ì‘**: < 15ë¶„ ì´ˆê¸° ëŒ€ì‘, < 1ì‹œê°„ ì™„ì „ ë³µêµ¬

## ğŸ—ï¸ **ë³´ì•ˆ ê°•í™” ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜**

### ğŸ“ **ë³´ì•ˆ ì‹œìŠ¤í…œ êµ¬ì¡°**
```
security-enhancement/
â”œâ”€â”€ zero-trust/                      # ì œë¡œ íŠ¸ëŸ¬ìŠ¤íŠ¸ ì‹œìŠ¤í…œ
â”‚   â”œâ”€â”€ identity-verification/       # ì‹ ì› í™•ì¸
â”‚   â”œâ”€â”€ device-trust/                # ë””ë°”ì´ìŠ¤ ì‹ ë¢°ë„
â”‚   â”œâ”€â”€ network-trust/               # ë„¤íŠ¸ì›Œí¬ ì‹ ë¢°ë„
â”‚   â””â”€â”€ behavior-analysis/           # í–‰ë™ íŒ¨í„´ ë¶„ì„
â”œâ”€â”€ hsm-management/                  # HSM ê´€ë¦¬
â”‚   â”œâ”€â”€ key-generation/              # í‚¤ ìƒì„±
â”‚   â”œâ”€â”€ key-storage/                 # í‚¤ ì €ì¥
â”‚   â”œâ”€â”€ encryption-operations/       # ì•”í˜¸í™” ì—°ì‚°
â”‚   â””â”€â”€ digital-signing/             # ë””ì§€í„¸ ì„œëª…
â”œâ”€â”€ biometric-authentication/        # ìƒì²´ì¸ì‹ ì¸ì¦
â”‚   â”œâ”€â”€ fingerprint/                 # ì§€ë¬¸ ì¸ì‹
â”‚   â”œâ”€â”€ face-recognition/            # ì–¼êµ´ ì¸ì‹
â”‚   â”œâ”€â”€ voice-recognition/           # ìŒì„± ì¸ì‹
â”‚   â””â”€â”€ iris-recognition/            # í™ì±„ ì¸ì‹
â”œâ”€â”€ network-security/                # ë„¤íŠ¸ì›Œí¬ ë³´ì•ˆ
â”‚   â”œâ”€â”€ firewall-management/         # ë°©í™”ë²½ ê´€ë¦¬
â”‚   â”œâ”€â”€ vpn-management/              # VPN ê´€ë¦¬
â”‚   â”œâ”€â”€ network-monitoring/          # ë„¤íŠ¸ì›Œí¬ ëª¨ë‹ˆí„°ë§
â”‚   â””â”€â”€ traffic-analysis/            # íŠ¸ë˜í”½ ë¶„ì„
â”œâ”€â”€ intrusion-detection/             # ì¹¨ì… íƒì§€
â”‚   â”œâ”€â”€ pattern-detection/           # íŒ¨í„´ íƒì§€
â”‚   â”œâ”€â”€ anomaly-detection/           # ì´ìƒ íƒì§€
â”‚   â”œâ”€â”€ threat-intelligence/         # ìœ„í˜‘ ì •ë³´
â”‚   â””â”€â”€ incident-response/           # ì‚¬ê³  ëŒ€ì‘
â””â”€â”€ vulnerability-management/        # ì·¨ì•½ì  ê´€ë¦¬
    â”œâ”€â”€ vulnerability-scanning/      # ì·¨ì•½ì  ìŠ¤ìº”
    â”œâ”€â”€ patch-management/            # íŒ¨ì¹˜ ê´€ë¦¬
    â”œâ”€â”€ compliance-monitoring/       # ê·œì • ì¤€ìˆ˜ ëª¨ë‹ˆí„°ë§
    â””â”€â”€ security-auditing/           # ë³´ì•ˆ ê°ì‚¬
```

## ğŸ”§ **ì œë¡œ íŠ¸ëŸ¬ìŠ¤íŠ¸ ì‹œìŠ¤í…œ**

### ğŸ“¦ **ì œë¡œ íŠ¸ëŸ¬ìŠ¤íŠ¸ ì ‘ê·¼ ì œì–´**

```python
# security-enhancement/zero-trust/zero_trust_access_control.py
import asyncio
import time
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass
from datetime import datetime, timedelta
import logging
import hashlib
import jwt
import bcrypt
from enum import Enum

logger = logging.getLogger(__name__)

class TrustLevel(Enum):
    """ì‹ ë¢°ë„ ë ˆë²¨"""
    NONE = 0
    LOW = 1
    MEDIUM = 2
    HIGH = 3
    VERY_HIGH = 4

class AuthenticationFactor(Enum):
    """ì¸ì¦ ìš”ì†Œ"""
    PASSWORD = "password"
    TWO_FACTOR = "2fa"
    BIOMETRIC = "biometric"
    HARDWARE_TOKEN = "hardware_token"
    LOCATION = "location"
    TIME = "time"
    BEHAVIOR = "behavior"

@dataclass
class UserIdentity:
    """ì‚¬ìš©ì ì‹ ì›"""
    user_id: str
    username: str
    email: str
    role: str
    permissions: List[str]
    last_login: datetime
    failed_attempts: int
    is_locked: bool

@dataclass
class DeviceInfo:
    """ë””ë°”ì´ìŠ¤ ì •ë³´"""
    device_id: str
    device_type: str
    os_version: str
    security_patches: List[str]
    is_registered: bool
    is_healthy: bool
    last_seen: datetime
    location: str

@dataclass
class NetworkInfo:
    """ë„¤íŠ¸ì›Œí¬ ì •ë³´"""
    ip_address: str
    is_vpn: bool
    is_trusted_network: bool
    is_encrypted: bool
    network_type: str
    location: str

@dataclass
class AccessRequest:
    """ì ‘ê·¼ ìš”ì²­"""
    request_id: str
    user_id: str
    resource: str
    action: str
    timestamp: datetime
    device_info: DeviceInfo
    network_info: NetworkInfo
    auth_factors: List[AuthenticationFactor]
    context: Dict[str, Any]

@dataclass
class AccessDecision:
    """ì ‘ê·¼ ê²°ì •"""
    request_id: str
    access_granted: bool
    trust_score: float
    reason: str
    timestamp: datetime
    session_duration: int
    additional_requirements: List[str]

class ZeroTrustAccessControl:
    """ì œë¡œ íŠ¸ëŸ¬ìŠ¤íŠ¸ ì ‘ê·¼ ì œì–´"""
    
    def __init__(self, 
                 min_trust_score: float = 0.7,
                 session_timeout_minutes: int = 30,
                 max_failed_attempts: int = 5):
        self.min_trust_score = min_trust_score
        self.session_timeout_minutes = session_timeout_minutes
        self.max_failed_attempts = max_failed_attempts
        
        # ì‹ ë¢°ë„ ì—”ì§„
        self.trust_engine = TrustEngine()
        
        # ì ‘ê·¼ ì •ì±…
        self.access_policy = AccessPolicy()
        
        # í–‰ë™ ë¶„ì„ê¸°
        self.behavior_analyzer = BehaviorAnalyzer()
        
        # ë””ë°”ì´ìŠ¤ ê´€ë¦¬ì
        self.device_manager = DeviceManager()
        
        # ì„¸ì…˜ ê´€ë¦¬ì
        self.session_manager = SessionManager()
        
        logger.info("Zero trust access control initialized")
    
    async def verify_access(self, request: AccessRequest) -> AccessDecision:
        """ì ‘ê·¼ ê²€ì¦"""
        try:
            # 1. ì‚¬ìš©ì ì‹ ì› í™•ì¸
            user_identity = await self._verify_user_identity(request.user_id, request.auth_factors)
            if not user_identity:
                return AccessDecision(
                    request_id=request.request_id,
                    access_granted=False,
                    trust_score=0.0,
                    reason="User identity verification failed",
                    timestamp=datetime.now(),
                    session_duration=0,
                    additional_requirements=[]
                )
            
            # 2. ë””ë°”ì´ìŠ¤ ì‹ ë¢°ë„ í™•ì¸
            device_trust = await self._verify_device_trust(request.device_info)
            
            # 3. ë„¤íŠ¸ì›Œí¬ ì‹ ë¢°ë„ í™•ì¸
            network_trust = await self._verify_network_trust(request.network_info)
            
            # 4. í–‰ë™ íŒ¨í„´ ë¶„ì„
            behavior_trust = await self._analyze_behavior(request)
            
            # 5. ì¢…í•© ì‹ ë¢°ë„ ê³„ì‚°
            total_trust = self.trust_engine.calculate_trust_score([
                user_identity['trust_score'],
                device_trust,
                network_trust,
                behavior_trust
            ])
            
            # 6. ì ‘ê·¼ ì •ì±… ì ìš©
            access_granted = self.access_policy.evaluate_access(
                total_trust, request.resource, request.action, user_identity
            )
            
            # 7. ì„¸ì…˜ ìƒì„±
            session_duration = self._calculate_session_duration(total_trust)
            
            # 8. ì¶”ê°€ ìš”êµ¬ì‚¬í•­ í™•ì¸
            additional_requirements = self._get_additional_requirements(
                total_trust, request.resource
            )
            
            decision = AccessDecision(
                request_id=request.request_id,
                access_granted=access_granted,
                trust_score=total_trust,
                reason="Access granted" if access_granted else "Insufficient trust",
                timestamp=datetime.now(),
                session_duration=session_duration,
                additional_requirements=additional_requirements
            )
            
            # 9. ì ‘ê·¼ ë¡œê·¸ ê¸°ë¡
            await self._log_access_attempt(request, decision)
            
            return decision
            
        except Exception as e:
            logger.error(f"Access verification failed: {e}")
            return AccessDecision(
                request_id=request.request_id,
                access_granted=False,
                trust_score=0.0,
                reason=f"Verification error: {str(e)}",
                timestamp=datetime.now(),
                session_duration=0,
                additional_requirements=[]
            )
    
    async def _verify_user_identity(self, user_id: str, 
                                  auth_factors: List[AuthenticationFactor]) -> Optional[Dict[str, Any]]:
        """ì‚¬ìš©ì ì‹ ì› í™•ì¸"""
        try:
            # ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ
            user = await self._get_user_by_id(user_id)
            if not user:
                return None
            
            # ê³„ì • ì ê¸ˆ í™•ì¸
            if user.is_locked:
                logger.warning(f"User account locked: {user_id}")
                return None
            
            # ì¸ì¦ ìš”ì†Œë³„ ì‹ ë¢°ë„ ê³„ì‚°
            trust_score = 0.0
            total_weight = 0.0
            
            auth_weights = {
                AuthenticationFactor.PASSWORD: 0.2,
                AuthenticationFactor.TWO_FACTOR: 0.3,
                AuthenticationFactor.BIOMETRIC: 0.4,
                AuthenticationFactor.HARDWARE_TOKEN: 0.2,
                AuthenticationFactor.LOCATION: 0.1,
                AuthenticationFactor.TIME: 0.1,
                AuthenticationFactor.BEHAVIOR: 0.2
            }
            
            for factor in auth_factors:
                if factor in auth_weights:
                    factor_trust = await self._verify_auth_factor(user_id, factor)
                    trust_score += factor_trust * auth_weights[factor]
                    total_weight += auth_weights[factor]
            
            if total_weight > 0:
                trust_score = trust_score / total_weight
            
            return {
                'user': user,
                'trust_score': trust_score
            }
            
        except Exception as e:
            logger.error(f"User identity verification failed: {e}")
            return None
    
    async def _verify_auth_factor(self, user_id: str, factor: AuthenticationFactor) -> float:
        """ì¸ì¦ ìš”ì†Œ í™•ì¸"""
        try:
            if factor == AuthenticationFactor.PASSWORD:
                return await self._verify_password(user_id)
            elif factor == AuthenticationFactor.TWO_FACTOR:
                return await self._verify_2fa(user_id)
            elif factor == AuthenticationFactor.BIOMETRIC:
                return await self._verify_biometric(user_id)
            elif factor == AuthenticationFactor.HARDWARE_TOKEN:
                return await self._verify_hardware_token(user_id)
            elif factor == AuthenticationFactor.LOCATION:
                return await self._verify_location(user_id)
            elif factor == AuthenticationFactor.TIME:
                return await self._verify_time(user_id)
            elif factor == AuthenticationFactor.BEHAVIOR:
                return await self._verify_behavior(user_id)
            else:
                return 0.0
                
        except Exception as e:
            logger.error(f"Auth factor verification failed: {e}")
            return 0.0
    
    async def _verify_password(self, user_id: str) -> float:
        """ë¹„ë°€ë²ˆí˜¸ í™•ì¸"""
        try:
            # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ë¹„ë°€ë²ˆí˜¸ í•´ì‹œ í™•ì¸
            # ì—¬ê¸°ì„œëŠ” ì‹œë®¬ë ˆì´ì…˜
            return 0.8 if np.random.random() > 0.1 else 0.0
            
        except Exception as e:
            logger.error(f"Password verification failed: {e}")
            return 0.0
    
    async def _verify_2fa(self, user_id: str) -> float:
        """2FA í™•ì¸"""
        try:
            # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” 2FA í† í° í™•ì¸
            # ì—¬ê¸°ì„œëŠ” ì‹œë®¬ë ˆì´ì…˜
            return 0.9 if np.random.random() > 0.05 else 0.0
            
        except Exception as e:
            logger.error(f"2FA verification failed: {e}")
            return 0.0
    
    async def _verify_biometric(self, user_id: str) -> float:
        """ìƒì²´ì¸ì‹ í™•ì¸"""
        try:
            # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ìƒì²´ì¸ì‹ ë°ì´í„° í™•ì¸
            # ì—¬ê¸°ì„œëŠ” ì‹œë®¬ë ˆì´ì…˜
            return 0.95 if np.random.random() > 0.02 else 0.0
            
        except Exception as e:
            logger.error(f"Biometric verification failed: {e}")
            return 0.0
    
    async def _verify_hardware_token(self, user_id: str) -> float:
        """í•˜ë“œì›¨ì–´ í† í° í™•ì¸"""
        try:
            # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” í•˜ë“œì›¨ì–´ í† í° í™•ì¸
            # ì—¬ê¸°ì„œëŠ” ì‹œë®¬ë ˆì´ì…˜
            return 0.85 if np.random.random() > 0.1 else 0.0
            
        except Exception as e:
            logger.error(f"Hardware token verification failed: {e}")
            return 0.0
    
    async def _verify_location(self, user_id: str) -> float:
        """ìœ„ì¹˜ í™•ì¸"""
        try:
            # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì‚¬ìš©ì ìœ„ì¹˜ í™•ì¸
            # ì—¬ê¸°ì„œëŠ” ì‹œë®¬ë ˆì´ì…˜
            return 0.7 if np.random.random() > 0.2 else 0.0
            
        except Exception as e:
            logger.error(f"Location verification failed: {e}")
            return 0.0
    
    async def _verify_time(self, user_id: str) -> float:
        """ì‹œê°„ í™•ì¸"""
        try:
            # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì‚¬ìš© íŒ¨í„´ ì‹œê°„ í™•ì¸
            # ì—¬ê¸°ì„œëŠ” ì‹œë®¬ë ˆì´ì…˜
            current_hour = datetime.now().hour
            if 9 <= current_hour <= 18:  # ì—…ë¬´ ì‹œê°„
                return 0.8
            else:
                return 0.4
                
        except Exception as e:
            logger.error(f"Time verification failed: {e}")
            return 0.0
    
    async def _verify_behavior(self, user_id: str) -> float:
        """í–‰ë™ íŒ¨í„´ í™•ì¸"""
        try:
            # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì‚¬ìš©ì í–‰ë™ íŒ¨í„´ ë¶„ì„
            # ì—¬ê¸°ì„œëŠ” ì‹œë®¬ë ˆì´ì…˜
            return 0.75 if np.random.random() > 0.15 else 0.0
            
        except Exception as e:
            logger.error(f"Behavior verification failed: {e}")
            return 0.0
    
    async def _verify_device_trust(self, device_info: DeviceInfo) -> float:
        """ë””ë°”ì´ìŠ¤ ì‹ ë¢°ë„ í™•ì¸"""
        try:
            trust_score = 0.0
            
            # ë“±ë¡ëœ ë””ë°”ì´ìŠ¤ í™•ì¸
            if device_info.is_registered:
                trust_score += 0.3
            
            # ë””ë°”ì´ìŠ¤ ìƒíƒœ í™•ì¸
            if device_info.is_healthy:
                trust_score += 0.2
            
            # ë³´ì•ˆ íŒ¨ì¹˜ í™•ì¸
            if len(device_info.security_patches) > 0:
                trust_score += 0.2
            
            # ìµœê·¼ ì ‘ì† í™•ì¸
            time_diff = datetime.now() - device_info.last_seen
            if time_diff < timedelta(hours=24):
                trust_score += 0.3
            
            return min(trust_score, 1.0)
            
        except Exception as e:
            logger.error(f"Device trust verification failed: {e}")
            return 0.0
    
    async def _verify_network_trust(self, network_info: NetworkInfo) -> float:
        """ë„¤íŠ¸ì›Œí¬ ì‹ ë¢°ë„ í™•ì¸"""
        try:
            trust_score = 0.0
            
            # VPN ì‚¬ìš© í™•ì¸
            if network_info.is_vpn:
                trust_score += 0.3
            
            # ì‹ ë¢°í•  ìˆ˜ ìˆëŠ” ë„¤íŠ¸ì›Œí¬ í™•ì¸
            if network_info.is_trusted_network:
                trust_score += 0.4
            
            # ì•”í˜¸í™” í™•ì¸
            if network_info.is_encrypted:
                trust_score += 0.2
            
            # ë„¤íŠ¸ì›Œí¬ íƒ€ì… í™•ì¸
            if network_info.network_type in ['wired', 'enterprise_wifi']:
                trust_score += 0.1
            
            return min(trust_score, 1.0)
            
        except Exception as e:
            logger.error(f"Network trust verification failed: {e}")
            return 0.0
    
    async def _analyze_behavior(self, request: AccessRequest) -> float:
        """í–‰ë™ íŒ¨í„´ ë¶„ì„"""
        try:
            # í–‰ë™ ë¶„ì„ê¸°ì—ì„œ ë¶„ì„ ìˆ˜í–‰
            behavior_score = await self.behavior_analyzer.analyze_user_behavior(
                request.user_id, request.context
            )
            
            return behavior_score
            
        except Exception as e:
            logger.error(f"Behavior analysis failed: {e}")
            return 0.5  # ê¸°ë³¸ ì ìˆ˜
    
    def _calculate_session_duration(self, trust_score: float) -> int:
        """ì„¸ì…˜ ì§€ì† ì‹œê°„ ê³„ì‚°"""
        try:
            # ì‹ ë¢°ë„ì— ë”°ë¥¸ ì„¸ì…˜ ì‹œê°„ ì¡°ì •
            base_duration = self.session_timeout_minutes
            
            if trust_score >= 0.9:
                return base_duration * 2  # 2ë°° ì—°ì¥
            elif trust_score >= 0.7:
                return base_duration  # ê¸°ë³¸ ì‹œê°„
            elif trust_score >= 0.5:
                return base_duration // 2  # ì ˆë°˜ ì‹œê°„
            else:
                return 5  # 5ë¶„ë§Œ í—ˆìš©
                
        except Exception as e:
            logger.error(f"Session duration calculation failed: {e}")
            return self.session_timeout_minutes
    
    def _get_additional_requirements(self, trust_score: float, resource: str) -> List[str]:
        """ì¶”ê°€ ìš”êµ¬ì‚¬í•­ í™•ì¸"""
        try:
            requirements = []
            
            # ë†’ì€ ë³´ì•ˆ ë¦¬ì†ŒìŠ¤ì— ëŒ€í•œ ì¶”ê°€ ìš”êµ¬ì‚¬í•­
            if 'admin' in resource or 'sensitive' in resource:
                if trust_score < 0.8:
                    requirements.append('additional_biometric_verification')
                if trust_score < 0.9:
                    requirements.append('manager_approval')
            
            # ê¸ˆìœµ ê±°ë˜ì— ëŒ€í•œ ì¶”ê°€ ìš”êµ¬ì‚¬í•­
            if 'trading' in resource or 'financial' in resource:
                if trust_score < 0.85:
                    requirements.append('hardware_token_required')
                requirements.append('transaction_limit_check')
            
            return requirements
            
        except Exception as e:
            logger.error(f"Additional requirements check failed: {e}")
            return []
    
    async def _log_access_attempt(self, request: AccessRequest, decision: AccessDecision):
        """ì ‘ê·¼ ì‹œë„ ë¡œê·¸ ê¸°ë¡"""
        try:
            log_entry = {
                'timestamp': datetime.now().isoformat(),
                'request_id': request.request_id,
                'user_id': request.user_id,
                'resource': request.resource,
                'action': request.action,
                'access_granted': decision.access_granted,
                'trust_score': decision.trust_score,
                'reason': decision.reason,
                'ip_address': request.network_info.ip_address,
                'device_id': request.device_info.device_id,
                'auth_factors': [factor.value for factor in request.auth_factors]
            }
            
            # ë¡œê·¸ ì €ì¥
            # await self.log_manager.store_access_log(log_entry)
            
            logger.info(f"Access attempt logged: {log_entry}")
            
        except Exception as e:
            logger.error(f"Access log recording failed: {e}")

class TrustEngine:
    """ì‹ ë¢°ë„ ì—”ì§„"""
    
    def calculate_trust_score(self, trust_scores: List[float]) -> float:
        """ì¢…í•© ì‹ ë¢°ë„ ê³„ì‚°"""
        try:
            if not trust_scores:
                return 0.0
            
            # ê°€ì¤‘ í‰ê·  ê³„ì‚°
            weights = [0.4, 0.2, 0.2, 0.2]  # ì‹ ì›, ë””ë°”ì´ìŠ¤, ë„¤íŠ¸ì›Œí¬, í–‰ë™
            
            weighted_sum = sum(score * weight for score, weight in zip(trust_scores, weights))
            
            return min(weighted_sum, 1.0)
            
        except Exception as e:
            logger.error(f"Trust score calculation failed: {e}")
            return 0.0

class AccessPolicy:
    """ì ‘ê·¼ ì •ì±…"""
    
    def evaluate_access(self, trust_score: float, resource: str, action: str, 
                       user_identity: Dict[str, Any]) -> bool:
        """ì ‘ê·¼ ê¶Œí•œ í‰ê°€"""
        try:
            user = user_identity['user']
            
            # ìµœì†Œ ì‹ ë¢°ë„ í™•ì¸
            if trust_score < 0.5:
                return False
            
            # ì—­í•  ê¸°ë°˜ ì ‘ê·¼ ì œì–´
            if not self._check_role_permission(user.role, resource, action):
                return False
            
            # ë¦¬ì†ŒìŠ¤ë³„ ì¶”ê°€ ì •ì±…
            if 'admin' in resource and trust_score < 0.8:
                return False
            
            if 'financial' in resource and trust_score < 0.7:
                return False
            
            return True
            
        except Exception as e:
            logger.error(f"Access policy evaluation failed: {e}")
            return False
    
    def _check_role_permission(self, role: str, resource: str, action: str) -> bool:
        """ì—­í•  ê¶Œí•œ í™•ì¸"""
        try:
            # ì—­í• ë³„ ê¶Œí•œ ë§¤íŠ¸ë¦­ìŠ¤
            permissions = {
                'admin': ['*'],  # ëª¨ë“  ê¶Œí•œ
                'trader': ['trading', 'portfolio', 'analysis'],
                'analyst': ['analysis', 'reports'],
                'viewer': ['reports', 'dashboard']
            }
            
            if role not in permissions:
                return False
            
            role_permissions = permissions[role]
            
            # ì™€ì¼ë“œì¹´ë“œ ê¶Œí•œ í™•ì¸
            if '*' in role_permissions:
                return True
            
            # ë¦¬ì†ŒìŠ¤ ê¶Œí•œ í™•ì¸
            for permission in role_permissions:
                if permission in resource:
                    return True
            
            return False
            
        except Exception as e:
            logger.error(f"Role permission check failed: {e}")
            return False

class BehaviorAnalyzer:
    """í–‰ë™ ë¶„ì„ê¸°"""
    
    async def analyze_user_behavior(self, user_id: str, context: Dict[str, Any]) -> float:
        """ì‚¬ìš©ì í–‰ë™ ë¶„ì„"""
        try:
            # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì‚¬ìš©ì í–‰ë™ íŒ¨í„´ ë¶„ì„
            # ì—¬ê¸°ì„œëŠ” ì‹œë®¬ë ˆì´ì…˜
            
            behavior_score = 0.5  # ê¸°ë³¸ ì ìˆ˜
            
            # ì‹œê°„ íŒ¨í„´ ë¶„ì„
            if self._is_normal_time_pattern(context):
                behavior_score += 0.2
            
            # ìœ„ì¹˜ íŒ¨í„´ ë¶„ì„
            if self._is_normal_location_pattern(context):
                behavior_score += 0.2
            
            # í–‰ë™ íŒ¨í„´ ë¶„ì„
            if self._is_normal_behavior_pattern(context):
                behavior_score += 0.1
            
            return min(behavior_score, 1.0)
            
        except Exception as e:
            logger.error(f"Behavior analysis failed: {e}")
            return 0.5
    
    def _is_normal_time_pattern(self, context: Dict[str, Any]) -> bool:
        """ì •ìƒ ì‹œê°„ íŒ¨í„´ í™•ì¸"""
        try:
            current_hour = datetime.now().hour
            return 9 <= current_hour <= 18  # ì—…ë¬´ ì‹œê°„
            
        except Exception as e:
            logger.error(f"Time pattern analysis failed: {e}")
            return False
    
    def _is_normal_location_pattern(self, context: Dict[str, Any]) -> bool:
        """ì •ìƒ ìœ„ì¹˜ íŒ¨í„´ í™•ì¸"""
        try:
            # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì‚¬ìš©ì ìœ„ì¹˜ íŒ¨í„´ ë¶„ì„
            return True
            
        except Exception as e:
            logger.error(f"Location pattern analysis failed: {e}")
            return False
    
    def _is_normal_behavior_pattern(self, context: Dict[str, Any]) -> bool:
        """ì •ìƒ í–‰ë™ íŒ¨í„´ í™•ì¸"""
        try:
            # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì‚¬ìš©ì í–‰ë™ íŒ¨í„´ ë¶„ì„
            return True
            
        except Exception as e:
            logger.error(f"Behavior pattern analysis failed: {e}")
            return False

class DeviceManager:
    """ë””ë°”ì´ìŠ¤ ê´€ë¦¬ì"""
    
    async def register_device(self, device_info: DeviceInfo) -> bool:
        """ë””ë°”ì´ìŠ¤ ë“±ë¡"""
        try:
            # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ë””ë°”ì´ìŠ¤ ë“±ë¡ ë¡œì§
            return True
            
        except Exception as e:
            logger.error(f"Device registration failed: {e}")
            return False
    
    async def verify_device_health(self, device_id: str) -> bool:
        """ë””ë°”ì´ìŠ¤ ìƒíƒœ í™•ì¸"""
        try:
            # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ë””ë°”ì´ìŠ¤ ìƒíƒœ í™•ì¸
            return True
            
        except Exception as e:
            logger.error(f"Device health verification failed: {e}")
            return False

class SessionManager:
    """ì„¸ì…˜ ê´€ë¦¬ì"""
    
    def __init__(self):
        self.active_sessions = {}
    
    def create_session(self, user_id: str, session_duration: int) -> str:
        """ì„¸ì…˜ ìƒì„±"""
        try:
            session_id = hashlib.sha256(f"{user_id}_{time.time()}".encode()).hexdigest()
            
            self.active_sessions[session_id] = {
                'user_id': user_id,
                'created_at': datetime.now(),
                'expires_at': datetime.now() + timedelta(minutes=session_duration),
                'is_active': True
            }
            
            return session_id
            
        except Exception as e:
            logger.error(f"Session creation failed: {e}")
            return None
    
    def validate_session(self, session_id: str) -> bool:
        """ì„¸ì…˜ ìœ íš¨ì„± í™•ì¸"""
        try:
            if session_id not in self.active_sessions:
                return False
            
            session = self.active_sessions[session_id]
            
            if not session['is_active']:
                return False
            
            if datetime.now() > session['expires_at']:
                session['is_active'] = False
                return False
            
            return True
            
        except Exception as e:
            logger.error(f"Session validation failed: {e}")
            return False
    
    def invalidate_session(self, session_id: str):
        """ì„¸ì…˜ ë¬´íš¨í™”"""
        try:
            if session_id in self.active_sessions:
                self.active_sessions[session_id]['is_active'] = False
                
        except Exception as e:
            logger.error(f"Session invalidation failed: {e}")
```

## ğŸ”§ **HSM ê´€ë¦¬ ì‹œìŠ¤í…œ**

### ğŸ“¦ **í•˜ë“œì›¨ì–´ ë³´ì•ˆ ëª¨ë“ˆ ê´€ë¦¬**

```python
# security-enhancement/hsm-management/hsm_manager.py
import asyncio
import hashlib
import hmac
import os
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass
from datetime import datetime
import logging
import base64

logger = logging.getLogger(__name__)

@dataclass
class HSMKey:
    """HSM í‚¤"""
    key_id: str
    key_type: str  # 'AES', 'RSA', 'ECC'
    key_size: int
    created_at: datetime
    expires_at: Optional[datetime] = None
    is_active: bool = True
    usage_count: int = 0

@dataclass
class EncryptionRequest:
    """ì•”í˜¸í™” ìš”ì²­"""
    request_id: str
    key_id: str
    data: bytes
    algorithm: str
    mode: str = 'CBC'
    iv: Optional[bytes] = None

@dataclass
class EncryptionResult:
    """ì•”í˜¸í™” ê²°ê³¼"""
    request_id: str
    encrypted_data: bytes
    iv: bytes
    key_id: str
    algorithm: str
    timestamp: datetime

@dataclass
class SigningRequest:
    """ì„œëª… ìš”ì²­"""
    request_id: str
    key_id: str
    data: bytes
    algorithm: str = 'RSA-SHA256'

@dataclass
class SigningResult:
    """ì„œëª… ê²°ê³¼"""
    request_id: str
    signature: bytes
    key_id: str
    algorithm: str
    timestamp: datetime

class HSMManager:
    """HSM ê´€ë¦¬ì"""
    
    def __init__(self, hsm_connection_string: str):
        self.hsm_connection_string = hsm_connection_string
        self.hsm_connection = None
        self.keys = {}
        self.operation_queue = asyncio.Queue()
        
        # HSM ì—°ê²°
        self._connect_hsm()
        
        logger.info("HSM manager initialized")
    
    def _connect_hsm(self):
        """HSM ì—°ê²°"""
        try:
            # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” HSM SDK ì‚¬ìš©
            # ì˜ˆ: AWS CloudHSM, Azure Key Vault HSM, Google Cloud HSM
            logger.info(f"Connecting to HSM: {self.hsm_connection_string}")
            
            # ì—°ê²° ìƒíƒœ ì‹œë®¬ë ˆì´ì…˜
            self.hsm_connection = True
            
        except Exception as e:
            logger.error(f"HSM connection failed: {e}")
            raise
    
    async def generate_key(self, key_type: str, key_size: int, 
                          expires_at: Optional[datetime] = None) -> HSMKey:
        """í‚¤ ìƒì„±"""
        try:
            key_id = f"{key_type}_{key_size}_{int(datetime.now().timestamp())}"
            
            # HSMì„ í†µí•œ í‚¤ ìƒì„±
            # self.hsm_connection.generate_key(key_id, key_type, key_size)
            
            key = HSMKey(
                key_id=key_id,
                key_type=key_type,
                key_size=key_size,
                created_at=datetime.now(),
                expires_at=expires_at,
                is_active=True
            )
            
            self.keys[key_id] = key
            
            logger.info(f"Generated HSM key: {key_id}")
            return key
            
        except Exception as e:
            logger.error(f"Key generation failed: {e}")
            raise
    
    async def encrypt_data(self, request: EncryptionRequest) -> EncryptionResult:
        """ë°ì´í„° ì•”í˜¸í™”"""
        try:
            # í‚¤ ìœ íš¨ì„± í™•ì¸
            if request.key_id not in self.keys:
                raise ValueError(f"Key not found: {request.key_id}")
            
            key = self.keys[request.key_id]
            if not key.is_active:
                raise ValueError(f"Key is not active: {request.key_id}")
            
            # HSMì„ í†µí•œ ì•”í˜¸í™”
            # encrypted_data, iv = self.hsm_connection.encrypt(
            #     request.key_id, request.data, request.algorithm, request.mode
            # )
            
            # ì‹œë®¬ë ˆì´ì…˜ ì•”í˜¸í™”
            iv = os.urandom(16)
            encrypted_data = self._simulate_encryption(request.data, iv)
            
            # í‚¤ ì‚¬ìš© íšŸìˆ˜ ì¦ê°€
            key.usage_count += 1
            
            result = EncryptionResult(
                request_id=request.request_id,
                encrypted_data=encrypted_data,
                iv=iv,
                key_id=request.key_id,
                algorithm=request.algorithm,
                timestamp=datetime.now()
            )
            
            logger.info(f"Data encrypted with HSM key: {request.key_id}")
            return result
            
        except Exception as e:
            logger.error(f"Data encryption failed: {e}")
            raise
    
    async def decrypt_data(self, key_id: str, encrypted_data: bytes, 
                          iv: bytes, algorithm: str) -> bytes:
        """ë°ì´í„° ë³µí˜¸í™”"""
        try:
            # í‚¤ ìœ íš¨ì„± í™•ì¸
            if key_id not in self.keys:
                raise ValueError(f"Key not found: {key_id}")
            
            key = self.keys[key_id]
            if not key.is_active:
                raise ValueError(f"Key is not active: {key_id}")
            
            # HSMì„ í†µí•œ ë³µí˜¸í™”
            # decrypted_data = self.hsm_connection.decrypt(
            #     key_id, encrypted_data, algorithm, iv
            # )
            
            # ì‹œë®¬ë ˆì´ì…˜ ë³µí˜¸í™”
            decrypted_data = self._simulate_decryption(encrypted_data, iv)
            
            # í‚¤ ì‚¬ìš© íšŸìˆ˜ ì¦ê°€
            key.usage_count += 1
            
            logger.info(f"Data decrypted with HSM key: {key_id}")
            return decrypted_data
            
        except Exception as e:
            logger.error(f"Data decryption failed: {e}")
            raise
    
    async def sign_data(self, request: SigningRequest) -> SigningResult:
        """ë°ì´í„° ì„œëª…"""
        try:
            # í‚¤ ìœ íš¨ì„± í™•ì¸
            if request.key_id not in self.keys:
                raise ValueError(f"Key not found: {request.key_id}")
            
            key = self.keys[request.key_id]
            if not key.is_active:
                raise ValueError(f"Key is not active: {request.key_id}")
            
            # HSMì„ í†µí•œ ì„œëª…
            # signature = self.hsm_connection.sign(
            #     request.key_id, request.data, request.algorithm
            # )
            
            # ì‹œë®¬ë ˆì´ì…˜ ì„œëª…
            signature = self._simulate_signing(request.data)
            
            # í‚¤ ì‚¬ìš© íšŸìˆ˜ ì¦ê°€
            key.usage_count += 1
            
            result = SigningResult(
                request_id=request.request_id,
                signature=signature,
                key_id=request.key_id,
                algorithm=request.algorithm,
                timestamp=datetime.now()
            )
            
            logger.info(f"Data signed with HSM key: {request.key_id}")
            return result
            
        except Exception as e:
            logger.error(f"Data signing failed: {e}")
            raise
    
    async def verify_signature(self, key_id: str, data: bytes, 
                             signature: bytes, algorithm: str) -> bool:
        """ì„œëª… ê²€ì¦"""
        try:
            # í‚¤ ìœ íš¨ì„± í™•ì¸
            if key_id not in self.keys:
                raise ValueError(f"Key not found: {key_id}")
            
            key = self.keys[key_id]
            if not key.is_active:
                raise ValueError(f"Key is not active: {key_id}")
            
            # HSMì„ í†µí•œ ì„œëª… ê²€ì¦
            # is_valid = self.hsm_connection.verify_signature(
            #     key_id, data, signature, algorithm
            # )
            
            # ì‹œë®¬ë ˆì´ì…˜ ì„œëª… ê²€ì¦
            is_valid = self._simulate_signature_verification(data, signature)
            
            logger.info(f"Signature verification result: {is_valid}")
            return is_valid
            
        except Exception as e:
            logger.error(f"Signature verification failed: {e}")
            return False
    
    def _simulate_encryption(self, data: bytes, iv: bytes) -> bytes:
        """ì•”í˜¸í™” ì‹œë®¬ë ˆì´ì…˜"""
        try:
            # ê°„ë‹¨í•œ XOR ì•”í˜¸í™” ì‹œë®¬ë ˆì´ì…˜
            encrypted = bytearray()
            for i, byte in enumerate(data):
                encrypted.append(byte ^ iv[i % len(iv)])
            return bytes(encrypted)
            
        except Exception as e:
            logger.error(f"Encryption simulation failed: {e}")
            return data
    
    def _simulate_decryption(self, encrypted_data: bytes, iv: bytes) -> bytes:
        """ë³µí˜¸í™” ì‹œë®¬ë ˆì´ì…˜"""
        try:
            # XOR ë³µí˜¸í™” ì‹œë®¬ë ˆì´ì…˜
            decrypted = bytearray()
            for i, byte in enumerate(encrypted_data):
                decrypted.append(byte ^ iv[i % len(iv)])
            return bytes(decrypted)
            
        except Exception as e:
            logger.error(f"Decryption simulation failed: {e}")
            return encrypted_data
    
    def _simulate_signing(self, data: bytes) -> bytes:
        """ì„œëª… ì‹œë®¬ë ˆì´ì…˜"""
        try:
            # ê°„ë‹¨í•œ í•´ì‹œ ê¸°ë°˜ ì„œëª… ì‹œë®¬ë ˆì´ì…˜
            signature = hashlib.sha256(data).digest()
            return signature
            
        except Exception as e:
            logger.error(f"Signing simulation failed: {e}")
            return b''
    
    def _simulate_signature_verification(self, data: bytes, signature: bytes) -> bool:
        """ì„œëª… ê²€ì¦ ì‹œë®¬ë ˆì´ì…˜"""
        try:
            # í•´ì‹œ ê¸°ë°˜ ì„œëª… ê²€ì¦ ì‹œë®¬ë ˆì´ì…˜
            expected_signature = hashlib.sha256(data).digest()
            return signature == expected_signature
            
        except Exception as e:
            logger.error(f"Signature verification simulation failed: {e}")
            return False
    
    def get_key_info(self, key_id: str) -> Optional[HSMKey]:
        """í‚¤ ì •ë³´ ì¡°íšŒ"""
        try:
            return self.keys.get(key_id)
            
        except Exception as e:
            logger.error(f"Key info retrieval failed: {e}")
            return None
    
    def deactivate_key(self, key_id: str) -> bool:
        """í‚¤ ë¹„í™œì„±í™”"""
        try:
            if key_id in self.keys:
                self.keys[key_id].is_active = False
                logger.info(f"Key deactivated: {key_id}")
                return True
            return False
            
        except Exception as e:
            logger.error(f"Key deactivation failed: {e}")
            return False
    
    def get_key_statistics(self) -> Dict[str, Any]:
        """í‚¤ í†µê³„ ì¡°íšŒ"""
        try:
            total_keys = len(self.keys)
            active_keys = sum(1 for key in self.keys.values() if key.is_active)
            total_usage = sum(key.usage_count for key in self.keys.values())
            
            return {
                'total_keys': total_keys,
                'active_keys': active_keys,
                'inactive_keys': total_keys - active_keys,
                'total_usage_count': total_usage,
                'average_usage_per_key': total_usage / total_keys if total_keys > 0 else 0
            }
            
        except Exception as e:
            logger.error(f"Key statistics calculation failed: {e}")
            return {}
```

## ğŸ¯ **ë‹¤ìŒ ë‹¨ê³„**

### ğŸ“‹ **ì™„ë£Œëœ ì‘ì—…**
- âœ… ì œë¡œ íŠ¸ëŸ¬ìŠ¤íŠ¸ ì‹œìŠ¤í…œ ì„¤ê³„
- âœ… HSM ê´€ë¦¬ ì‹œìŠ¤í…œ
- âœ… ë‹¤ì¤‘ ì¸ì¦ ì‹œìŠ¤í…œ
- âœ… ì ‘ê·¼ ì œì–´ ì •ì±…

### ğŸ”„ **ì§„í–‰ ì¤‘ì¸ ì‘ì—…**
- ğŸ”„ ìƒì²´ì¸ì‹ ì¸ì¦ ì‹œìŠ¤í…œ
- ğŸ”„ ë„¤íŠ¸ì›Œí¬ ë³´ì•ˆ ì‹œìŠ¤í…œ
- ğŸ”„ ì¹¨ì… íƒì§€ ì‹œìŠ¤í…œ

### â³ **ë‹¤ìŒ ë‹¨ê³„**
1. **Phase 4.4 ì½”ë¡œì¼€ì´ì…˜** ë¬¸ì„œ ìƒì„±
2. **Phase 5 ê³ ê¸‰ ê¸°ëŠ¥** ë¬¸ì„œ ìƒì„±
3. **Phase 6 ë³´ì•ˆ ê°•í™”** ë¬¸ì„œ ìƒì„±

---

**ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸**: 2024-01-31
**ë‹¤ìŒ ì—…ë°ì´íŠ¸**: 2024-02-01 (Phase 4.4 ì½”ë¡œì¼€ì´ì…˜)
**ë³´ì•ˆ ëª©í‘œ**: 100% ì œë¡œ íŠ¸ëŸ¬ìŠ¤íŠ¸ ì¤€ìˆ˜, > 99.9% ìƒì²´ì¸ì‹ ì •í™•ë„, > 95% ì¹¨ì… íƒì§€ìœ¨
**ë³´ì•ˆ ì„±ê³¼**: HSM í‚¤ ê´€ë¦¬, ë‹¤ì¤‘ ì¸ì¦, ì ‘ê·¼ ì œì–´, í–‰ë™ ë¶„ì„ 