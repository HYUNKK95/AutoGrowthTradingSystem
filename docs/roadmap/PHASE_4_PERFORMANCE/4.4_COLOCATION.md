# ğŸ¢ Phase 4.4: ì½”ë¡œì¼€ì´ì…˜ ë° ë„¤íŠ¸ì›Œí¬ ìµœì í™”

## ğŸ“‹ **ê°œìš”**

### ğŸ¯ **ëª©í‘œ**
- **ê±°ë˜ì†Œ ì½”ë¡œì¼€ì´ì…˜**: ê±°ë˜ì†Œ ì„œë²„ì™€ ë¬¼ë¦¬ì ìœ¼ë¡œ ê°€ê¹Œìš´ ìœ„ì¹˜ì— ë°°í¬
- **ë„¤íŠ¸ì›Œí¬ ìµœì í™”**: ì´ˆì €ì§€ì—° ë„¤íŠ¸ì›Œí¬ ì—°ê²° ë° ë¼ìš°íŒ… ìµœì í™”
- **ë°ì´í„° ì„¼í„° ì„ íƒ**: ìµœì ì˜ ë°ì´í„° ì„¼í„° ë° ë„¤íŠ¸ì›Œí¬ ì¸í”„ë¼ ì„ íƒ
- **ì—°ê²°ì„± ìµœì í™”**: ë‹¤ì¤‘ ê²½ë¡œ, ë°±ì—… ì—°ê²°, ì¥ì•  ë³µêµ¬ ì‹œìŠ¤í…œ
- **ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§**: ì‹¤ì‹œê°„ ë„¤íŠ¸ì›Œí¬ ì„±ëŠ¥ ë° ì§€ì—° ì‹œê°„ ëª¨ë‹ˆí„°ë§

### ğŸ“Š **ì„±ëŠ¥ ëª©í‘œ**
- **ë„¤íŠ¸ì›Œí¬ ì§€ì—°**: < 1ms (ê±°ë˜ì†Œê¹Œì§€)
- **íŒ¨í‚· ì†ì‹¤ë¥ **: < 0.001% (0.001% ë¯¸ë§Œ)
- **ëŒ€ì—­í­**: > 10Gbps (10ê¸°ê°€ë¹„íŠ¸ ì´ìƒ)
- **ê°€ìš©ì„±**: > 99.99% (99.99% ì´ìƒ)
- **ì¥ì•  ë³µêµ¬ ì‹œê°„**: < 30ì´ˆ (30ì´ˆ ë¯¸ë§Œ)

## ğŸ—ï¸ **ì½”ë¡œì¼€ì´ì…˜ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜**

### ğŸ“ **ì½”ë¡œì¼€ì´ì…˜ ì‹œìŠ¤í…œ êµ¬ì¡°**
```
colocation-system/
â”œâ”€â”€ exchange-connectivity/           # ê±°ë˜ì†Œ ì—°ê²°
â”‚   â”œâ”€â”€ binance-colocation/          # ë°”ì´ë‚¸ìŠ¤ ì½”ë¡œì¼€ì´ì…˜
â”‚   â”œâ”€â”€ coinbase-colocation/         # ì½”ì¸ë² ì´ìŠ¤ ì½”ë¡œì¼€ì´ì…˜
â”‚   â”œâ”€â”€ kraken-colocation/           # í¬ë¼ì¼„ ì½”ë¡œì¼€ì´ì…˜
â”‚   â””â”€â”€ multi-exchange/              # ë‹¤ì¤‘ ê±°ë˜ì†Œ
â”œâ”€â”€ network-optimization/            # ë„¤íŠ¸ì›Œí¬ ìµœì í™”
â”‚   â”œâ”€â”€ low-latency-routing/         # ì €ì§€ì—° ë¼ìš°íŒ…
â”‚   â”œâ”€â”€ bandwidth-management/        # ëŒ€ì—­í­ ê´€ë¦¬
â”‚   â”œâ”€â”€ packet-optimization/         # íŒ¨í‚· ìµœì í™”
â”‚   â””â”€â”€ congestion-control/          # í˜¼ì¡ ì œì–´
â”œâ”€â”€ data-center-selection/           # ë°ì´í„° ì„¼í„° ì„ íƒ
â”‚   â”œâ”€â”€ location-analysis/           # ìœ„ì¹˜ ë¶„ì„
â”‚   â”œâ”€â”€ infrastructure-assessment/   # ì¸í”„ë¼ í‰ê°€
â”‚   â”œâ”€â”€ cost-optimization/           # ë¹„ìš© ìµœì í™”
â”‚   â””â”€â”€ performance-benchmarking/    # ì„±ëŠ¥ ë²¤ì¹˜ë§ˆí‚¹
â”œâ”€â”€ connectivity-management/         # ì—°ê²°ì„± ê´€ë¦¬
â”‚   â”œâ”€â”€ primary-connections/         # ì£¼ ì—°ê²°
â”‚   â”œâ”€â”€ backup-connections/          # ë°±ì—… ì—°ê²°
â”‚   â”œâ”€â”€ failover-management/         # ì¥ì•  ë³µêµ¬ ê´€ë¦¬
â”‚   â””â”€â”€ load-balancing/              # ë¡œë“œ ë°¸ëŸ°ì‹±
â””â”€â”€ performance-monitoring/          # ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§
    â”œâ”€â”€ latency-monitoring/          # ì§€ì—° ì‹œê°„ ëª¨ë‹ˆí„°ë§
    â”œâ”€â”€ bandwidth-monitoring/        # ëŒ€ì—­í­ ëª¨ë‹ˆí„°ë§
    â”œâ”€â”€ packet-loss-monitoring/      # íŒ¨í‚· ì†ì‹¤ ëª¨ë‹ˆí„°ë§
    â””â”€â”€ availability-monitoring/     # ê°€ìš©ì„± ëª¨ë‹ˆí„°ë§
```

## ğŸ”§ **ê±°ë˜ì†Œ ì½”ë¡œì¼€ì´ì…˜ ì‹œìŠ¤í…œ**

### ğŸ“¦ **ë‹¤ì¤‘ ê±°ë˜ì†Œ ì½”ë¡œì¼€ì´ì…˜**

```python
# colocation-system/exchange-connectivity/multi_exchange_colocation.py
import asyncio
import time
import socket
import struct
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass
from datetime import datetime, timedelta
import logging
import numpy as np
import aiohttp
import ssl

logger = logging.getLogger(__name__)

@dataclass
class ExchangeInfo:
    """ê±°ë˜ì†Œ ì •ë³´"""
    exchange_id: str
    name: str
    colocation_location: str
    primary_ip: str
    backup_ip: str
    api_endpoint: str
    websocket_endpoint: str
    ping_interval: int
    connection_timeout: int
    max_retries: int

@dataclass
class ConnectionMetrics:
    """ì—°ê²° ë©”íŠ¸ë¦­"""
    exchange_id: str
    latency_ms: float
    packet_loss_rate: float
    bandwidth_mbps: float
    connection_status: str
    last_heartbeat: datetime
    uptime_percentage: float

@dataclass
class ColocationConfig:
    """ì½”ë¡œì¼€ì´ì…˜ ì„¤ì •"""
    exchange_id: str
    data_center: str
    rack_location: str
    network_provider: str
    bandwidth_limit: int
    priority: int
    failover_enabled: bool

class MultiExchangeColocation:
    """ë‹¤ì¤‘ ê±°ë˜ì†Œ ì½”ë¡œì¼€ì´ì…˜"""
    
    def __init__(self):
        self.exchanges = {}
        self.connections = {}
        self.metrics = {}
        self.colocation_configs = {}
        
        # ê±°ë˜ì†Œ ì •ë³´ ì´ˆê¸°í™”
        self._initialize_exchanges()
        
        # ì½”ë¡œì¼€ì´ì…˜ ì„¤ì • ì´ˆê¸°í™”
        self._initialize_colocation_configs()
        
        # ì—°ê²° ê´€ë¦¬ì
        self.connection_manager = ConnectionManager()
        
        # ì„±ëŠ¥ ëª¨ë‹ˆí„°
        self.performance_monitor = PerformanceMonitor()
        
        # ì¥ì•  ë³µêµ¬ ê´€ë¦¬ì
        self.failover_manager = FailoverManager()
        
        logger.info("Multi-exchange colocation system initialized")
    
    def _initialize_exchanges(self):
        """ê±°ë˜ì†Œ ì •ë³´ ì´ˆê¸°í™”"""
        self.exchanges = {
            'binance': ExchangeInfo(
                exchange_id='binance',
                name='Binance',
                colocation_location='Singapore',
                primary_ip='52.84.0.0',
                backup_ip='52.84.0.1',
                api_endpoint='https://api.binance.com',
                websocket_endpoint='wss://stream.binance.com:9443',
                ping_interval=30,
                connection_timeout=10,
                max_retries=3
            ),
            'coinbase': ExchangeInfo(
                exchange_id='coinbase',
                name='Coinbase Pro',
                colocation_location='New York',
                primary_ip='52.84.0.2',
                backup_ip='52.84.0.3',
                api_endpoint='https://api.pro.coinbase.com',
                websocket_endpoint='wss://ws-feed.pro.coinbase.com',
                ping_interval=30,
                connection_timeout=10,
                max_retries=3
            ),
            'kraken': ExchangeInfo(
                exchange_id='kraken',
                name='Kraken',
                colocation_location='London',
                primary_ip='52.84.0.4',
                backup_ip='52.84.0.5',
                api_endpoint='https://api.kraken.com',
                websocket_endpoint='wss://ws.kraken.com',
                ping_interval=30,
                connection_timeout=10,
                max_retries=3
            )
        }
    
    def _initialize_colocation_configs(self):
        """ì½”ë¡œì¼€ì´ì…˜ ì„¤ì • ì´ˆê¸°í™”"""
        self.colocation_configs = {
            'binance': ColocationConfig(
                exchange_id='binance',
                data_center='Equinix SG1',
                rack_location='Rack A-01',
                network_provider='Equinix',
                bandwidth_limit=10000,  # 10Gbps
                priority=1,
                failover_enabled=True
            ),
            'coinbase': ColocationConfig(
                exchange_id='coinbase',
                data_center='Equinix NY4',
                rack_location='Rack B-02',
                network_provider='Equinix',
                bandwidth_limit=10000,  # 10Gbps
                priority=2,
                failover_enabled=True
            ),
            'kraken': ColocationConfig(
                exchange_id='kraken',
                data_center='Equinix LD4',
                rack_location='Rack C-03',
                network_provider='Equinix',
                bandwidth_limit=10000,  # 10Gbps
                priority=3,
                failover_enabled=True
            )
        }
    
    async def start_colocation_services(self):
        """ì½”ë¡œì¼€ì´ì…˜ ì„œë¹„ìŠ¤ ì‹œì‘"""
        try:
            logger.info("Starting colocation services")
            
            # ëª¨ë“  ê±°ë˜ì†Œì— ëŒ€í•œ ì—°ê²° ì„¤ì •
            for exchange_id, exchange_info in self.exchanges.items():
                await self._setup_exchange_connection(exchange_id, exchange_info)
            
            # ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì‹œì‘
            await self.performance_monitor.start_monitoring()
            
            # ì¥ì•  ë³µêµ¬ ëª¨ë‹ˆí„°ë§ ì‹œì‘
            await self.failover_manager.start_monitoring()
            
            logger.info("Colocation services started successfully")
            
        except Exception as e:
            logger.error(f"Failed to start colocation services: {e}")
            raise
    
    async def _setup_exchange_connection(self, exchange_id: str, exchange_info: ExchangeInfo):
        """ê±°ë˜ì†Œ ì—°ê²° ì„¤ì •"""
        try:
            # ì£¼ ì—°ê²° ì„¤ì •
            primary_connection = await self.connection_manager.create_connection(
                exchange_id, exchange_info, 'primary'
            )
            
            # ë°±ì—… ì—°ê²° ì„¤ì •
            backup_connection = await self.connection_manager.create_connection(
                exchange_id, exchange_info, 'backup'
            )
            
            # ì—°ê²° ì •ë³´ ì €ì¥
            self.connections[exchange_id] = {
                'primary': primary_connection,
                'backup': backup_connection,
                'active': 'primary'
            }
            
            logger.info(f"Exchange connection setup completed for {exchange_id}")
            
        except Exception as e:
            logger.error(f"Failed to setup connection for {exchange_id}: {e}")
    
    async def send_order(self, exchange_id: str, order_data: Dict[str, Any]) -> Dict[str, Any]:
        """ì£¼ë¬¸ ì „ì†¡"""
        try:
            # í™œì„± ì—°ê²° í™•ì¸
            active_connection = self._get_active_connection(exchange_id)
            if not active_connection:
                raise Exception(f"No active connection for {exchange_id}")
            
            # ì£¼ë¬¸ ì „ì†¡
            start_time = time.perf_counter()
            response = await active_connection.send_order(order_data)
            end_time = time.perf_counter()
            
            # ì§€ì—° ì‹œê°„ ê¸°ë¡
            latency_ms = (end_time - start_time) * 1000
            await self.performance_monitor.record_latency(exchange_id, latency_ms)
            
            return response
            
        except Exception as e:
            logger.error(f"Order sending failed for {exchange_id}: {e}")
            
            # ì¥ì•  ë³µêµ¬ ì‹œë„
            await self._handle_connection_failure(exchange_id)
            raise
    
    async def get_market_data(self, exchange_id: str, symbol: str) -> Dict[str, Any]:
        """ì‹œì¥ ë°ì´í„° ì¡°íšŒ"""
        try:
            # í™œì„± ì—°ê²° í™•ì¸
            active_connection = self._get_active_connection(exchange_id)
            if not active_connection:
                raise Exception(f"No active connection for {exchange_id}")
            
            # ì‹œì¥ ë°ì´í„° ì¡°íšŒ
            start_time = time.perf_counter()
            market_data = await active_connection.get_market_data(symbol)
            end_time = time.perf_counter()
            
            # ì§€ì—° ì‹œê°„ ê¸°ë¡
            latency_ms = (end_time - start_time) * 1000
            await self.performance_monitor.record_latency(exchange_id, latency_ms)
            
            return market_data
            
        except Exception as e:
            logger.error(f"Market data retrieval failed for {exchange_id}: {e}")
            
            # ì¥ì•  ë³µêµ¬ ì‹œë„
            await self._handle_connection_failure(exchange_id)
            raise
    
    def _get_active_connection(self, exchange_id: str):
        """í™œì„± ì—°ê²° ì¡°íšŒ"""
        try:
            if exchange_id not in self.connections:
                return None
            
            connection_info = self.connections[exchange_id]
            active_type = connection_info['active']
            
            return connection_info[active_type]
            
        except Exception as e:
            logger.error(f"Failed to get active connection for {exchange_id}: {e}")
            return None
    
    async def _handle_connection_failure(self, exchange_id: str):
        """ì—°ê²° ì¥ì•  ì²˜ë¦¬"""
        try:
            # ì¥ì•  ë³µêµ¬ ê´€ë¦¬ìì— ì¥ì•  ì•Œë¦¼
            await self.failover_manager.handle_failure(exchange_id)
            
            # ë°±ì—… ì—°ê²°ë¡œ ì „í™˜
            await self._switch_to_backup_connection(exchange_id)
            
        except Exception as e:
            logger.error(f"Connection failure handling failed for {exchange_id}: {e}")
    
    async def _switch_to_backup_connection(self, exchange_id: str):
        """ë°±ì—… ì—°ê²°ë¡œ ì „í™˜"""
        try:
            if exchange_id not in self.connections:
                return
            
            connection_info = self.connections[exchange_id]
            
            # ë°±ì—… ì—°ê²°ì´ ì‚¬ìš© ê°€ëŠ¥í•œì§€ í™•ì¸
            if connection_info['backup'].is_healthy():
                connection_info['active'] = 'backup'
                logger.info(f"Switched to backup connection for {exchange_id}")
            else:
                logger.error(f"Backup connection not available for {exchange_id}")
                
        except Exception as e:
            logger.error(f"Connection switch failed for {exchange_id}: {e}")
    
    async def get_connection_metrics(self, exchange_id: str) -> Optional[ConnectionMetrics]:
        """ì—°ê²° ë©”íŠ¸ë¦­ ì¡°íšŒ"""
        try:
            return await self.performance_monitor.get_metrics(exchange_id)
            
        except Exception as e:
            logger.error(f"Failed to get connection metrics for {exchange_id}: {e}")
            return None
    
    async def get_all_metrics(self) -> Dict[str, ConnectionMetrics]:
        """ëª¨ë“  ì—°ê²° ë©”íŠ¸ë¦­ ì¡°íšŒ"""
        try:
            all_metrics = {}
            
            for exchange_id in self.exchanges.keys():
                metrics = await self.get_connection_metrics(exchange_id)
                if metrics:
                    all_metrics[exchange_id] = metrics
            
            return all_metrics
            
        except Exception as e:
            logger.error(f"Failed to get all metrics: {e}")
            return {}

class ConnectionManager:
    """ì—°ê²° ê´€ë¦¬ì"""
    
    def __init__(self):
        self.connections = {}
        self.connection_pool = {}
    
    async def create_connection(self, exchange_id: str, exchange_info: ExchangeInfo, 
                              connection_type: str) -> 'ExchangeConnection':
        """ì—°ê²° ìƒì„±"""
        try:
            connection = ExchangeConnection(
                exchange_id, exchange_info, connection_type
            )
            
            # ì—°ê²° ì´ˆê¸°í™”
            await connection.initialize()
            
            # ì—°ê²° í’€ì— ì¶”ê°€
            key = f"{exchange_id}_{connection_type}"
            self.connections[key] = connection
            
            logger.info(f"Created {connection_type} connection for {exchange_id}")
            return connection
            
        except Exception as e:
            logger.error(f"Failed to create connection for {exchange_id}: {e}")
            raise
    
    def get_connection(self, exchange_id: str, connection_type: str):
        """ì—°ê²° ì¡°íšŒ"""
        try:
            key = f"{exchange_id}_{connection_type}"
            return self.connections.get(key)
            
        except Exception as e:
            logger.error(f"Failed to get connection: {e}")
            return None

class ExchangeConnection:
    """ê±°ë˜ì†Œ ì—°ê²°"""
    
    def __init__(self, exchange_id: str, exchange_info: ExchangeInfo, connection_type: str):
        self.exchange_id = exchange_id
        self.exchange_info = exchange_info
        self.connection_type = connection_type
        self.session = None
        self.websocket = None
        self.is_healthy = False
        self.last_heartbeat = None
        self.connection_start_time = None
    
    async def initialize(self):
        """ì—°ê²° ì´ˆê¸°í™”"""
        try:
            # HTTP ì„¸ì…˜ ìƒì„±
            connector = aiohttp.TCPConnector(
                limit=100,
                limit_per_host=20,
                ttl_dns_cache=300,
                use_dns_cache=True,
                ssl=False
            )
            
            timeout = aiohttp.ClientTimeout(total=self.exchange_info.connection_timeout)
            
            self.session = aiohttp.ClientSession(
                connector=connector,
                timeout=timeout,
                headers={
                    'User-Agent': 'TradingBot/1.0',
                    'Accept': 'application/json'
                }
            )
            
            # ì—°ê²° ìƒíƒœ í™•ì¸
            await self._test_connection()
            
            # ì—°ê²° ì‹œì‘ ì‹œê°„ ê¸°ë¡
            self.connection_start_time = datetime.now()
            
            logger.info(f"Initialized {self.connection_type} connection for {self.exchange_id}")
            
        except Exception as e:
            logger.error(f"Connection initialization failed for {self.exchange_id}: {e}")
            raise
    
    async def _test_connection(self):
        """ì—°ê²° í…ŒìŠ¤íŠ¸"""
        try:
            # ê°„ë‹¨í•œ API í˜¸ì¶œë¡œ ì—°ê²° í…ŒìŠ¤íŠ¸
            async with self.session.get(f"{self.exchange_info.api_endpoint}/api/v3/ping") as response:
                if response.status == 200:
                    self.is_healthy = True
                    self.last_heartbeat = datetime.now()
                    logger.info(f"Connection test successful for {self.exchange_id}")
                else:
                    self.is_healthy = False
                    logger.warning(f"Connection test failed for {self.exchange_id}")
                    
        except Exception as e:
            self.is_healthy = False
            logger.error(f"Connection test failed for {self.exchange_id}: {e}")
    
    async def send_order(self, order_data: Dict[str, Any]) -> Dict[str, Any]:
        """ì£¼ë¬¸ ì „ì†¡"""
        try:
            if not self.is_healthy:
                raise Exception("Connection is not healthy")
            
            # ì£¼ë¬¸ API ì—”ë“œí¬ì¸íŠ¸
            url = f"{self.exchange_info.api_endpoint}/api/v3/order"
            
            # ì£¼ë¬¸ ì „ì†¡
            async with self.session.post(url, json=order_data) as response:
                if response.status == 200:
                    result = await response.json()
                    return result
                else:
                    error_text = await response.text()
                    raise Exception(f"Order failed: {error_text}")
                    
        except Exception as e:
            logger.error(f"Order sending failed: {e}")
            self.is_healthy = False
            raise
    
    async def get_market_data(self, symbol: str) -> Dict[str, Any]:
        """ì‹œì¥ ë°ì´í„° ì¡°íšŒ"""
        try:
            if not self.is_healthy:
                raise Exception("Connection is not healthy")
            
            # ì‹œì¥ ë°ì´í„° API ì—”ë“œí¬ì¸íŠ¸
            url = f"{self.exchange_info.api_endpoint}/api/v3/ticker/24hr"
            params = {'symbol': symbol}
            
            # ì‹œì¥ ë°ì´í„° ì¡°íšŒ
            async with self.session.get(url, params=params) as response:
                if response.status == 200:
                    result = await response.json()
                    return result
                else:
                    error_text = await response.text()
                    raise Exception(f"Market data retrieval failed: {error_text}")
                    
        except Exception as e:
            logger.error(f"Market data retrieval failed: {e}")
            self.is_healthy = False
            raise
    
    def is_healthy(self) -> bool:
        """ì—°ê²° ìƒíƒœ í™•ì¸"""
        return self.is_healthy
    
    async def close(self):
        """ì—°ê²° ì¢…ë£Œ"""
        try:
            if self.session:
                await self.session.close()
            
            if self.websocket:
                await self.websocket.close()
                
            logger.info(f"Closed connection for {self.exchange_id}")
            
        except Exception as e:
            logger.error(f"Connection close failed: {e}")

class PerformanceMonitor:
    """ì„±ëŠ¥ ëª¨ë‹ˆí„°"""
    
    def __init__(self):
        self.metrics = {}
        self.monitoring_task = None
    
    async def start_monitoring(self):
        """ëª¨ë‹ˆí„°ë§ ì‹œì‘"""
        try:
            self.monitoring_task = asyncio.create_task(self._monitoring_loop())
            logger.info("Performance monitoring started")
            
        except Exception as e:
            logger.error(f"Performance monitoring start failed: {e}")
    
    async def _monitoring_loop(self):
        """ëª¨ë‹ˆí„°ë§ ë£¨í”„"""
        try:
            while True:
                # ëª¨ë“  ì—°ê²°ì˜ ì„±ëŠ¥ ì¸¡ì •
                for exchange_id in ['binance', 'coinbase', 'kraken']:
                    await self._measure_performance(exchange_id)
                
                # 30ì´ˆë§ˆë‹¤ ì¸¡ì •
                await asyncio.sleep(30)
                
        except Exception as e:
            logger.error(f"Monitoring loop failed: {e}")
    
    async def _measure_performance(self, exchange_id: str):
        """ì„±ëŠ¥ ì¸¡ì •"""
        try:
            # ì§€ì—° ì‹œê°„ ì¸¡ì •
            latency = await self._measure_latency(exchange_id)
            
            # íŒ¨í‚· ì†ì‹¤ë¥  ì¸¡ì •
            packet_loss = await self._measure_packet_loss(exchange_id)
            
            # ëŒ€ì—­í­ ì¸¡ì •
            bandwidth = await self._measure_bandwidth(exchange_id)
            
            # ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸
            self.metrics[exchange_id] = ConnectionMetrics(
                exchange_id=exchange_id,
                latency_ms=latency,
                packet_loss_rate=packet_loss,
                bandwidth_mbps=bandwidth,
                connection_status='healthy' if latency < 10 else 'degraded',
                last_heartbeat=datetime.now(),
                uptime_percentage=99.9  # ì‹œë®¬ë ˆì´ì…˜
            )
            
        except Exception as e:
            logger.error(f"Performance measurement failed for {exchange_id}: {e}")
    
    async def _measure_latency(self, exchange_id: str) -> float:
        """ì§€ì—° ì‹œê°„ ì¸¡ì •"""
        try:
            # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ICMP ping ë˜ëŠ” TCP ping ì‚¬ìš©
            # ì—¬ê¸°ì„œëŠ” ì‹œë®¬ë ˆì´ì…˜
            base_latency = {
                'binance': 0.5,    # 0.5ms
                'coinbase': 1.2,   # 1.2ms
                'kraken': 2.1      # 2.1ms
            }
            
            # ëœë¤ ë³€ë™ ì¶”ê°€
            variation = np.random.normal(0, 0.1)
            latency = base_latency.get(exchange_id, 1.0) + variation
            
            return max(latency, 0.1)  # ìµœì†Œ 0.1ms
            
        except Exception as e:
            logger.error(f"Latency measurement failed: {e}")
            return 999.0  # ì¸¡ì • ì‹¤íŒ¨ ì‹œ ë†’ì€ ê°’
    
    async def _measure_packet_loss(self, exchange_id: str) -> float:
        """íŒ¨í‚· ì†ì‹¤ë¥  ì¸¡ì •"""
        try:
            # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” íŒ¨í‚· ì†ì‹¤ë¥  ì¸¡ì •
            # ì—¬ê¸°ì„œëŠ” ì‹œë®¬ë ˆì´ì…˜
            base_loss_rate = 0.0001  # 0.01%
            
            # ëœë¤ ë³€ë™ ì¶”ê°€
            variation = np.random.normal(0, 0.00005)
            loss_rate = base_loss_rate + variation
            
            return max(loss_rate, 0.0)  # ìµœì†Œ 0%
            
        except Exception as e:
            logger.error(f"Packet loss measurement failed: {e}")
            return 1.0  # ì¸¡ì • ì‹¤íŒ¨ ì‹œ 100%
    
    async def _measure_bandwidth(self, exchange_id: str) -> float:
        """ëŒ€ì—­í­ ì¸¡ì •"""
        try:
            # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ëŒ€ì—­í­ ì¸¡ì •
            # ì—¬ê¸°ì„œëŠ” ì‹œë®¬ë ˆì´ì…˜
            base_bandwidth = 9500  # 9.5Gbps
            
            # ëœë¤ ë³€ë™ ì¶”ê°€
            variation = np.random.normal(0, 100)
            bandwidth = base_bandwidth + variation
            
            return max(bandwidth, 1000)  # ìµœì†Œ 1Gbps
            
        except Exception as e:
            logger.error(f"Bandwidth measurement failed: {e}")
            return 1000  # ì¸¡ì • ì‹¤íŒ¨ ì‹œ 1Gbps
    
    async def record_latency(self, exchange_id: str, latency_ms: float):
        """ì§€ì—° ì‹œê°„ ê¸°ë¡"""
        try:
            if exchange_id not in self.metrics:
                self.metrics[exchange_id] = ConnectionMetrics(
                    exchange_id=exchange_id,
                    latency_ms=latency_ms,
                    packet_loss_rate=0.0,
                    bandwidth_mbps=10000.0,
                    connection_status='healthy',
                    last_heartbeat=datetime.now(),
                    uptime_percentage=99.9
                )
            else:
                # ì´ë™ í‰ê· ìœ¼ë¡œ ì§€ì—° ì‹œê°„ ì—…ë°ì´íŠ¸
                current_metrics = self.metrics[exchange_id]
                alpha = 0.1  # í‰í™œí™” ê³„ìˆ˜
                new_latency = alpha * latency_ms + (1 - alpha) * current_metrics.latency_ms
                
                self.metrics[exchange_id] = ConnectionMetrics(
                    exchange_id=exchange_id,
                    latency_ms=new_latency,
                    packet_loss_rate=current_metrics.packet_loss_rate,
                    bandwidth_mbps=current_metrics.bandwidth_mbps,
                    connection_status='healthy' if new_latency < 10 else 'degraded',
                    last_heartbeat=datetime.now(),
                    uptime_percentage=current_metrics.uptime_percentage
                )
                
        except Exception as e:
            logger.error(f"Latency recording failed: {e}")
    
    async def get_metrics(self, exchange_id: str) -> Optional[ConnectionMetrics]:
        """ë©”íŠ¸ë¦­ ì¡°íšŒ"""
        try:
            return self.metrics.get(exchange_id)
            
        except Exception as e:
            logger.error(f"Metrics retrieval failed: {e}")
            return None

class FailoverManager:
    """ì¥ì•  ë³µêµ¬ ê´€ë¦¬ì"""
    
    def __init__(self):
        self.failures = {}
        self.failover_history = []
    
    async def start_monitoring(self):
        """ì¥ì•  ë³µêµ¬ ëª¨ë‹ˆí„°ë§ ì‹œì‘"""
        try:
            logger.info("Failover monitoring started")
            
        except Exception as e:
            logger.error(f"Failover monitoring start failed: {e}")
    
    async def handle_failure(self, exchange_id: str):
        """ì¥ì•  ì²˜ë¦¬"""
        try:
            # ì¥ì•  ê¸°ë¡
            failure_record = {
                'exchange_id': exchange_id,
                'timestamp': datetime.now(),
                'failure_type': 'connection_failure'
            }
            
            self.failures[exchange_id] = failure_record
            
            # ì¥ì•  ë³µêµ¬ ì´ë ¥ ê¸°ë¡
            self.failover_history.append(failure_record)
            
            logger.warning(f"Failure detected for {exchange_id}")
            
        except Exception as e:
            logger.error(f"Failure handling failed: {e}")
    
    def get_failure_history(self, exchange_id: str) -> List[Dict[str, Any]]:
        """ì¥ì•  ì´ë ¥ ì¡°íšŒ"""
        try:
            return [
                record for record in self.failover_history
                if record['exchange_id'] == exchange_id
            ]
            
        except Exception as e:
            logger.error(f"Failure history retrieval failed: {e}")
            return []
```

## ğŸ”§ **ë„¤íŠ¸ì›Œí¬ ìµœì í™” ì‹œìŠ¤í…œ**

### ğŸ“¦ **ì €ì§€ì—° ë„¤íŠ¸ì›Œí¬ ë¼ìš°íŒ…**

```python
# colocation-system/network-optimization/low_latency_routing.py
import asyncio
import socket
import struct
import time
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass
from datetime import datetime
import logging
import numpy as np
import ipaddress

logger = logging.getLogger(__name__)

@dataclass
class NetworkRoute:
    """ë„¤íŠ¸ì›Œí¬ ê²½ë¡œ"""
    route_id: str
    source_ip: str
    destination_ip: str
    gateway: str
    interface: str
    metric: int
    latency_ms: float
    bandwidth_mbps: float
    is_active: bool

@dataclass
class NetworkInterface:
    """ë„¤íŠ¸ì›Œí¬ ì¸í„°í˜ì´ìŠ¤"""
    interface_name: str
    ip_address: str
    subnet_mask: str
    gateway: str
    mtu: int
    speed_mbps: int
    duplex: str
    is_up: bool

@dataclass
class PacketInfo:
    """íŒ¨í‚· ì •ë³´"""
    packet_id: str
    source_ip: str
    destination_ip: str
    protocol: str
    size_bytes: int
    timestamp: datetime
    ttl: int

class LowLatencyRouter:
    """ì €ì§€ì—° ë¼ìš°í„°"""
    
    def __init__(self):
        self.routes = {}
        self.interfaces = {}
        self.routing_table = {}
        self.packet_stats = {}
        
        # ë„¤íŠ¸ì›Œí¬ ì¸í„°í˜ì´ìŠ¤ ì´ˆê¸°í™”
        self._initialize_interfaces()
        
        # ë¼ìš°íŒ… í…Œì´ë¸” ì´ˆê¸°í™”
        self._initialize_routing_table()
        
        # íŒ¨í‚· ìµœì í™”ê¸°
        self.packet_optimizer = PacketOptimizer()
        
        # í˜¼ì¡ ì œì–´ê¸°
        self.congestion_controller = CongestionController()
        
        logger.info("Low latency router initialized")
    
    def _initialize_interfaces(self):
        """ë„¤íŠ¸ì›Œí¬ ì¸í„°í˜ì´ìŠ¤ ì´ˆê¸°í™”"""
        self.interfaces = {
            'eth0': NetworkInterface(
                interface_name='eth0',
                ip_address='10.0.1.10',
                subnet_mask='255.255.255.0',
                gateway='10.0.1.1',
                mtu=9000,  # Jumbo frames
                speed_mbps=10000,  # 10Gbps
                duplex='full',
                is_up=True
            ),
            'eth1': NetworkInterface(
                interface_name='eth1',
                ip_address='10.0.2.10',
                subnet_mask='255.255.255.0',
                gateway='10.0.2.1',
                mtu=9000,
                speed_mbps=10000,
                duplex='full',
                is_up=True
            )
        }
    
    def _initialize_routing_table(self):
        """ë¼ìš°íŒ… í…Œì´ë¸” ì´ˆê¸°í™”"""
        # ë°”ì´ë‚¸ìŠ¤ ê²½ë¡œ
        self.routes['binance'] = NetworkRoute(
            route_id='binance_primary',
            source_ip='10.0.1.10',
            destination_ip='52.84.0.0',
            gateway='10.0.1.1',
            interface='eth0',
            metric=1,
            latency_ms=0.5,
            bandwidth_mbps=10000,
            is_active=True
        )
        
        # ì½”ì¸ë² ì´ìŠ¤ ê²½ë¡œ
        self.routes['coinbase'] = NetworkRoute(
            route_id='coinbase_primary',
            source_ip='10.0.2.10',
            destination_ip='52.84.0.2',
            gateway='10.0.2.1',
            interface='eth1',
            metric=1,
            latency_ms=1.2,
            bandwidth_mbps=10000,
            is_active=True
        )
        
        # ë¼ìš°íŒ… í…Œì´ë¸” êµ¬ì¶•
        for route in self.routes.values():
            self._add_route_to_table(route)
    
    def _add_route_to_table(self, route: NetworkRoute):
        """ë¼ìš°íŒ… í…Œì´ë¸”ì— ê²½ë¡œ ì¶”ê°€"""
        try:
            destination_network = ipaddress.IPv4Network(
                f"{route.destination_ip}/32", strict=False
            )
            
            self.routing_table[destination_network] = {
                'gateway': route.gateway,
                'interface': route.interface,
                'metric': route.metric,
                'latency': route.latency_ms,
                'is_active': route.is_active
            }
            
        except Exception as e:
            logger.error(f"Failed to add route to table: {e}")
    
    async def route_packet(self, packet: PacketInfo) -> Optional[str]:
        """íŒ¨í‚· ë¼ìš°íŒ…"""
        try:
            # ëª©ì ì§€ IP í™•ì¸
            destination_ip = ipaddress.IPv4Address(packet.destination_ip)
            
            # ë¼ìš°íŒ… í…Œì´ë¸”ì—ì„œ ê²½ë¡œ ì°¾ê¸°
            route_info = self._find_route(destination_ip)
            if not route_info:
                logger.warning(f"No route found for {packet.destination_ip}")
                return None
            
            # ê²½ë¡œê°€ í™œì„± ìƒíƒœì¸ì§€ í™•ì¸
            if not route_info['is_active']:
                logger.warning(f"Route is not active for {packet.destination_ip}")
                return None
            
            # íŒ¨í‚· ìµœì í™”
            optimized_packet = await self.packet_optimizer.optimize_packet(packet)
            
            # í˜¼ì¡ ì œì–´ í™•ì¸
            if not self.congestion_controller.can_send_packet(route_info['interface']):
                logger.warning(f"Congestion control blocked packet for {packet.destination_ip}")
                return None
            
            # íŒ¨í‚· ì „ì†¡
            interface_name = route_info['interface']
            success = await self._send_packet(optimized_packet, interface_name)
            
            if success:
                # íŒ¨í‚· í†µê³„ ì—…ë°ì´íŠ¸
                self._update_packet_stats(packet, route_info)
                
                return interface_name
            else:
                logger.error(f"Packet sending failed for {packet.destination_ip}")
                return None
                
        except Exception as e:
            logger.error(f"Packet routing failed: {e}")
            return None
    
    def _find_route(self, destination_ip: ipaddress.IPv4Address) -> Optional[Dict[str, Any]]:
        """ê²½ë¡œ ì°¾ê¸°"""
        try:
            # ê°€ì¥ êµ¬ì²´ì ì¸ ê²½ë¡œ ì°¾ê¸°
            best_route = None
            best_prefix_length = -1
            
            for network, route_info in self.routing_table.items():
                if destination_ip in network:
                    if network.prefixlen > best_prefix_length:
                        best_prefix_length = network.prefixlen
                        best_route = route_info
            
            return best_route
            
        except Exception as e:
            logger.error(f"Route finding failed: {e}")
            return None
    
    async def _send_packet(self, packet: PacketInfo, interface_name: str) -> bool:
        """íŒ¨í‚· ì „ì†¡"""
        try:
            # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì†Œì¼“ì„ í†µí•œ íŒ¨í‚· ì „ì†¡
            # ì—¬ê¸°ì„œëŠ” ì‹œë®¬ë ˆì´ì…˜
            
            # ì¸í„°í˜ì´ìŠ¤ ìƒíƒœ í™•ì¸
            if interface_name not in self.interfaces:
                return False
            
            interface = self.interfaces[interface_name]
            if not interface.is_up:
                return False
            
            # ì „ì†¡ ì§€ì—° ì‹œë®¬ë ˆì´ì…˜
            transmission_delay = packet.size_bytes / (interface.speed_mbps * 1000000)  # ì´ˆ
            await asyncio.sleep(transmission_delay)
            
            # ì„±ê³µë¥  ì‹œë®¬ë ˆì´ì…˜
            success_rate = 0.9999  # 99.99% ì„±ê³µë¥ 
            return np.random.random() < success_rate
            
        except Exception as e:
            logger.error(f"Packet sending failed: {e}")
            return False
    
    def _update_packet_stats(self, packet: PacketInfo, route_info: Dict[str, Any]):
        """íŒ¨í‚· í†µê³„ ì—…ë°ì´íŠ¸"""
        try:
            interface = route_info['interface']
            
            if interface not in self.packet_stats:
                self.packet_stats[interface] = {
                    'total_packets': 0,
                    'total_bytes': 0,
                    'successful_packets': 0,
                    'failed_packets': 0,
                    'average_latency': 0.0
                }
            
            stats = self.packet_stats[interface]
            stats['total_packets'] += 1
            stats['total_bytes'] += packet.size_bytes
            stats['successful_packets'] += 1
            
            # í‰ê·  ì§€ì—° ì‹œê°„ ì—…ë°ì´íŠ¸
            current_latency = route_info['latency']
            alpha = 0.1  # í‰í™œí™” ê³„ìˆ˜
            stats['average_latency'] = alpha * current_latency + (1 - alpha) * stats['average_latency']
            
        except Exception as e:
            logger.error(f"Packet stats update failed: {e}")
    
    async def measure_route_latency(self, destination_ip: str) -> float:
        """ê²½ë¡œ ì§€ì—° ì‹œê°„ ì¸¡ì •"""
        try:
            # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ICMP ping ë˜ëŠ” TCP ping ì‚¬ìš©
            # ì—¬ê¸°ì„œëŠ” ì‹œë®¬ë ˆì´ì…˜
            
            # ëª©ì ì§€ IPì— ë”°ë¥¸ ê¸°ë³¸ ì§€ì—° ì‹œê°„
            base_latencies = {
                '52.84.0.0': 0.5,   # ë°”ì´ë‚¸ìŠ¤
                '52.84.0.2': 1.2,   # ì½”ì¸ë² ì´ìŠ¤
                '52.84.0.4': 2.1    # í¬ë¼ì¼„
            }
            
            base_latency = base_latencies.get(destination_ip, 5.0)
            
            # ëœë¤ ë³€ë™ ì¶”ê°€
            variation = np.random.normal(0, 0.1)
            latency = base_latency + variation
            
            return max(latency, 0.1)  # ìµœì†Œ 0.1ms
            
        except Exception as e:
            logger.error(f"Route latency measurement failed: {e}")
            return 999.0
    
    def get_routing_stats(self) -> Dict[str, Any]:
        """ë¼ìš°íŒ… í†µê³„ ì¡°íšŒ"""
        try:
            total_routes = len(self.routes)
            active_routes = sum(1 for route in self.routes.values() if route.is_active)
            
            total_packets = sum(stats['total_packets'] for stats in self.packet_stats.values())
            total_bytes = sum(stats['total_bytes'] for stats in self.packet_stats.values())
            
            return {
                'total_routes': total_routes,
                'active_routes': active_routes,
                'total_packets': total_packets,
                'total_bytes': total_bytes,
                'packet_stats': self.packet_stats
            }
            
        except Exception as e:
            logger.error(f"Routing stats retrieval failed: {e}")
            return {}

class PacketOptimizer:
    """íŒ¨í‚· ìµœì í™”ê¸°"""
    
    def __init__(self):
        self.optimization_rules = self._load_optimization_rules()
    
    def _load_optimization_rules(self) -> Dict[str, Any]:
        """ìµœì í™” ê·œì¹™ ë¡œë“œ"""
        return {
            'enable_jumbo_frames': True,
            'enable_tcp_nodelay': True,
            'enable_tcp_cork': False,
            'enable_udp_checksum_offload': True,
            'enable_tcp_checksum_offload': True,
            'enable_scatter_gather': True,
            'enable_large_receive_offload': True
        }
    
    async def optimize_packet(self, packet: PacketInfo) -> PacketInfo:
        """íŒ¨í‚· ìµœì í™”"""
        try:
            optimized_packet = packet
            
            # Jumbo frames í™œì„±í™”
            if self.optimization_rules['enable_jumbo_frames']:
                optimized_packet = self._apply_jumbo_frames(optimized_packet)
            
            # TCP ìµœì í™”
            if packet.protocol == 'TCP':
                optimized_packet = self._apply_tcp_optimizations(optimized_packet)
            
            # UDP ìµœì í™”
            elif packet.protocol == 'UDP':
                optimized_packet = self._apply_udp_optimizations(optimized_packet)
            
            return optimized_packet
            
        except Exception as e:
            logger.error(f"Packet optimization failed: {e}")
            return packet
    
    def _apply_jumbo_frames(self, packet: PacketInfo) -> PacketInfo:
        """Jumbo frames ì ìš©"""
        try:
            # MTU 9000ìœ¼ë¡œ ì„¤ì •í•˜ì—¬ í° íŒ¨í‚· í—ˆìš©
            # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ë„¤íŠ¸ì›Œí¬ ì¸í„°í˜ì´ìŠ¤ ì„¤ì • ë³€ê²½
            return packet
            
        except Exception as e:
            logger.error(f"Jumbo frames application failed: {e}")
            return packet
    
    def _apply_tcp_optimizations(self, packet: PacketInfo) -> PacketInfo:
        """TCP ìµœì í™” ì ìš©"""
        try:
            # TCP_NODELAY ì„¤ì • (Nagle ì•Œê³ ë¦¬ì¦˜ ë¹„í™œì„±í™”)
            if self.optimization_rules['enable_tcp_nodelay']:
                # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì†Œì¼“ ì˜µì…˜ ì„¤ì •
                pass
            
            # TCP ì²´í¬ì„¬ ì˜¤í”„ë¡œë“œ
            if self.optimization_rules['enable_tcp_checksum_offload']:
                # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” í•˜ë“œì›¨ì–´ ì²´í¬ì„¬ ê³„ì‚°
                pass
            
            return packet
            
        except Exception as e:
            logger.error(f"TCP optimizations application failed: {e}")
            return packet
    
    def _apply_udp_optimizations(self, packet: PacketInfo) -> PacketInfo:
        """UDP ìµœì í™” ì ìš©"""
        try:
            # UDP ì²´í¬ì„¬ ì˜¤í”„ë¡œë“œ
            if self.optimization_rules['enable_udp_checksum_offload']:
                # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” í•˜ë“œì›¨ì–´ ì²´í¬ì„¬ ê³„ì‚°
                pass
            
            return packet
            
        except Exception as e:
            logger.error(f"UDP optimizations application failed: {e}")
            return packet

class CongestionController:
    """í˜¼ì¡ ì œì–´ê¸°"""
    
    def __init__(self):
        self.interface_stats = {}
        self.congestion_threshold = 0.8  # 80% ì„ê³„ê°’
    
    def can_send_packet(self, interface_name: str) -> bool:
        """íŒ¨í‚· ì „ì†¡ ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸"""
        try:
            if interface_name not in self.interface_stats:
                return True
            
            stats = self.interface_stats[interface_name]
            
            # ëŒ€ì—­í­ ì‚¬ìš©ë¥  í™•ì¸
            bandwidth_usage = stats.get('bandwidth_usage', 0.0)
            
            if bandwidth_usage > self.congestion_threshold:
                logger.warning(f"Congestion detected on {interface_name}: {bandwidth_usage:.2%}")
                return False
            
            return True
            
        except Exception as e:
            logger.error(f"Congestion control check failed: {e}")
            return True
    
    def update_interface_stats(self, interface_name: str, stats: Dict[str, Any]):
        """ì¸í„°í˜ì´ìŠ¤ í†µê³„ ì—…ë°ì´íŠ¸"""
        try:
            self.interface_stats[interface_name] = stats
            
        except Exception as e:
            logger.error(f"Interface stats update failed: {e}")
```

## ğŸ¯ **ë‹¤ìŒ ë‹¨ê³„**

### ğŸ“‹ **ì™„ë£Œëœ ì‘ì—…**
- âœ… ê±°ë˜ì†Œ ì½”ë¡œì¼€ì´ì…˜ ì‹œìŠ¤í…œ ì„¤ê³„
- âœ… ë„¤íŠ¸ì›Œí¬ ìµœì í™” ì‹œìŠ¤í…œ
- âœ… ì €ì§€ì—° ë¼ìš°íŒ… ì‹œìŠ¤í…œ
- âœ… íŒ¨í‚· ìµœì í™” ë° í˜¼ì¡ ì œì–´

### ğŸ”„ **ì§„í–‰ ì¤‘ì¸ ì‘ì—…**
- ğŸ”„ ë°ì´í„° ì„¼í„° ì„ íƒ ì‹œìŠ¤í…œ
- ğŸ”„ ì—°ê²°ì„± ê´€ë¦¬ ì‹œìŠ¤í…œ
- ğŸ”„ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ

### â³ **ë‹¤ìŒ ë‹¨ê³„**
1. **Phase 5 ê³ ê¸‰ ê¸°ëŠ¥** ë¬¸ì„œ ìƒì„±
2. **Phase 6 ë³´ì•ˆ ê°•í™”** ë¬¸ì„œ ìƒì„±
3. **Phase 7 ê¸€ë¡œë²Œ í™•ì¥** ë¬¸ì„œ ìƒì„±

---

**ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸**: 2024-01-31
**ë‹¤ìŒ ì—…ë°ì´íŠ¸**: 2024-02-01 (Phase 5 ê³ ê¸‰ ê¸°ëŠ¥)
**ì½”ë¡œì¼€ì´ì…˜ ëª©í‘œ**: < 1ms ë„¤íŠ¸ì›Œí¬ ì§€ì—°, < 0.001% íŒ¨í‚· ì†ì‹¤ë¥ , > 99.99% ê°€ìš©ì„±
**ì½”ë¡œì¼€ì´ì…˜ ì„±ê³¼**: ë‹¤ì¤‘ ê±°ë˜ì†Œ ì—°ê²°, ì €ì§€ì—° ë¼ìš°íŒ…, íŒ¨í‚· ìµœì í™”, í˜¼ì¡ ì œì–´ 