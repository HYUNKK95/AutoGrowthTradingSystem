# ğŸ“Š Phase 3.5.1: ê¸°ìˆ ì  ì§€í‘œ ë¶„ì„ ì‹œìŠ¤í…œ (ê¸°ë³¸ + ê³ ê¸‰ í†µí•©)

## ğŸ“‹ **ê°œìš”**

### ğŸ¯ **ëª©í‘œ**
- **ê¸°ë³¸ ì§€í‘œ**: RSI, MACD, Bollinger Bands, Moving Averages ë“± 20+ ì§€í‘œ
- **ê³ ê¸‰ ì§€í‘œ**: Stochastic, Williams %R, ATR, Ichimoku ë“± ê³ ê¸‰ ì§€í‘œ
- **í¬íŠ¸í´ë¦¬ì˜¤ ë¶„ì„**: ìì‚°ë³„ ì„±ê³¼ ë¶„ì„, ë¦¬ìŠ¤í¬ ë¶„í•´
- **ì‹œì¥ ì‹¬ë¦¬ ë¶„ì„**: Fear & Greed Index, ë³€ë™ì„± ì§€í‘œ(VIX, ATR)
- **ê±°ë˜ëŸ‰ ë¶„ì„**: Volume Profile, OBV, ê±°ë˜ëŸ‰ ê°€ì¤‘ í‰ê· 
- **ìë™ ì§€ì§€/ì €í•­**: í”¼ë³´ë‚˜ì¹˜ ë ˆë²¨, Pivot Points, ìë™ ë ˆë²¨ ê°ì§€
- **ê³ ê¸‰ íŒ¨í„´ ì¸ì‹**: í—¤ë“œì•¤ìˆ„ë”, ë”ë¸”íƒ‘/ë°”í…€, í”¼ë³´ë‚˜ì¹˜ íŒ¨í„´
- **ë‹¤ì¤‘ ì‹œì¥ ìƒê´€ê´€ê³„**: í¬ë¡œìŠ¤ ì—ì…‹, í¬ë¡œìŠ¤ ë§ˆì¼“ ë¶„ì„
- **ì‹¤ì‹œê°„ ì˜µì…˜ ë¶„ì„**: ì˜µì…˜ ì²´ì¸, ê·¸ë¦­ìŠ¤ ë¶„ì„
- **ë©€í‹° íƒ€ì„í”„ë ˆì„**: 1ë¶„~ì›”ë´‰ í†µí•© ë¶„ì„
- **ì§€í‘œ ì¡°í•©**: ë‹¤ì¤‘ ì§€í‘œ ì‹ í˜¸ í†µí•© ë° ê°€ì¤‘ì¹˜ ì ìš©
- **ì‹¤ì‹œê°„ ê³„ì‚°**: < 10ms ì§€í‘œ ì—…ë°ì´íŠ¸

### ğŸ“Š **ì„±ëŠ¥ ëª©í‘œ**
- **ì§€í‘œ ê³„ì‚° ì†ë„**: < 10ms per indicator
- **ë©€í‹° íƒ€ì„í”„ë ˆì„**: < 50ms í†µí•© ë¶„ì„
- **ì‹ í˜¸ ìƒì„±**: < 100ms ì‹ í˜¸ ìƒì„±
- **íŒ¨í„´ ì¸ì‹ ì •í™•ë„**: > 85% íŒ¨í„´ ê°ì§€ ì •í™•ë„
- **ìƒê´€ê´€ê³„ ë¶„ì„**: < 100ms í¬ë¡œìŠ¤ ì—ì…‹ ë¶„ì„
- **ì˜µì…˜ ë¶„ì„**: < 500ms ê·¸ë¦­ìŠ¤ ê³„ì‚°
- **ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰**: < 500MB
- **ì •í™•ë„**: > 70% ì‹ í˜¸ ì •í™•ë„

## ğŸ—ï¸ **ê¸°ìˆ ì  ì§€í‘œ ë¶„ì„ ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜**

### ğŸ“ **ì‹œìŠ¤í…œ êµ¬ì¡°**
```
technical-analysis/
â”œâ”€â”€ basic-indicators/                   # ê¸°ë³¸ ì§€í‘œ
â”‚   â”œâ”€â”€ trend-indicators/              # íŠ¸ë Œë“œ ì§€í‘œ
â”‚   â”œâ”€â”€ momentum-indicators/           # ëª¨ë©˜í…€ ì§€í‘œ
â”‚   â”œâ”€â”€ volatility-indicators/         # ë³€ë™ì„± ì§€í‘œ
â”‚   â””â”€â”€ volume-indicators/             # ê±°ë˜ëŸ‰ ì§€í‘œ
â”œâ”€â”€ advanced-indicators/                # ê³ ê¸‰ ì§€í‘œ
â”‚   â”œâ”€â”€ oscillator-indicators/         # ì˜¤ì‹¤ë ˆì´í„° ì§€í‘œ
â”‚   â”œâ”€â”€ custom-indicators/             # ì»¤ìŠ¤í…€ ì§€í‘œ
â”‚   â”œâ”€â”€ composite-indicators/          # ë³µí•© ì§€í‘œ
â”‚   â””â”€â”€ pattern-indicators/            # íŒ¨í„´ ì§€í‘œ
â”œâ”€â”€ portfolio-analysis/                 # í¬íŠ¸í´ë¦¬ì˜¤ ë¶„ì„
â”‚   â”œâ”€â”€ asset-performance/             # ìì‚°ë³„ ì„±ê³¼ ë¶„ì„
â”‚   â”œâ”€â”€ risk-decomposition/            # ë¦¬ìŠ¤í¬ ë¶„í•´
â”‚   â”œâ”€â”€ correlation-analysis/          # ìƒê´€ê´€ê³„ ë¶„ì„
â”‚   â””â”€â”€ portfolio-optimization/        # í¬íŠ¸í´ë¦¬ì˜¤ ìµœì í™”
â”œâ”€â”€ market-sentiment-analysis/          # ì‹œì¥ ì‹¬ë¦¬ ë¶„ì„
â”‚   â”œâ”€â”€ fear-greed-index/              # Fear & Greed Index
â”‚   â”œâ”€â”€ volatility-indicators/         # ë³€ë™ì„± ì§€í‘œ (VIX, ATR)
â”‚   â”œâ”€â”€ market-regime-detection/       # ì‹œì¥ ì²´ì œ ê°ì§€
â”‚   â””â”€â”€ sentiment-aggregation/         # ì‹¬ë¦¬ ì§€í‘œ ì§‘ê³„
â”œâ”€â”€ volume-analysis/                    # ê±°ë˜ëŸ‰ ë¶„ì„
â”‚   â”œâ”€â”€ volume-profile/                # Volume Profile
â”‚   â”œâ”€â”€ obv-analysis/                  # OBV ë¶„ì„
â”‚   â”œâ”€â”€ volume-weighted-averages/      # ê±°ë˜ëŸ‰ ê°€ì¤‘ í‰ê· 
â”‚   â””â”€â”€ volume-patterns/               # ê±°ë˜ëŸ‰ íŒ¨í„´
â”œâ”€â”€ support-resistance/                 # ìë™ ì§€ì§€/ì €í•­
â”‚   â”œâ”€â”€ fibonacci-levels/              # í”¼ë³´ë‚˜ì¹˜ ë ˆë²¨
â”‚   â”œâ”€â”€ pivot-points/                  # Pivot Points
â”‚   â”œâ”€â”€ automatic-level-detection/     # ìë™ ë ˆë²¨ ê°ì§€
â”‚   â””â”€â”€ dynamic-levels/                # ë™ì  ë ˆë²¨
â”œâ”€â”€ multi-timeframe/                    # ë©€í‹° íƒ€ì„í”„ë ˆì„
â”‚   â”œâ”€â”€ timeframe-manager/             # íƒ€ì„í”„ë ˆì„ ê´€ë¦¬
â”‚   â”œâ”€â”€ signal-aggregator/             # ì‹ í˜¸ ì§‘ê³„
â”‚   â”œâ”€â”€ weight-calculator/             # ê°€ì¤‘ì¹˜ ê³„ì‚°
â”‚   â””â”€â”€ consistency-checker/           # ì¼ê´€ì„± ê²€ì‚¬
â”œâ”€â”€ signal-generation/                  # ì‹ í˜¸ ìƒì„±
â”‚   â”œâ”€â”€ signal-combiner/               # ì‹ í˜¸ ê²°í•©
â”‚   â”œâ”€â”€ confidence-calculator/         # ì‹ ë¢°ë„ ê³„ì‚°
â”‚   â”œâ”€â”€ threshold-manager/             # ì„ê³„ê°’ ê´€ë¦¬
â”‚   â””â”€â”€ alert-system/                  # ì•Œë¦¼ ì‹œìŠ¤í…œ
â”œâ”€â”€ performance-optimization/           # ì„±ëŠ¥ ìµœì í™”
    â”œâ”€â”€ caching-system/                # ìºì‹± ì‹œìŠ¤í…œ
    â”œâ”€â”€ parallel-processing/           # ë³‘ë ¬ ì²˜ë¦¬
    â”œâ”€â”€ memory-management/             # ë©”ëª¨ë¦¬ ê´€ë¦¬
    â””â”€â”€ latency-monitoring/            # ì§€ì—° ëª¨ë‹ˆí„°ë§
â”œâ”€â”€ advanced-pattern-recognition/       # ê³ ê¸‰ íŒ¨í„´ ì¸ì‹
    â”œâ”€â”€ candlestick-patterns/          # ìº”ë“¤ìŠ¤í‹± íŒ¨í„´
    â”œâ”€â”€ chart-patterns/                # ì°¨íŠ¸ íŒ¨í„´ (í—¤ë“œì•¤ìˆ„ë”, ë”ë¸”íƒ‘/ë°”í…€)
    â”œâ”€â”€ fibonacci-patterns/            # í”¼ë³´ë‚˜ì¹˜ íŒ¨í„´
    â”œâ”€â”€ harmonic-patterns/             # í•˜ëª¨ë‹‰ íŒ¨í„´
    â””â”€â”€ elliott-waves/                 # ì—˜ë¦¬ì—‡ ì›¨ì´ë¸Œ
â”œâ”€â”€ cross-market-analysis/              # í¬ë¡œìŠ¤ ë§ˆì¼“ ë¶„ì„
    â”œâ”€â”€ asset-correlation/             # ìì‚° ìƒê´€ê´€ê³„
    â”œâ”€â”€ market-regime-detection/       # ì‹œì¥ ì²´ì œ ê°ì§€
    â”œâ”€â”€ sector-rotation/               # ì„¹í„° ë¡œí…Œì´ì…˜
    â””â”€â”€ global-macro-analysis/         # ê¸€ë¡œë²Œ ë§¤í¬ë¡œ
â””â”€â”€ options-analysis/                   # ì˜µì…˜ ë¶„ì„
    â”œâ”€â”€ options-chain-analysis/        # ì˜µì…˜ ì²´ì¸ ë¶„ì„
    â”œâ”€â”€ greeks-calculator/             # ê·¸ë¦­ìŠ¤ ê³„ì‚°ê¸°
    â”œâ”€â”€ implied-volatility/            # ë‚´ì¬ ë³€ë™ì„±
    â””â”€â”€ options-strategies/            # ì˜µì…˜ ì „ëµ
```

## ğŸ”§ **ê¸°ë³¸ ê¸°ìˆ ì  ì§€í‘œ ì‹œìŠ¤í…œ**

### ğŸ“¦ **ê¸°ë³¸ ì§€í‘œ ê³„ì‚°ê¸°**

```python
# technical-analysis/basic-indicators/basic_indicator_calculator.py
import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional, Union
from dataclasses import dataclass
from datetime import datetime
import logging
from enum import Enum

logger = logging.getLogger(__name__)

class IndicatorType(Enum):
    """ì§€í‘œ íƒ€ì…"""
    TREND = "trend"
    MOMENTUM = "momentum"
    VOLATILITY = "volatility"
    VOLUME = "volume"
    OSCILLATOR = "oscillator"

@dataclass
class IndicatorValue:
    """ì§€í‘œ ê°’"""
    indicator_name: str
    value: float
    timestamp: datetime
    confidence: float = 0.0
    metadata: Dict[str, any] = None

@dataclass
class TechnicalSignal:
    """ê¸°ìˆ ì  ì‹ í˜¸"""
    signal_type: str  # 'BUY', 'SELL', 'HOLD'
    strength: float   # 0.0 ~ 1.0
    confidence: float # 0.0 ~ 1.0
    indicators: List[IndicatorValue]
    timestamp: datetime
    timeframe: str

class BasicIndicatorCalculator:
    """ê¸°ë³¸ ê¸°ìˆ ì  ì§€í‘œ ê³„ì‚°ê¸°"""
    
    def __init__(self):
        self.cache = {}
        self.calculation_history = []
    
    def calculate_rsi(self, prices: List[float], period: int = 14) -> IndicatorValue:
        """RSI (Relative Strength Index) ê³„ì‚°"""
        if len(prices) < period + 1:
            return None
        
        # ìºì‹œ í™•ì¸
        cache_key = f"rsi_{period}_{hash(tuple(prices[-period-1:]))}"
        if cache_key in self.cache:
            return self.cache[cache_key]
        
        try:
            # ê°€ê²© ë³€í™” ê³„ì‚°
            deltas = np.diff(prices)
            gains = np.where(deltas > 0, deltas, 0)
            losses = np.where(deltas < 0, -deltas, 0)
            
            # í‰ê·  ê³„ì‚°
            avg_gains = np.mean(gains[-period:])
            avg_losses = np.mean(losses[-period:])
            
            if avg_losses == 0:
                rsi = 100
            else:
                rs = avg_gains / avg_losses
                rsi = 100 - (100 / (1 + rs))
            
            # ì‹ ë¢°ë„ ê³„ì‚° (ë°ì´í„° í’ˆì§ˆ ê¸°ë°˜)
            confidence = min(1.0, len(prices) / (period * 2))
            
            result = IndicatorValue(
                indicator_name="RSI",
                value=rsi,
                timestamp=datetime.now(),
                confidence=confidence,
                metadata={"period": period, "method": "standard"}
            )
            
            # ìºì‹œ ì €ì¥
            self.cache[cache_key] = result
            return result
            
        except Exception as e:
            logger.error(f"RSI ê³„ì‚° ì˜¤ë¥˜: {e}")
            return None
    
    def calculate_macd(self, prices: List[float], 
                      fast_period: int = 12, 
                      slow_period: int = 26, 
                      signal_period: int = 9) -> Dict[str, IndicatorValue]:
        """MACD (Moving Average Convergence Divergence) ê³„ì‚°"""
        if len(prices) < slow_period + signal_period:
            return None
        
        try:
            # EMA ê³„ì‚°
            ema_fast = self._calculate_ema(prices, fast_period)
            ema_slow = self._calculate_ema(prices, slow_period)
            
            # MACD ë¼ì¸
            macd_line = ema_fast - ema_slow
            
            # ì‹œê·¸ë„ ë¼ì¸
            macd_values = [macd_line]
            signal_line = self._calculate_ema(macd_values, signal_period)
            
            # íˆìŠ¤í† ê·¸ë¨
            histogram = macd_line - signal_line
            
            # ì‹ ë¢°ë„ ê³„ì‚°
            confidence = min(1.0, len(prices) / (slow_period + signal_period))
            
            return {
                "macd": IndicatorValue("MACD", macd_line, datetime.now(), confidence),
                "signal": IndicatorValue("MACD_Signal", signal_line, datetime.now(), confidence),
                "histogram": IndicatorValue("MACD_Histogram", histogram, datetime.now(), confidence)
            }
            
        except Exception as e:
            logger.error(f"MACD ê³„ì‚° ì˜¤ë¥˜: {e}")
            return None
    
    def calculate_bollinger_bands(self, prices: List[float], 
                                 period: int = 20, 
                                 std_dev: float = 2.0) -> Dict[str, IndicatorValue]:
        """ë³¼ë¦°ì € ë°´ë“œ ê³„ì‚°"""
        if len(prices) < period:
            return None
        
        try:
            # ì´ë™í‰ê· 
            sma = np.mean(prices[-period:])
            
            # í‘œì¤€í¸ì°¨
            std = np.std(prices[-period:])
            
            # ë°´ë“œ ê³„ì‚°
            upper_band = sma + (std_dev * std)
            lower_band = sma - (std_dev * std)
            
            # ì‹ ë¢°ë„ ê³„ì‚°
            confidence = min(1.0, len(prices) / period)
            
            return {
                "upper": IndicatorValue("BB_Upper", upper_band, datetime.now(), confidence),
                "middle": IndicatorValue("BB_Middle", sma, datetime.now(), confidence),
                "lower": IndicatorValue("BB_Lower", lower_band, datetime.now(), confidence),
                "width": IndicatorValue("BB_Width", upper_band - lower_band, datetime.now(), confidence)
            }
            
        except Exception as e:
            logger.error(f"ë³¼ë¦°ì € ë°´ë“œ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return None
    
    def calculate_moving_averages(self, prices: List[float], 
                                 periods: List[int] = [5, 10, 20, 50, 200]) -> Dict[str, IndicatorValue]:
        """ì´ë™í‰ê·  ê³„ì‚°"""
        results = {}
        
        for period in periods:
            if len(prices) >= period:
                try:
                    ma_value = np.mean(prices[-period:])
                    confidence = min(1.0, len(prices) / period)
                    
                    results[f"SMA_{period}"] = IndicatorValue(
                        f"SMA_{period}", ma_value, datetime.now(), confidence
                    )
                except Exception as e:
                    logger.error(f"SMA {period} ê³„ì‚° ì˜¤ë¥˜: {e}")
        
        return results
    
    def _calculate_ema(self, prices: List[float], period: int) -> float:
        """ì§€ìˆ˜ì´ë™í‰ê·  ê³„ì‚°"""
        if len(prices) < period:
            return prices[-1] if prices else 0
        
        alpha = 2 / (period + 1)
        ema = prices[0]
        
        for price in prices[1:]:
            ema = alpha * price + (1 - alpha) * ema
        
        return ema
    
    def calculate_stochastic(self, high_prices: List[float], 
                           low_prices: List[float], 
                           close_prices: List[float], 
                           k_period: int = 14, 
                           d_period: int = 3) -> Dict[str, IndicatorValue]:
        """ìŠ¤í† ìºìŠ¤í‹± ê³„ì‚°"""
        if len(close_prices) < k_period:
            return None
        
        try:
            # %K ê³„ì‚°
            lowest_low = min(low_prices[-k_period:])
            highest_high = max(high_prices[-k_period:])
            current_close = close_prices[-1]
            
            if highest_high == lowest_low:
                k_percent = 50
            else:
                k_percent = ((current_close - lowest_low) / (highest_high - lowest_low)) * 100
            
            # %D ê³„ì‚° (Kì˜ ì´ë™í‰ê· )
            k_values = []
            for i in range(k_period):
                if i < len(close_prices) - k_period:
                    low_min = min(low_prices[-(k_period-i):])
                    high_max = max(high_prices[-(k_period-i):])
                    close_val = close_prices[-(i+1)]
                    if high_max == low_min:
                        k_val = 50
                    else:
                        k_val = ((close_val - low_min) / (high_max - low_min)) * 100
                    k_values.append(k_val)
            
            d_percent = np.mean(k_values) if k_values else k_percent
            
            confidence = min(1.0, len(close_prices) / k_period)
            
            return {
                "k": IndicatorValue("Stoch_K", k_percent, datetime.now(), confidence),
                "d": IndicatorValue("Stoch_D", d_percent, datetime.now(), confidence)
            }
            
        except Exception as e:
            logger.error(f"ìŠ¤í† ìºìŠ¤í‹± ê³„ì‚° ì˜¤ë¥˜: {e}")
            return None
    
    def calculate_atr(self, high_prices: List[float], 
                     low_prices: List[float], 
                     close_prices: List[float], 
                     period: int = 14) -> IndicatorValue:
        """ATR (Average True Range) ê³„ì‚°"""
        if len(close_prices) < period + 1:
            return None
        
        try:
            true_ranges = []
            
            for i in range(1, len(close_prices)):
                high = high_prices[i]
                low = low_prices[i]
                prev_close = close_prices[i-1]
                
                tr1 = high - low
                tr2 = abs(high - prev_close)
                tr3 = abs(low - prev_close)
                
                true_range = max(tr1, tr2, tr3)
                true_ranges.append(true_range)
            
            # ATR ê³„ì‚° (ì§€ìˆ˜ì´ë™í‰ê·  ì‚¬ìš©)
            atr = self._calculate_ema(true_ranges, period)
            
            confidence = min(1.0, len(close_prices) / period)
            
            return IndicatorValue(
                "ATR", atr, datetime.now(), confidence,
                metadata={"period": period, "method": "exponential"}
            )
            
        except Exception as e:
            logger.error(f"ATR ê³„ì‚° ì˜¤ë¥˜: {e}")
            return None
```

## ğŸ”§ **ê³ ê¸‰ ì§€í‘œ ì‹œìŠ¤í…œ**

### ğŸ“¦ **ê³ ê¸‰ ì§€í‘œ ê³„ì‚°ê¸°**

```python
# technical-analysis/advanced-indicators/advanced_indicator_calculator.py
import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional, Union
from dataclasses import dataclass
from datetime import datetime
import logging
import talib

logger = logging.getLogger(__name__)

class AdvancedIndicatorCalculator:
    """ê³ ê¸‰ ê¸°ìˆ ì  ì§€í‘œ ê³„ì‚°ê¸°"""
    
    def __init__(self):
        self.cache = {}
        self.custom_indicators = {}
    
    def calculate_ichimoku(self, high_prices: List[float], 
                          low_prices: List[float], 
                          close_prices: List[float]) -> Dict[str, IndicatorValue]:
        """ì¼ëª©ê· í˜•í‘œ (Ichimoku Kinko Hyo) ê³„ì‚°"""
        if len(close_prices) < 52:
            return None
        
        try:
            # ì „í™˜ì„  (Conversion Line)
            period9_high = max(high_prices[-9:])
            period9_low = min(low_prices[-9:])
            conversion = (period9_high + period9_low) / 2
            
            # ê¸°ì¤€ì„  (Base Line)
            period26_high = max(high_prices[-26:])
            period26_low = min(low_prices[-26:])
            base = (period26_high + period26_low) / 2
            
            # ì„ í–‰ìŠ¤íŒ¬1 (Leading Span A)
            leading_span_a = (conversion + base) / 2
            
            # ì„ í–‰ìŠ¤íŒ¬2 (Leading Span B)
            period52_high = max(high_prices[-52:])
            period52_low = min(low_prices[-52:])
            leading_span_b = (period52_high + period52_low) / 2
            
            # í›„í–‰ìŠ¤íŒ¬ (Lagging Span)
            lagging_span = close_prices[-26] if len(close_prices) >= 26 else close_prices[-1]
            
            confidence = min(1.0, len(close_prices) / 52)
            timestamp = datetime.now()
            
            return {
                "conversion": IndicatorValue("Ichimoku_Conversion", conversion, timestamp, confidence),
                "base": IndicatorValue("Ichimoku_Base", base, timestamp, confidence),
                "leading_span_a": IndicatorValue("Ichimoku_Leading_A", leading_span_a, timestamp, confidence),
                "leading_span_b": IndicatorValue("Ichimoku_Leading_B", leading_span_b, timestamp, confidence),
                "lagging_span": IndicatorValue("Ichimoku_Lagging", lagging_span, timestamp, confidence)
            }
            
        except Exception as e:
            logger.error(f"ì¼ëª©ê· í˜•í‘œ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return None
    
    def calculate_williams_r(self, high_prices: List[float], 
                           low_prices: List[float], 
                           close_prices: List[float], 
                           period: int = 14) -> IndicatorValue:
        """Williams %R ê³„ì‚°"""
        if len(close_prices) < period:
            return None
        
        try:
            highest_high = max(high_prices[-period:])
            lowest_low = min(low_prices[-period:])
            current_close = close_prices[-1]
            
            if highest_high == lowest_low:
                williams_r = -50
            else:
                williams_r = ((highest_high - current_close) / (highest_high - lowest_low)) * -100
            
            confidence = min(1.0, len(close_prices) / period)
            
            return IndicatorValue(
                "Williams_R", williams_r, datetime.now(), confidence,
                metadata={"period": period, "method": "standard"}
            )
            
        except Exception as e:
            logger.error(f"Williams %R ê³„ì‚° ì˜¤ë¥˜: {e}")
            return None
    
    def calculate_cci(self, high_prices: List[float], 
                     low_prices: List[float], 
                     close_prices: List[float], 
                     period: int = 20) -> IndicatorValue:
        """CCI (Commodity Channel Index) ê³„ì‚°"""
        if len(close_prices) < period:
            return None
        
        try:
            # ì „í˜•ì  ê°€ê²© (Typical Price)
            typical_prices = [(h + l + c) / 3 for h, l, c in zip(high_prices, low_prices, close_prices)]
            
            # ì´ë™í‰ê· 
            sma = np.mean(typical_prices[-period:])
            
            # í‰ê· í¸ì°¨
            mean_deviation = np.mean([abs(tp - sma) for tp in typical_prices[-period:]])
            
            current_tp = typical_prices[-1]
            
            if mean_deviation == 0:
                cci = 0
            else:
                cci = (current_tp - sma) / (0.015 * mean_deviation)
            
            confidence = min(1.0, len(close_prices) / period)
            
            return IndicatorValue(
                "CCI", cci, datetime.now(), confidence,
                metadata={"period": period, "method": "standard"}
            )
            
        except Exception as e:
            logger.error(f"CCI ê³„ì‚° ì˜¤ë¥˜: {e}")
            return None
    
    def add_custom_indicator(self, name: str, calculation_func):
        """ì»¤ìŠ¤í…€ ì§€í‘œ ì¶”ê°€"""
        self.custom_indicators[name] = calculation_func
        logger.info(f"ì»¤ìŠ¤í…€ ì§€í‘œ ì¶”ê°€: {name}")
    
    def calculate_custom_indicator(self, name: str, *args, **kwargs) -> Optional[IndicatorValue]:
        """ì»¤ìŠ¤í…€ ì§€í‘œ ê³„ì‚°"""
        if name not in self.custom_indicators:
            logger.error(f"ì»¤ìŠ¤í…€ ì§€í‘œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŒ: {name}")
            return None
        
        try:
            result = self.custom_indicators[name](*args, **kwargs)
            return result
        except Exception as e:
            logger.error(f"ì»¤ìŠ¤í…€ ì§€í‘œ ê³„ì‚° ì˜¤ë¥˜ {name}: {e}")
            return None
```

## ğŸ”§ **ë©€í‹° íƒ€ì„í”„ë ˆì„ ë¶„ì„ ì‹œìŠ¤í…œ**

### ğŸ“¦ **ë©€í‹° íƒ€ì„í”„ë ˆì„ ë¶„ì„ê¸°**

```python
# technical-analysis/multi-timeframe/multi_timeframe_analyzer.py
import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional, Union
from dataclasses import dataclass
from datetime import datetime, timedelta
import logging
from enum import Enum

logger = logging.getLogger(__name__)

class Timeframe(Enum):
    """íƒ€ì„í”„ë ˆì„"""
    MINUTE_1 = "1m"
    MINUTE_5 = "5m"
    MINUTE_15 = "15m"
    MINUTE_30 = "30m"
    HOUR_1 = "1h"
    HOUR_4 = "4h"
    DAY_1 = "1d"
    WEEK_1 = "1w"
    MONTH_1 = "1M"

@dataclass
class TimeframeSignal:
    """íƒ€ì„í”„ë ˆì„ë³„ ì‹ í˜¸"""
    timeframe: Timeframe
    signal_type: str  # 'BUY', 'SELL', 'HOLD'
    strength: float   # 0.0 ~ 1.0
    confidence: float # 0.0 ~ 1.0
    indicators: List[IndicatorValue]
    timestamp: datetime

@dataclass
class MultiTimeframeSignal:
    """ë©€í‹° íƒ€ì„í”„ë ˆì„ í†µí•© ì‹ í˜¸"""
    overall_signal: str  # 'BUY', 'SELL', 'HOLD'
    overall_strength: float  # 0.0 ~ 1.0
    overall_confidence: float  # 0.0 ~ 1.0
    timeframe_signals: Dict[Timeframe, TimeframeSignal]
    consistency_score: float  # 0.0 ~ 1.0
    timestamp: datetime

class MultiTimeframeAnalyzer:
    """ë©€í‹° íƒ€ì„í”„ë ˆì„ ë¶„ì„ê¸°"""
    
    def __init__(self, timeframes: List[Timeframe] = None):
        self.timeframes = timeframes or [
            Timeframe.MINUTE_5, Timeframe.MINUTE_15, Timeframe.HOUR_1, 
            Timeframe.HOUR_4, Timeframe.DAY_1
        ]
        self.timeframe_weights = self._calculate_timeframe_weights()
        self.consistency_threshold = 0.7
    
    def _calculate_timeframe_weights(self) -> Dict[Timeframe, float]:
        """íƒ€ì„í”„ë ˆì„ë³„ ê°€ì¤‘ì¹˜ ê³„ì‚°"""
        weights = {}
        total_weight = 0
        
        for i, tf in enumerate(self.timeframes):
            # ì§§ì€ íƒ€ì„í”„ë ˆì„ì— ë” ë†’ì€ ê°€ì¤‘ì¹˜
            weight = 1.0 / (i + 1)
            weights[tf] = weight
            total_weight += weight
        
        # ì •ê·œí™”
        for tf in weights:
            weights[tf] /= total_weight
        
        return weights
    
    def analyze_multi_timeframe(self, market_data: Dict[Timeframe, Dict]) -> MultiTimeframeSignal:
        """ë©€í‹° íƒ€ì„í”„ë ˆì„ ë¶„ì„"""
        timeframe_signals = {}
        
        # ê° íƒ€ì„í”„ë ˆì„ë³„ ë¶„ì„
        for timeframe in self.timeframes:
            if timeframe in market_data:
                signal = self._analyze_single_timeframe(timeframe, market_data[timeframe])
                if signal:
                    timeframe_signals[timeframe] = signal
        
        if not timeframe_signals:
            return None
        
        # í†µí•© ì‹ í˜¸ ìƒì„±
        overall_signal = self._combine_timeframe_signals(timeframe_signals)
        consistency_score = self._calculate_consistency(timeframe_signals)
        
        return MultiTimeframeSignal(
            overall_signal=overall_signal["signal"],
            overall_strength=overall_signal["strength"],
            overall_confidence=overall_signal["confidence"],
            timeframe_signals=timeframe_signals,
            consistency_score=consistency_score,
            timestamp=datetime.now()
        )
    
    def _analyze_single_timeframe(self, timeframe: Timeframe, data: Dict) -> Optional[TimeframeSignal]:
        """ë‹¨ì¼ íƒ€ì„í”„ë ˆì„ ë¶„ì„"""
        try:
            # ê¸°ë³¸ ì§€í‘œ ê³„ì‚°
            basic_calc = BasicIndicatorCalculator()
            advanced_calc = AdvancedIndicatorCalculator()
            
            indicators = []
            
            # RSI
            if 'close' in data:
                rsi = basic_calc.calculate_rsi(data['close'])
                if rsi:
                    indicators.append(rsi)
            
            # MACD
            if 'close' in data:
                macd_results = basic_calc.calculate_macd(data['close'])
                if macd_results:
                    indicators.extend(macd_results.values())
            
            # ë³¼ë¦°ì € ë°´ë“œ
            if 'close' in data:
                bb_results = basic_calc.calculate_bollinger_bands(data['close'])
                if bb_results:
                    indicators.extend(bb_results.values())
            
            # ì´ë™í‰ê· 
            if 'close' in data:
                ma_results = basic_calc.calculate_moving_averages(data['close'])
                if ma_results:
                    indicators.extend(ma_results.values())
            
            # ì‹ í˜¸ ìƒì„±
            signal = self._generate_signal_from_indicators(indicators)
            
            return TimeframeSignal(
                timeframe=timeframe,
                signal_type=signal["type"],
                strength=signal["strength"],
                confidence=signal["confidence"],
                indicators=indicators,
                timestamp=datetime.now()
            )
            
        except Exception as e:
            logger.error(f"íƒ€ì„í”„ë ˆì„ ë¶„ì„ ì˜¤ë¥˜ {timeframe}: {e}")
            return None
    
    def _generate_signal_from_indicators(self, indicators: List[IndicatorValue]) -> Dict:
        """ì§€í‘œë¡œë¶€í„° ì‹ í˜¸ ìƒì„±"""
        buy_signals = 0
        sell_signals = 0
        total_confidence = 0
        total_indicators = 0
        
        for indicator in indicators:
            if indicator.value is None:
                continue
            
            signal = self._interpret_indicator(indicator)
            if signal == "BUY":
                buy_signals += indicator.confidence
            elif signal == "SELL":
                sell_signals += indicator.confidence
            
            total_confidence += indicator.confidence
            total_indicators += 1
        
        if total_indicators == 0:
            return {"type": "HOLD", "strength": 0.0, "confidence": 0.0}
        
        # ì‹ í˜¸ ê²°ì •
        if buy_signals > sell_signals:
            signal_type = "BUY"
            strength = buy_signals / total_confidence
        elif sell_signals > buy_signals:
            signal_type = "SELL"
            strength = sell_signals / total_confidence
        else:
            signal_type = "HOLD"
            strength = 0.0
        
        confidence = total_confidence / total_indicators
        
        return {
            "type": signal_type,
            "strength": min(1.0, strength),
            "confidence": confidence
        }
    
    def _interpret_indicator(self, indicator: IndicatorValue) -> str:
        """ì§€í‘œ í•´ì„"""
        name = indicator.indicator_name
        value = indicator.value
        
        if name == "RSI":
            if value > 70:
                return "SELL"
            elif value < 30:
                return "BUY"
        elif name == "MACD":
            if value > 0:
                return "BUY"
            else:
                return "SELL"
        elif name.startswith("BB_"):
            if name == "BB_Upper" and value < 0:
                return "SELL"
            elif name == "BB_Lower" and value > 0:
                return "BUY"
        
        return "HOLD"
    
    def _combine_timeframe_signals(self, timeframe_signals: Dict[Timeframe, TimeframeSignal]) -> Dict:
        """íƒ€ì„í”„ë ˆì„ ì‹ í˜¸ ê²°í•©"""
        weighted_buy = 0.0
        weighted_sell = 0.0
        total_weight = 0.0
        total_confidence = 0.0
        
        for timeframe, signal in timeframe_signals.items():
            weight = self.timeframe_weights.get(timeframe, 0.0)
            
            if signal.signal_type == "BUY":
                weighted_buy += signal.strength * weight * signal.confidence
            elif signal.signal_type == "SELL":
                weighted_sell += signal.strength * weight * signal.confidence
            
            total_weight += weight
            total_confidence += signal.confidence
        
        if total_weight == 0:
            return {"signal": "HOLD", "strength": 0.0, "confidence": 0.0}
        
        # ì‹ í˜¸ ê²°ì •
        if weighted_buy > weighted_sell:
            signal_type = "BUY"
            strength = weighted_buy / total_weight
        elif weighted_sell > weighted_buy:
            signal_type = "SELL"
            strength = weighted_sell / total_weight
        else:
            signal_type = "HOLD"
            strength = 0.0
        
        confidence = total_confidence / len(timeframe_signals)
        
        return {
            "signal": signal_type,
            "strength": min(1.0, strength),
            "confidence": confidence
        }
    
    def _calculate_consistency(self, timeframe_signals: Dict[Timeframe, TimeframeSignal]) -> float:
        """ì¼ê´€ì„± ì ìˆ˜ ê³„ì‚°"""
        if len(timeframe_signals) < 2:
            return 1.0
        
        signals = [s.signal_type for s in timeframe_signals.values()]
        
        # ë™ì¼í•œ ì‹ í˜¸ì˜ ë¹„ìœ¨ ê³„ì‚°
        buy_count = signals.count("BUY")
        sell_count = signals.count("SELL")
        hold_count = signals.count("HOLD")
        
        max_count = max(buy_count, sell_count, hold_count)
        consistency = max_count / len(signals)
        
        return consistency
```

## ğŸ”§ **ê³ ê¸‰ íŒ¨í„´ ì¸ì‹ ì‹œìŠ¤í…œ**

### ğŸ“¦ **ìº”ë“¤ìŠ¤í‹± íŒ¨í„´ ì¸ì‹ê¸°**

```python
# technical-analysis/advanced-pattern-recognition/candlestick_pattern_recognizer.py
import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass
from datetime import datetime
import logging
from enum import Enum

logger = logging.getLogger(__name__)

class PatternType(Enum):
    """íŒ¨í„´ íƒ€ì…"""
    BULLISH = "bullish"
    BEARISH = "bearish"
    NEUTRAL = "neutral"
    REVERSAL = "reversal"
    CONTINUATION = "continuation"

class PatternStrength(Enum):
    """íŒ¨í„´ ê°•ë„"""
    WEAK = "weak"
    MODERATE = "moderate"
    STRONG = "strong"
    VERY_STRONG = "very_strong"

@dataclass
class CandlestickPattern:
    """ìº”ë“¤ìŠ¤í‹± íŒ¨í„´"""
    pattern_name: str
    pattern_type: PatternType
    strength: PatternStrength
    confidence: float
    start_index: int
    end_index: int
    description: str
    trading_signal: str
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None

class AdvancedCandlestickPatternRecognizer:
    """ê³ ê¸‰ ìº”ë“¤ìŠ¤í‹± íŒ¨í„´ ì¸ì‹ê¸°"""
    
    def __init__(self):
        self.pattern_definitions = self._load_pattern_definitions()
        self.recognition_threshold = 0.7
    
    def _load_pattern_definitions(self) -> Dict[str, Dict]:
        """íŒ¨í„´ ì •ì˜ ë¡œë“œ"""
        return {
            'doji': {
                'description': 'Doji - ì‹œì¥ ë¶ˆí™•ì‹¤ì„±',
                'type': PatternType.NEUTRAL,
                'conditions': ['body_ratio < 0.1', 'upper_shadow > 0', 'lower_shadow > 0'],
                'signal': 'HOLD',
                'strength': PatternStrength.MODERATE
            },
            'hammer': {
                'description': 'Hammer - ê°•ì„¸ ë°˜ì „ ì‹ í˜¸',
                'type': PatternType.BULLISH,
                'conditions': ['body_ratio < 0.3', 'lower_shadow > 2 * body', 'upper_shadow < 0.1'],
                'signal': 'BUY',
                'strength': PatternStrength.STRONG
            },
            'shooting_star': {
                'description': 'Shooting Star - ì•½ì„¸ ë°˜ì „ ì‹ í˜¸',
                'type': PatternType.BEARISH,
                'conditions': ['body_ratio < 0.3', 'upper_shadow > 2 * body', 'lower_shadow < 0.1'],
                'signal': 'SELL',
                'strength': PatternStrength.STRONG
            },
            'engulfing_bullish': {
                'description': 'Bullish Engulfing - ê°•ì„¸ ë°˜ì „',
                'type': PatternType.BULLISH,
                'conditions': ['prev_body < 0', 'curr_body > 0', 'curr_open < prev_close', 'curr_close > prev_open'],
                'signal': 'BUY',
                'strength': PatternStrength.VERY_STRONG
            },
            'engulfing_bearish': {
                'description': 'Bearish Engulfing - ì•½ì„¸ ë°˜ì „',
                'type': PatternType.BEARISH,
                'conditions': ['prev_body > 0', 'curr_body < 0', 'curr_open > prev_close', 'curr_close < prev_open'],
                'signal': 'SELL',
                'strength': PatternStrength.VERY_STRONG
            }
        }
    
    def recognize_patterns(self, candlestick_data: pd.DataFrame) -> List[CandlestickPattern]:
        """ìº”ë“¤ìŠ¤í‹± íŒ¨í„´ ì¸ì‹"""
        try:
            patterns = []
            
            # ê¸°ë³¸ ìº”ë“¤ìŠ¤í‹± íŠ¹ì„± ê³„ì‚°
            candlestick_features = self._calculate_candlestick_features(candlestick_data)
            
            # ê° íŒ¨í„´ ê²€ì‚¬
            for pattern_name, pattern_def in self.pattern_definitions.items():
                detected_patterns = self._check_pattern(pattern_name, pattern_def, candlestick_features)
                patterns.extend(detected_patterns)
            
            # ì‹ ë¢°ë„ ìˆœìœ¼ë¡œ ì •ë ¬
            patterns.sort(key=lambda x: x.confidence, reverse=True)
            
            return patterns
            
        except Exception as e:
            logger.error(f"íŒ¨í„´ ì¸ì‹ ì˜¤ë¥˜: {e}")
            return []
    
    def _calculate_candlestick_features(self, data: pd.DataFrame) -> pd.DataFrame:
        """ìº”ë“¤ìŠ¤í‹± íŠ¹ì„± ê³„ì‚°"""
        try:
            features = data.copy()
            
            # ê¸°ë³¸ íŠ¹ì„±
            features['body'] = features['close'] - features['open']
            features['body_abs'] = np.abs(features['body'])
            features['upper_shadow'] = features['high'] - np.maximum(features['open'], features['close'])
            features['lower_shadow'] = np.minimum(features['open'], features['close']) - features['low']
            features['total_range'] = features['high'] - features['low']
            
            # ë¹„ìœ¨ íŠ¹ì„±
            features['body_ratio'] = features['body_abs'] / features['total_range']
            features['upper_shadow_ratio'] = features['upper_shadow'] / features['total_range']
            features['lower_shadow_ratio'] = features['lower_shadow'] / features['total_range']
            
            return features
            
        except Exception as e:
            logger.error(f"ìº”ë“¤ìŠ¤í‹± íŠ¹ì„± ê³„ì‚° ì˜¤ë¥˜: {e}")
            return data
```

## ğŸ”§ **í¬ë¡œìŠ¤ ë§ˆì¼“ ë¶„ì„ ì‹œìŠ¤í…œ**

### ğŸ“¦ **í¬ë¡œìŠ¤ ë§ˆì¼“ ë¶„ì„ê¸°**

```python
# technical-analysis/cross-market-analysis/cross_market_analyzer.py
import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass
from datetime import datetime, timedelta
import logging
from scipy import stats
from sklearn.decomposition import PCA
from sklearn.cluster import KMeans

logger = logging.getLogger(__name__)

@dataclass
class MarketCorrelation:
    """ì‹œì¥ ìƒê´€ê´€ê³„"""
    asset1: str
    asset2: str
    correlation: float
    p_value: float
    rolling_correlation: List[float]
    regime_correlation: Dict[str, float]
    timestamp: datetime

@dataclass
class MarketRegime:
    """ì‹œì¥ ì²´ì œ"""
    regime_id: str
    regime_type: str  # 'risk_on', 'risk_off', 'neutral'
    volatility_level: float
    correlation_level: float
    dominant_assets: List[str]
    start_time: datetime
    end_time: Optional[datetime] = None
    confidence: float = 0.0

class CrossMarketAnalyzer:
    """í¬ë¡œìŠ¤ ë§ˆì¼“ ë¶„ì„ê¸°"""
    
    def __init__(self, lookback_period: int = 252):
        self.lookback_period = lookback_period
        self.correlation_matrix = pd.DataFrame()
        self.market_regimes = []
        self.asset_data = {}
    
    def add_asset_data(self, asset: str, data: pd.DataFrame):
        """ìì‚° ë°ì´í„° ì¶”ê°€"""
        try:
            self.asset_data[asset] = data
            logger.info(f"ìì‚° ë°ì´í„° ì¶”ê°€: {asset} - {len(data)}ê°œ ë°ì´í„°")
        except Exception as e:
            logger.error(f"ìì‚° ë°ì´í„° ì¶”ê°€ ì˜¤ë¥˜: {e}")
    
    def calculate_correlations(self) -> pd.DataFrame:
        """ìƒê´€ê´€ê³„ ê³„ì‚°"""
        try:
            # ìˆ˜ìµë¥  ê³„ì‚°
            returns_data = {}
            for asset, data in self.asset_data.items():
                if 'close' in data.columns:
                    returns_data[asset] = data['close'].pct_change().dropna()
            
            # ìƒê´€ê´€ê³„ í–‰ë ¬ ê³„ì‚°
            returns_df = pd.DataFrame(returns_data)
            correlation_matrix = returns_df.corr()
            
            self.correlation_matrix = correlation_matrix
            
            return correlation_matrix
            
        except Exception as e:
            logger.error(f"ìƒê´€ê´€ê³„ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return pd.DataFrame()
    
    def detect_market_regime(self) -> MarketRegime:
        """ì‹œì¥ ì²´ì œ ê°ì§€"""
        try:
            if self.correlation_matrix.empty:
                self.calculate_correlations()
            
            # ì£¼ìš” ìì‚°ë“¤ì˜ ë³€ë™ì„± ê³„ì‚°
            volatilities = {}
            for asset, data in self.asset_data.items():
                if 'close' in data.columns:
                    returns = data['close'].pct_change().dropna()
                    volatilities[asset] = returns.std()
            
            # í‰ê·  ë³€ë™ì„±
            avg_volatility = np.mean(list(volatilities.values()))
            
            # ìƒê´€ê´€ê³„ ìˆ˜ì¤€ ê³„ì‚°
            correlation_level = self._calculate_correlation_level()
            
            # ì²´ì œ ë¶„ë¥˜
            if avg_volatility > 0.02 and correlation_level > 0.7:
                regime_type = 'risk_off'
            elif avg_volatility < 0.01 and correlation_level < 0.3:
                regime_type = 'risk_on'
            else:
                regime_type = 'neutral'
            
            # ì£¼ìš” ìì‚° ì‹ë³„
            dominant_assets = self._identify_dominant_assets()
            
            # ì‹ ë¢°ë„ ê³„ì‚°
            confidence = self._calculate_regime_confidence(avg_volatility, correlation_level)
            
            regime = MarketRegime(
                regime_id=f"regime_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                regime_type=regime_type,
                volatility_level=avg_volatility,
                correlation_level=correlation_level,
                dominant_assets=dominant_assets,
                start_time=datetime.now(),
                confidence=confidence
            )
            
            self.market_regimes.append(regime)
            
            return regime
            
        except Exception as e:
            logger.error(f"ì‹œì¥ ì²´ì œ ê°ì§€ ì˜¤ë¥˜: {e}")
            return None
```

## ğŸ”§ **ì˜µì…˜ ë¶„ì„ ì‹œìŠ¤í…œ**

### ğŸ“¦ **ì˜µì…˜ ë¶„ì„ê¸°**

```python
# technical-analysis/options-analysis/options_analyzer.py
import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass
from datetime import datetime
import logging
from scipy.stats import norm

logger = logging.getLogger(__name__)

@dataclass
class OptionGreeks:
    """ì˜µì…˜ ê·¸ë¦­ìŠ¤"""
    delta: float
    gamma: float
    theta: float
    vega: float
    rho: float
    timestamp: datetime

@dataclass
class OptionChain:
    """ì˜µì…˜ ì²´ì¸"""
    symbol: str
    expiration_date: datetime
    strike_prices: List[float]
    call_options: Dict[float, Dict]
    put_options: Dict[float, Dict]
    implied_volatility: Dict[float, float]
    timestamp: datetime

class OptionsAnalyzer:
    """ì˜µì…˜ ë¶„ì„ê¸°"""
    
    def __init__(self, risk_free_rate: float = 0.02):
        self.risk_free_rate = risk_free_rate
    
    def calculate_black_scholes(self, S: float, K: float, T: float, r: float, 
                              sigma: float, option_type: str = 'call') -> Dict[str, float]:
        """Black-Scholes ì˜µì…˜ ê°€ê²© ê³„ì‚°"""
        try:
            d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
            d2 = d1 - sigma * np.sqrt(T)
            
            if option_type.lower() == 'call':
                price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)
                delta = norm.cdf(d1)
            else:  # put
                price = K * np.exp(-r * T) * norm.cdf(-d2) - S * norm.cdf(-d1)
                delta = norm.cdf(d1) - 1
            
            # ê·¸ë¦­ìŠ¤ ê³„ì‚°
            gamma = norm.pdf(d1) / (S * sigma * np.sqrt(T))
            theta = (-S * norm.pdf(d1) * sigma / (2 * np.sqrt(T)) - 
                    r * K * np.exp(-r * T) * norm.cdf(d2)) if option_type == 'call' else \
                   (-S * norm.pdf(d1) * sigma / (2 * np.sqrt(T)) + 
                    r * K * np.exp(-r * T) * norm.cdf(-d2))
            vega = S * np.sqrt(T) * norm.pdf(d1)
            rho = K * T * np.exp(-r * T) * norm.cdf(d2) if option_type == 'call' else \
                  -K * T * np.exp(-r * T) * norm.cdf(-d2)
            
            return {
                'price': price,
                'delta': delta,
                'gamma': gamma,
                'theta': theta,
                'vega': vega,
                'rho': rho
            }
            
        except Exception as e:
            logger.error(f"Black-Scholes ê³„ì‚° ì˜¤ë¥˜: {e}")
            return {}
    
    def calculate_implied_volatility(self, S: float, K: float, T: float, r: float, 
                                   option_price: float, option_type: str = 'call') -> float:
        """ë‚´ì¬ ë³€ë™ì„± ê³„ì‚°"""
        try:
            def objective(sigma):
                calculated_price = self.calculate_black_scholes(S, K, T, r, sigma, option_type)['price']
                return calculated_price - option_price
            
            # Newton-Raphson ë°©ë²•ìœ¼ë¡œ ë‚´ì¬ ë³€ë™ì„± ê³„ì‚°
            sigma = 0.3  # ì´ˆê¸°ê°’
            tolerance = 1e-5
            max_iterations = 100
            
            for i in range(max_iterations):
                price_diff = objective(sigma)
                if abs(price_diff) < tolerance:
                    break
                
                # Vegaë¡œ ë¯¸ë¶„
                vega = self.calculate_black_scholes(S, K, T, r, sigma, option_type)['vega']
                if abs(vega) < 1e-10:
                    break
                
                sigma = sigma - price_diff / vega
                sigma = max(0.001, min(5.0, sigma))  # ë²”ìœ„ ì œí•œ
            
            return sigma
            
        except Exception as e:
            logger.error(f"ë‚´ì¬ ë³€ë™ì„± ê³„ì‚° ì˜¤ë¥˜: {e}")
            return 0.0
    
    def analyze_option_chain(self, option_chain: OptionChain) -> Dict[str, Any]:
        """ì˜µì…˜ ì²´ì¸ ë¶„ì„"""
        try:
            analysis = {
                'put_call_ratio': 0.0,
                'skew': 0.0,
                'term_structure': {},
                'volatility_smile': {},
                'greeks_summary': {}
            }
            
            # Put-Call ë¹„ìœ¨ ê³„ì‚°
            total_call_volume = sum(opt.get('volume', 0) for opt in option_chain.call_options.values())
            total_put_volume = sum(opt.get('volume', 0) for opt in option_chain.put_options.values())
            
            if total_call_volume > 0:
                analysis['put_call_ratio'] = total_put_volume / total_call_volume
            
            # ë³€ë™ì„± ìŠ¤í ê³„ì‚°
            atm_strike = min(option_chain.strike_prices, key=lambda x: abs(x - option_chain.strike_prices[len(option_chain.strike_prices)//2]))
            
            if atm_strike in option_chain.implied_volatility:
                atm_iv = option_chain.implied_volatility[atm_strike]
                
                # OTM Putê³¼ OTM Callì˜ ë³€ë™ì„± ì°¨ì´
                otm_puts = [iv for strike, iv in option_chain.implied_volatility.items() 
                           if strike < atm_strike and strike in option_chain.put_options]
                otm_calls = [iv for strike, iv in option_chain.implied_volatility.items() 
                            if strike > atm_strike and strike in option_chain.call_options]
                
                if otm_puts and otm_calls:
                    avg_put_iv = np.mean(otm_puts)
                    avg_call_iv = np.mean(otm_calls)
                    analysis['skew'] = avg_put_iv - avg_call_iv
            
            return analysis
            
        except Exception as e:
            logger.error(f"ì˜µì…˜ ì²´ì¸ ë¶„ì„ ì˜¤ë¥˜: {e}")
            return {}
```

## ğŸ“Š **ì„±ê³¼ ì§€í‘œ**

### **ëª©í‘œ ì„±ê³¼**
- **ì§€í‘œ ì •í™•ë„**: 70% ì´ìƒ
- **ì‹ í˜¸ ì •í™•ë„**: 65% ì´ìƒ
- **ë©€í‹° íƒ€ì„í”„ë ˆì„ ì¼ê´€ì„±**: 80% ì´ìƒ
- **íŒ¨í„´ ì¸ì‹ ì •í™•ë„**: > 85% íŒ¨í„´ ê°ì§€ ì •í™•ë„
- **ìƒê´€ê´€ê³„ ë¶„ì„**: < 100ms í¬ë¡œìŠ¤ ì—ì…‹ ë¶„ì„
- **ì˜µì…˜ ë¶„ì„**: < 500ms ê·¸ë¦­ìŠ¤ ê³„ì‚°
- **ì‹¤ì‹œê°„ ì²˜ë¦¬**: < 100ms
- **ë©”ëª¨ë¦¬ íš¨ìœ¨ì„±**: < 500MB

### **ì„±ëŠ¥ ì§€í‘œ**
- **ì§€í‘œ ê³„ì‚° ì‹œê°„**: < 10ms per indicator
- **ë©€í‹° íƒ€ì„í”„ë ˆì„ ë¶„ì„**: < 50ms
- **ì‹ í˜¸ ìƒì„± ì‹œê°„**: < 100ms
- **ìºì‹œ íˆíŠ¸ìœ¨**: > 90%
- **ì‹œìŠ¤í…œ ê°€ë™ë¥ **: > 99.5%

## ğŸ”— **ê´€ë ¨ ë¬¸ì„œ**

- [Phase 3.5.2: ì „ëµ ë¼ì´ë¸ŒëŸ¬ë¦¬](3.5.2_TRADING_STRATEGIES.md)
- [Phase 3.5.3: ë‰´ìŠ¤ ì´ë²¤íŠ¸ ë¶„ì„](3.5.3_NEWS_EVENT_ANALYSIS.md)
- [Phase 3.5.4: ì˜¨ë¼ì¸ í•™ìŠµ](3.5.4_ONLINE_LEARNING.md)
- [Phase 3.5.5: ì„¤ëª… ê°€ëŠ¥í•œ AI](3.5.5_EXPLAINABLE_AI.md)

## ğŸ”§ **ìƒˆë¡œìš´ ëª¨ë“ˆ êµ¬í˜„ ì½”ë“œ**

### ğŸ“Š **í¬íŠ¸í´ë¦¬ì˜¤ ë¶„ì„ ì‹œìŠ¤í…œ**

```python
# technical-analysis/portfolio-analysis/portfolio_analyzer.py
import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass
from datetime import datetime, timedelta
import logging

logger = logging.getLogger(__name__)

@dataclass
class AssetPerformance:
    """ìì‚°ë³„ ì„±ê³¼ ë°ì´í„°"""
    asset_id: str
    returns: List[float]
    volatility: float
    sharpe_ratio: float
    max_drawdown: float
    beta: float
    alpha: float

class PortfolioAnalyzer:
    """í¬íŠ¸í´ë¦¬ì˜¤ ë¶„ì„ê¸°"""
    
    def __init__(self):
        self.risk_free_rate = 0.02  # 2% ë¬´ìœ„í—˜ ìˆ˜ìµë¥ 
        
    def analyze_asset_performance(self, asset_data: Dict[str, List[float]]) -> Dict[str, AssetPerformance]:
        """ìì‚°ë³„ ì„±ê³¼ ë¶„ì„"""
        results = {}
        
        for asset_id, prices in asset_data.items():
            if len(prices) < 2:
                continue
                
            # ìˆ˜ìµë¥  ê³„ì‚°
            returns = np.diff(prices) / prices[:-1]
            
            # ê¸°ë³¸ í†µê³„
            avg_return = np.mean(returns)
            volatility = np.std(returns)
            
            # ìƒ¤í”„ ë¹„ìœ¨
            sharpe_ratio = (avg_return - self.risk_free_rate) / volatility if volatility > 0 else 0
            
            # ìµœëŒ€ ë‚™í­
            cumulative_returns = np.cumprod(1 + returns)
            running_max = np.maximum.accumulate(cumulative_returns)
            drawdown = (cumulative_returns - running_max) / running_max
            max_drawdown = np.min(drawdown)
            
            # ë² íƒ€ ê³„ì‚° (ì‹œì¥ ëŒ€ë¹„)
            market_returns = self._get_market_returns()
            if len(market_returns) == len(returns):
                beta = np.cov(returns, market_returns)[0, 1] / np.var(market_returns)
                alpha = avg_return - (self.risk_free_rate + beta * (np.mean(market_returns) - self.risk_free_rate))
            else:
                beta = alpha = 0
            
            results[asset_id] = AssetPerformance(
                asset_id=asset_id,
                returns=returns.tolist(),
                volatility=volatility,
                sharpe_ratio=sharpe_ratio,
                max_drawdown=max_drawdown,
                beta=beta,
                alpha=alpha
            )
        
        return results
    
    def risk_decomposition(self, portfolio_weights: Dict[str, float], 
                          asset_covariance: np.ndarray) -> Dict[str, float]:
        """ë¦¬ìŠ¤í¬ ë¶„í•´"""
        try:
            weights = np.array(list(portfolio_weights.values()))
            
            # í¬íŠ¸í´ë¦¬ì˜¤ ë³€ë™ì„±
            portfolio_vol = np.sqrt(weights.T @ asset_covariance @ weights)
            
            # ê° ìì‚°ì˜ ê¸°ì—¬ë„
            marginal_contrib = asset_covariance @ weights
            risk_contrib = weights * marginal_contrib / portfolio_vol
            
            return {
                'portfolio_volatility': portfolio_vol,
                'risk_contributions': dict(zip(portfolio_weights.keys(), risk_contrib))
            }
            
        except Exception as e:
            logger.error(f"ë¦¬ìŠ¤í¬ ë¶„í•´ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return {}
    
    def _get_market_returns(self) -> np.ndarray:
        """ì‹œì¥ ìˆ˜ìµë¥  (ì˜ˆì‹œ)"""
        # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ì‹œì¥ ì§€ìˆ˜ ë°ì´í„° ì‚¬ìš©
        return np.random.normal(0.001, 0.02, 100)
```

### ğŸ§  **ì‹œì¥ ì‹¬ë¦¬ ë¶„ì„ ì‹œìŠ¤í…œ**

```python
# technical-analysis/market-sentiment-analysis/market_sentiment_analyzer.py
import numpy as np
import pandas as pd
from typing import Dict, List, Optional
from dataclasses import dataclass
import logging

logger = logging.getLogger(__name__)

@dataclass
class FearGreedData:
    """Fear & Greed Index ë°ì´í„°"""
    value: float
    classification: str
    components: Dict[str, float]
    timestamp: datetime

class MarketSentimentAnalyzer:
    """ì‹œì¥ ì‹¬ë¦¬ ë¶„ì„ê¸°"""
    
    def __init__(self):
        self.fear_greed_thresholds = {
            'extreme_fear': 25,
            'fear': 45,
            'neutral': 55,
            'greed': 75,
            'extreme_greed': 100
        }
    
    def calculate_fear_greed_index(self, market_data: Dict[str, float]) -> FearGreedData:
        """Fear & Greed Index ê³„ì‚°"""
        try:
            components = {}
            
            # ë³€ë™ì„± (25%)
            volatility = market_data.get('volatility', 0)
            vol_score = max(0, 100 - (volatility * 100))
            components['volatility'] = vol_score * 0.25
            
            # ì‹œì¥ ëª¨ë©˜í…€ (25%)
            momentum = market_data.get('momentum', 0)
            mom_score = 50 + (momentum * 50)
            components['momentum'] = mom_score * 0.25
            
            # ê±°ë˜ëŸ‰ (20%)
            volume = market_data.get('volume_ratio', 1.0)
            vol_ratio_score = min(100, volume * 50)
            components['volume'] = vol_ratio_score * 0.20
            
            # ì‹œì¥ ê°•ë„ (15%)
            strength = market_data.get('market_strength', 0)
            strength_score = 50 + (strength * 50)
            components['strength'] = strength_score * 0.15
            
            # ì•ˆì „ìì‚° ì„ í˜¸ë„ (15%)
            safe_haven = market_data.get('safe_haven_demand', 0)
            safe_score = 100 - (safe_haven * 100)
            components['safe_haven'] = safe_score * 0.15
            
            # ì´ì  ê³„ì‚°
            total_score = sum(components.values())
            
            # ë¶„ë¥˜
            classification = self._classify_fear_greed(total_score)
            
            return FearGreedData(
                value=total_score,
                classification=classification,
                components=components,
                timestamp=datetime.now()
            )
            
        except Exception as e:
            logger.error(f"Fear & Greed Index ê³„ì‚° ì˜¤ë¥˜: {e}")
            return FearGreedData(50, 'neutral', {}, datetime.now())
    
    def calculate_vix_equivalent(self, price_data: List[float], window: int = 30) -> float:
        """VIX ë“±ê°€ ì§€ìˆ˜ ê³„ì‚°"""
        try:
            if len(price_data) < window + 1:
                return 0.0
            
            # ë¡œê·¸ ìˆ˜ìµë¥  ê³„ì‚°
            returns = np.log(np.array(price_data[1:]) / np.array(price_data[:-1]))
            
            # ë³€ë™ì„± ê³„ì‚° (30ì¼)
            volatility = np.std(returns[-window:]) * np.sqrt(252)  # ì—°ìœ¨í™”
            
            # VIX ë“±ê°€ (ë³€ë™ì„± * 100)
            vix_equivalent = volatility * 100
            
            return vix_equivalent
            
        except Exception as e:
            logger.error(f"VIX ë“±ê°€ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return 0.0
    
    def detect_market_regime(self, market_data: Dict[str, float]) -> str:
        """ì‹œì¥ ì²´ì œ ê°ì§€"""
        try:
            volatility = market_data.get('volatility', 0)
            trend = market_data.get('trend', 0)
            volume = market_data.get('volume_ratio', 1.0)
            
            # ë³€ë™ì„± ê¸°ë°˜ ì²´ì œ ë¶„ë¥˜
            if volatility > 0.03:  # 3% ì´ìƒ
                if trend > 0:
                    return 'high_volatility_bull'
                else:
                    return 'high_volatility_bear'
            elif volatility < 0.01:  # 1% ë¯¸ë§Œ
                if volume < 0.8:
                    return 'low_volatility_sideways'
                else:
                    return 'low_volatility_trending'
            else:
                if abs(trend) > 0.01:
                    return 'moderate_volatility_trending'
                else:
                    return 'moderate_volatility_sideways'
                    
        except Exception as e:
            logger.error(f"ì‹œì¥ ì²´ì œ ê°ì§€ ì˜¤ë¥˜: {e}")
            return 'unknown'
    
    def _classify_fear_greed(self, score: float) -> str:
        """Fear & Greed ë¶„ë¥˜"""
        if score <= self.fear_greed_thresholds['extreme_fear']:
            return 'extreme_fear'
        elif score <= self.fear_greed_thresholds['fear']:
            return 'fear'
        elif score <= self.fear_greed_thresholds['neutral']:
            return 'neutral'
        elif score <= self.fear_greed_thresholds['greed']:
            return 'greed'
        else:
            return 'extreme_greed'
```

### ğŸ“ˆ **ê±°ë˜ëŸ‰ ë¶„ì„ ì‹œìŠ¤í…œ**

```python
# technical-analysis/volume-analysis/volume_analyzer.py
import numpy as np
import pandas as pd
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
import logging

logger = logging.getLogger(__name__)

@dataclass
class VolumeProfile:
    """ê±°ë˜ëŸ‰ í”„ë¡œíŒŒì¼"""
    price_levels: List[float]
    volume_at_price: List[float]
    poc_price: float  # Point of Control
    value_areas: List[Tuple[float, float]]

class VolumeAnalyzer:
    """ê±°ë˜ëŸ‰ ë¶„ì„ê¸°"""
    
    def __init__(self):
        self.volume_profile_bins = 100
        
    def calculate_volume_profile(self, price_data: List[float], 
                               volume_data: List[float]) -> VolumeProfile:
        """ê±°ë˜ëŸ‰ í”„ë¡œíŒŒì¼ ê³„ì‚°"""
        try:
            if len(price_data) != len(volume_data):
                raise ValueError("ê°€ê²©ê³¼ ê±°ë˜ëŸ‰ ë°ì´í„° ê¸¸ì´ê°€ ë‹¤ë¦„")
            
            # ê°€ê²© ë²”ìœ„ ë¶„í• 
            min_price = min(price_data)
            max_price = max(price_data)
            price_range = max_price - min_price
            
            if price_range == 0:
                return VolumeProfile([], [], 0, [])
            
            bin_size = price_range / self.volume_profile_bins
            price_levels = [min_price + i * bin_size for i in range(self.volume_profile_bins + 1)]
            
            # ê° ê°€ê²© ë ˆë²¨ë³„ ê±°ë˜ëŸ‰ ì§‘ê³„
            volume_at_price = [0.0] * len(price_levels)
            
            for price, volume in zip(price_data, volume_data):
                bin_index = min(int((price - min_price) / bin_size), len(price_levels) - 1)
                volume_at_price[bin_index] += volume
            
            # Point of Control (ê°€ì¥ ê±°ë˜ëŸ‰ì´ ë§ì€ ê°€ê²©)
            poc_index = np.argmax(volume_at_price)
            poc_price = price_levels[poc_index]
            
            # Value Areas (ì´ ê±°ë˜ëŸ‰ì˜ 70%ë¥¼ í¬í•¨í•˜ëŠ” ì˜ì—­)
            total_volume = sum(volume_at_price)
            target_volume = total_volume * 0.7
            
            # POCì—ì„œ ì‹œì‘í•˜ì—¬ ì–‘ë°©í–¥ìœ¼ë¡œ í™•ì¥
            current_volume = volume_at_price[poc_index]
            left_index = poc_index
            right_index = poc_index
            
            while current_volume < target_volume and (left_index > 0 or right_index < len(volume_at_price) - 1):
                left_volume = volume_at_price[left_index - 1] if left_index > 0 else 0
                right_volume = volume_at_price[right_index + 1] if right_index < len(volume_at_price) - 1 else 0
                
                if left_volume > right_volume and left_index > 0:
                    left_index -= 1
                    current_volume += left_volume
                elif right_index < len(volume_at_price) - 1:
                    right_index += 1
                    current_volume += right_volume
                else:
                    break
            
            value_areas = [(price_levels[left_index], price_levels[right_index])]
            
            return VolumeProfile(
                price_levels=price_levels,
                volume_at_price=volume_at_price,
                poc_price=poc_price,
                value_areas=value_areas
            )
            
        except Exception as e:
            logger.error(f"ê±°ë˜ëŸ‰ í”„ë¡œíŒŒì¼ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return VolumeProfile([], [], 0, [])
    
    def calculate_obv(self, price_data: List[float], volume_data: List[float]) -> List[float]:
        """On-Balance Volume (OBV) ê³„ì‚°"""
        try:
            if len(price_data) != len(volume_data):
                raise ValueError("ê°€ê²©ê³¼ ê±°ë˜ëŸ‰ ë°ì´í„° ê¸¸ì´ê°€ ë‹¤ë¦„")
            
            obv = [0.0]
            
            for i in range(1, len(price_data)):
                if price_data[i] > price_data[i-1]:
                    obv.append(obv[-1] + volume_data[i])
                elif price_data[i] < price_data[i-1]:
                    obv.append(obv[-1] - volume_data[i])
                else:
                    obv.append(obv[-1])
            
            return obv
            
        except Exception as e:
            logger.error(f"OBV ê³„ì‚° ì˜¤ë¥˜: {e}")
            return [0.0] * len(price_data)
    
    def calculate_volume_weighted_average(self, price_data: List[float], 
                                        volume_data: List[float], 
                                        window: int = 20) -> List[float]:
        """ê±°ë˜ëŸ‰ ê°€ì¤‘ í‰ê·  ê³„ì‚°"""
        try:
            if len(price_data) != len(volume_data):
                raise ValueError("ê°€ê²©ê³¼ ê±°ë˜ëŸ‰ ë°ì´í„° ê¸¸ì´ê°€ ë‹¤ë¦„")
            
            vwa = []
            
            for i in range(len(price_data)):
                start_idx = max(0, i - window + 1)
                end_idx = i + 1
                
                window_prices = price_data[start_idx:end_idx]
                window_volumes = volume_data[start_idx:end_idx]
                
                if sum(window_volumes) > 0:
                    vwa_value = sum(p * v for p, v in zip(window_prices, window_volumes)) / sum(window_volumes)
                else:
                    vwa_value = price_data[i]
                
                vwa.append(vwa_value)
            
            return vwa
            
        except Exception as e:
            logger.error(f"ê±°ë˜ëŸ‰ ê°€ì¤‘ í‰ê·  ê³„ì‚° ì˜¤ë¥˜: {e}")
            return price_data.copy()
    
    def detect_volume_patterns(self, volume_data: List[float], 
                             price_data: List[float]) -> Dict[str, bool]:
        """ê±°ë˜ëŸ‰ íŒ¨í„´ ê°ì§€"""
        try:
            patterns = {
                'volume_spike': False,
                'volume_dry_up': False,
                'price_volume_divergence': False,
                'accumulation': False,
                'distribution': False
            }
            
            if len(volume_data) < 20:
                return patterns
            
            # ê±°ë˜ëŸ‰ ìŠ¤íŒŒì´í¬ ê°ì§€
            avg_volume = np.mean(volume_data[-20:])
            current_volume = volume_data[-1]
            if current_volume > avg_volume * 2:
                patterns['volume_spike'] = True
            
            # ê±°ë˜ëŸ‰ ê³ ê°ˆ ê°ì§€
            if current_volume < avg_volume * 0.5:
                patterns['volume_dry_up'] = True
            
            # ê°€ê²©-ê±°ë˜ëŸ‰ ê´´ë¦¬ ê°ì§€
            if len(price_data) >= 10:
                price_trend = price_data[-1] - price_data[-10]
                volume_trend = volume_data[-1] - volume_data[-10]
                
                if (price_trend > 0 and volume_trend < 0) or (price_trend < 0 and volume_trend > 0):
                    patterns['price_volume_divergence'] = True
            
            # ëˆ„ì /ë¶„ì‚° íŒ¨í„´ ê°ì§€
            if len(price_data) >= 20:
                recent_prices = price_data[-20:]
                recent_volumes = volume_data[-20:]
                
                price_trend = recent_prices[-1] - recent_prices[0]
                volume_trend = np.mean(recent_volumes[-5:]) - np.mean(recent_volumes[:5])
                
                if price_trend > 0 and volume_trend > 0:
                    patterns['accumulation'] = True
                elif price_trend < 0 and volume_trend > 0:
                    patterns['distribution'] = True
            
            return patterns
            
        except Exception as e:
            logger.error(f"ê±°ë˜ëŸ‰ íŒ¨í„´ ê°ì§€ ì˜¤ë¥˜: {e}")
            return {'volume_spike': False, 'volume_dry_up': False, 
                   'price_volume_divergence': False, 'accumulation': False, 'distribution': False}
```

### ğŸ¯ **ìë™ ì§€ì§€/ì €í•­ ì‹œìŠ¤í…œ**

```python
# technical-analysis/support-resistance/support_resistance_detector.py
import numpy as np
import pandas as pd
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
import logging

logger = logging.getLogger(__name__)

@dataclass
class SupportResistanceLevel:
    """ì§€ì§€/ì €í•­ ë ˆë²¨"""
    price: float
    strength: float
    type: str  # 'support' or 'resistance'
    confidence: float
    touches: int
    last_touch: datetime

class SupportResistanceDetector:
    """ìë™ ì§€ì§€/ì €í•­ ê°ì§€ê¸°"""
    
    def __init__(self):
        self.min_touches = 2
        self.touch_tolerance = 0.002  # 0.2% í„°ì¹˜ í—ˆìš© ì˜¤ì°¨
        self.strength_threshold = 0.6
        
    def calculate_fibonacci_levels(self, high: float, low: float) -> Dict[str, float]:
        """í”¼ë³´ë‚˜ì¹˜ ë ˆë²¨ ê³„ì‚°"""
        try:
            diff = high - low
            
            levels = {
                '0.0': low,
                '0.236': low + 0.236 * diff,
                '0.382': low + 0.382 * diff,
                '0.5': low + 0.5 * diff,
                '0.618': low + 0.618 * diff,
                '0.786': low + 0.786 * diff,
                '1.0': high,
                '1.272': high + 0.272 * diff,
                '1.618': high + 0.618 * diff
            }
            
            return levels
            
        except Exception as e:
            logger.error(f"í”¼ë³´ë‚˜ì¹˜ ë ˆë²¨ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return {}
    
    def calculate_pivot_points(self, high: float, low: float, close: float) -> Dict[str, float]:
        """Pivot Points ê³„ì‚°"""
        try:
            pivot = (high + low + close) / 3
            
            r1 = 2 * pivot - low
            r2 = pivot + (high - low)
            r3 = high + 2 * (pivot - low)
            
            s1 = 2 * pivot - high
            s2 = pivot - (high - low)
            s3 = low - 2 * (high - pivot)
            
            return {
                'pivot': pivot,
                'r1': r1, 'r2': r2, 'r3': r3,
                's1': s1, 's2': s2, 's3': s3
            }
            
        except Exception as e:
            logger.error(f"Pivot Points ê³„ì‚° ì˜¤ë¥˜: {e}")
            return {}
    
    def detect_automatic_levels(self, price_data: List[float], 
                              volume_data: Optional[List[float]] = None) -> List[SupportResistanceLevel]:
        """ìë™ ì§€ì§€/ì €í•­ ë ˆë²¨ ê°ì§€"""
        try:
            levels = []
            
            if len(price_data) < 50:
                return levels
            
            # ê³ ì ê³¼ ì €ì  ì°¾ê¸°
            highs = self._find_peaks(price_data, 'high')
            lows = self._find_peaks(price_data, 'low')
            
            # ì €í•­ ë ˆë²¨ (ê³ ì  ê¸°ë°˜)
            resistance_levels = self._cluster_levels(highs, 'resistance')
            for level in resistance_levels:
                levels.append(level)
            
            # ì§€ì§€ ë ˆë²¨ (ì €ì  ê¸°ë°˜)
            support_levels = self._cluster_levels(lows, 'support')
            for level in support_levels:
                levels.append(level)
            
            # ê±°ë˜ëŸ‰ ê°€ì¤‘ ë ˆë²¨ (ê±°ë˜ëŸ‰ ë°ì´í„°ê°€ ìˆëŠ” ê²½ìš°)
            if volume_data and len(volume_data) == len(price_data):
                volume_levels = self._detect_volume_based_levels(price_data, volume_data)
                levels.extend(volume_levels)
            
            # ê°•ë„ë³„ ì •ë ¬
            levels.sort(key=lambda x: x.strength, reverse=True)
            
            return levels
            
        except Exception as e:
            logger.error(f"ìë™ ë ˆë²¨ ê°ì§€ ì˜¤ë¥˜: {e}")
            return []
    
    def _find_peaks(self, data: List[float], peak_type: str) -> List[Tuple[int, float]]:
        """ê³ ì /ì €ì  ì°¾ê¸°"""
        peaks = []
        window = 5
        
        for i in range(window, len(data) - window):
            if peak_type == 'high':
                if all(data[i] >= data[j] for j in range(i - window, i + window + 1)):
                    peaks.append((i, data[i]))
            else:  # low
                if all(data[i] <= data[j] for j in range(i - window, i + window + 1)):
                    peaks.append((i, data[i]))
        
        return peaks
    
    def _cluster_levels(self, peaks: List[Tuple[int, float]], level_type: str) -> List[SupportResistanceLevel]:
        """ë ˆë²¨ í´ëŸ¬ìŠ¤í„°ë§"""
        levels = []
        
        if not peaks:
            return levels
        
        # ê°€ê²©ë³„ ê·¸ë£¹í•‘
        price_groups = {}
        for idx, price in peaks:
            grouped = False
            for group_price in price_groups.keys():
                if abs(price - group_price) / group_price < self.touch_tolerance:
                    price_groups[group_price].append((idx, price))
                    grouped = True
                    break
            
            if not grouped:
                price_groups[price] = [(idx, price)]
        
        # ê° ê·¸ë£¹ì—ì„œ ë ˆë²¨ ìƒì„±
        for group_price, touches in price_groups.items():
            if len(touches) >= self.min_touches:
                avg_price = np.mean([price for _, price in touches])
                strength = len(touches) / 10  # í„°ì¹˜ íšŸìˆ˜ ê¸°ë°˜ ê°•ë„
                confidence = min(1.0, strength / self.strength_threshold)
                
                levels.append(SupportResistanceLevel(
                    price=avg_price,
                    strength=strength,
                    type=level_type,
                    confidence=confidence,
                    touches=len(touches),
                    last_touch=datetime.now()  # ì‹¤ì œë¡œëŠ” íƒ€ì„ìŠ¤íƒ¬í”„ ì‚¬ìš©
                ))
        
        return levels
    
    def _detect_volume_based_levels(self, price_data: List[float], 
                                  volume_data: List[float]) -> List[SupportResistanceLevel]:
        """ê±°ë˜ëŸ‰ ê¸°ë°˜ ë ˆë²¨ ê°ì§€"""
        levels = []
        
        # ê±°ë˜ëŸ‰ì´ ë†’ì€ ê°€ê²©ëŒ€ ì°¾ê¸°
        volume_threshold = np.percentile(volume_data, 80)
        
        for i, (price, volume) in enumerate(zip(price_data, volume_data)):
            if volume > volume_threshold:
                # ì´ë¯¸ ê°ì§€ëœ ë ˆë²¨ê³¼ ë¹„êµ
                is_new_level = True
                for level in levels:
                    if abs(price - level.price) / level.price < self.touch_tolerance:
                        level.touches += 1
                        level.strength = min(1.0, level.touches / 5)
                        is_new_level = False
                        break
                
                if is_new_level:
                    levels.append(SupportResistanceLevel(
                        price=price,
                        strength=0.5,
                        type='volume_based',
                        confidence=0.7,
                        touches=1,
                        last_touch=datetime.now()
                    ))
        
        return levels
```

---

**ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸**: 2025-01-26  
**í”„ë¡œì íŠ¸ ìƒíƒœ**: ì„¤ê³„ ì™„ë£Œ, ê°œë°œ ì¤€ë¹„  
**ë‹¤ìŒ ë‹¨ê³„**: ê¸°ë³¸ ì§€í‘œ ê³„ì‚°ê¸° êµ¬í˜„ ì‹œì‘ 