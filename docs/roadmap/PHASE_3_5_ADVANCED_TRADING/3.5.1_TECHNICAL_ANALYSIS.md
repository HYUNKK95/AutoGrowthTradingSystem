# 📊 Phase 3.5.1: 기술적 지표 분석 시스템 (기본 + 고급 통합)

## 📋 **개요**

### 🎯 **목표**
- **기본 지표**: RSI, MACD, Bollinger Bands, Moving Averages 등 20+ 지표
- **고급 지표**: Stochastic, Williams %R, ATR, Ichimoku 등 고급 지표
- **포트폴리오 분석**: 자산별 성과 분석, 리스크 분해
- **시장 심리 분석**: Fear & Greed Index, 변동성 지표(VIX, ATR)
- **거래량 분석**: Volume Profile, OBV, 거래량 가중 평균
- **자동 지지/저항**: 피보나치 레벨, Pivot Points, 자동 레벨 감지
- **고급 패턴 인식**: 헤드앤숄더, 더블탑/바텀, 피보나치 패턴
- **다중 시장 상관관계**: 크로스 에셋, 크로스 마켓 분석
- **실시간 옵션 분석**: 옵션 체인, 그릭스 분석
- **멀티 타임프레임**: 1분~월봉 통합 분석
- **지표 조합**: 다중 지표 신호 통합 및 가중치 적용
- **실시간 계산**: < 10ms 지표 업데이트

### 📊 **성능 목표**
- **지표 계산 속도**: < 10ms per indicator
- **멀티 타임프레임**: < 50ms 통합 분석
- **신호 생성**: < 100ms 신호 생성
- **패턴 인식 정확도**: > 85% 패턴 감지 정확도
- **상관관계 분석**: < 100ms 크로스 에셋 분석
- **옵션 분석**: < 500ms 그릭스 계산
- **메모리 사용량**: < 500MB
- **정확도**: > 70% 신호 정확도

## 🏗️ **기술적 지표 분석 시스템 아키텍처**

### 📁 **시스템 구조**
```
technical-analysis/
├── basic-indicators/                   # 기본 지표
│   ├── trend-indicators/              # 트렌드 지표
│   ├── momentum-indicators/           # 모멘텀 지표
│   ├── volatility-indicators/         # 변동성 지표
│   └── volume-indicators/             # 거래량 지표
├── advanced-indicators/                # 고급 지표
│   ├── oscillator-indicators/         # 오실레이터 지표
│   ├── custom-indicators/             # 커스텀 지표
│   ├── composite-indicators/          # 복합 지표
│   └── pattern-indicators/            # 패턴 지표
├── portfolio-analysis/                 # 포트폴리오 분석
│   ├── asset-performance/             # 자산별 성과 분석
│   ├── risk-decomposition/            # 리스크 분해
│   ├── correlation-analysis/          # 상관관계 분석
│   └── portfolio-optimization/        # 포트폴리오 최적화
├── market-sentiment-analysis/          # 시장 심리 분석
│   ├── fear-greed-index/              # Fear & Greed Index
│   ├── volatility-indicators/         # 변동성 지표 (VIX, ATR)
│   ├── market-regime-detection/       # 시장 체제 감지
│   └── sentiment-aggregation/         # 심리 지표 집계
├── volume-analysis/                    # 거래량 분석
│   ├── volume-profile/                # Volume Profile
│   ├── obv-analysis/                  # OBV 분석
│   ├── volume-weighted-averages/      # 거래량 가중 평균
│   └── volume-patterns/               # 거래량 패턴
├── support-resistance/                 # 자동 지지/저항
│   ├── fibonacci-levels/              # 피보나치 레벨
│   ├── pivot-points/                  # Pivot Points
│   ├── automatic-level-detection/     # 자동 레벨 감지
│   └── dynamic-levels/                # 동적 레벨
├── multi-timeframe/                    # 멀티 타임프레임
│   ├── timeframe-manager/             # 타임프레임 관리
│   ├── signal-aggregator/             # 신호 집계
│   ├── weight-calculator/             # 가중치 계산
│   └── consistency-checker/           # 일관성 검사
├── signal-generation/                  # 신호 생성
│   ├── signal-combiner/               # 신호 결합
│   ├── confidence-calculator/         # 신뢰도 계산
│   ├── threshold-manager/             # 임계값 관리
│   └── alert-system/                  # 알림 시스템
├── performance-optimization/           # 성능 최적화
    ├── caching-system/                # 캐싱 시스템
    ├── parallel-processing/           # 병렬 처리
    ├── memory-management/             # 메모리 관리
    └── latency-monitoring/            # 지연 모니터링
├── advanced-pattern-recognition/       # 고급 패턴 인식
    ├── candlestick-patterns/          # 캔들스틱 패턴
    ├── chart-patterns/                # 차트 패턴 (헤드앤숄더, 더블탑/바텀)
    ├── fibonacci-patterns/            # 피보나치 패턴
    ├── harmonic-patterns/             # 하모닉 패턴
    └── elliott-waves/                 # 엘리엇 웨이브
├── cross-market-analysis/              # 크로스 마켓 분석
    ├── asset-correlation/             # 자산 상관관계
    ├── market-regime-detection/       # 시장 체제 감지
    ├── sector-rotation/               # 섹터 로테이션
    └── global-macro-analysis/         # 글로벌 매크로
└── options-analysis/                   # 옵션 분석
    ├── options-chain-analysis/        # 옵션 체인 분석
    ├── greeks-calculator/             # 그릭스 계산기
    ├── implied-volatility/            # 내재 변동성
    └── options-strategies/            # 옵션 전략
```

## 🔧 **기본 기술적 지표 시스템**

### 📦 **기본 지표 계산기**

```python
# technical-analysis/basic-indicators/basic_indicator_calculator.py
import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional, Union
from dataclasses import dataclass
from datetime import datetime
import logging
from enum import Enum

logger = logging.getLogger(__name__)

class IndicatorType(Enum):
    """지표 타입"""
    TREND = "trend"
    MOMENTUM = "momentum"
    VOLATILITY = "volatility"
    VOLUME = "volume"
    OSCILLATOR = "oscillator"

@dataclass
class IndicatorValue:
    """지표 값"""
    indicator_name: str
    value: float
    timestamp: datetime
    confidence: float = 0.0
    metadata: Dict[str, any] = None

@dataclass
class TechnicalSignal:
    """기술적 신호"""
    signal_type: str  # 'BUY', 'SELL', 'HOLD'
    strength: float   # 0.0 ~ 1.0
    confidence: float # 0.0 ~ 1.0
    indicators: List[IndicatorValue]
    timestamp: datetime
    timeframe: str

class BasicIndicatorCalculator:
    """기본 기술적 지표 계산기"""
    
    def __init__(self):
        self.cache = {}
        self.calculation_history = []
    
    def calculate_rsi(self, prices: List[float], period: int = 14) -> IndicatorValue:
        """RSI (Relative Strength Index) 계산"""
        if len(prices) < period + 1:
            return None
        
        # 캐시 확인
        cache_key = f"rsi_{period}_{hash(tuple(prices[-period-1:]))}"
        if cache_key in self.cache:
            return self.cache[cache_key]
        
        try:
            # 가격 변화 계산
            deltas = np.diff(prices)
            gains = np.where(deltas > 0, deltas, 0)
            losses = np.where(deltas < 0, -deltas, 0)
            
            # 평균 계산
            avg_gains = np.mean(gains[-period:])
            avg_losses = np.mean(losses[-period:])
            
            if avg_losses == 0:
                rsi = 100
            else:
                rs = avg_gains / avg_losses
                rsi = 100 - (100 / (1 + rs))
            
            # 신뢰도 계산 (데이터 품질 기반)
            confidence = min(1.0, len(prices) / (period * 2))
            
            result = IndicatorValue(
                indicator_name="RSI",
                value=rsi,
                timestamp=datetime.now(),
                confidence=confidence,
                metadata={"period": period, "method": "standard"}
            )
            
            # 캐시 저장
            self.cache[cache_key] = result
            return result
            
        except Exception as e:
            logger.error(f"RSI 계산 오류: {e}")
            return None
    
    def calculate_macd(self, prices: List[float], 
                      fast_period: int = 12, 
                      slow_period: int = 26, 
                      signal_period: int = 9) -> Dict[str, IndicatorValue]:
        """MACD (Moving Average Convergence Divergence) 계산"""
        if len(prices) < slow_period + signal_period:
            return None
        
        try:
            # EMA 계산
            ema_fast = self._calculate_ema(prices, fast_period)
            ema_slow = self._calculate_ema(prices, slow_period)
            
            # MACD 라인
            macd_line = ema_fast - ema_slow
            
            # 시그널 라인
            macd_values = [macd_line]
            signal_line = self._calculate_ema(macd_values, signal_period)
            
            # 히스토그램
            histogram = macd_line - signal_line
            
            # 신뢰도 계산
            confidence = min(1.0, len(prices) / (slow_period + signal_period))
            
            return {
                "macd": IndicatorValue("MACD", macd_line, datetime.now(), confidence),
                "signal": IndicatorValue("MACD_Signal", signal_line, datetime.now(), confidence),
                "histogram": IndicatorValue("MACD_Histogram", histogram, datetime.now(), confidence)
            }
            
        except Exception as e:
            logger.error(f"MACD 계산 오류: {e}")
            return None
    
    def calculate_bollinger_bands(self, prices: List[float], 
                                 period: int = 20, 
                                 std_dev: float = 2.0) -> Dict[str, IndicatorValue]:
        """볼린저 밴드 계산"""
        if len(prices) < period:
            return None
        
        try:
            # 이동평균
            sma = np.mean(prices[-period:])
            
            # 표준편차
            std = np.std(prices[-period:])
            
            # 밴드 계산
            upper_band = sma + (std_dev * std)
            lower_band = sma - (std_dev * std)
            
            # 신뢰도 계산
            confidence = min(1.0, len(prices) / period)
            
            return {
                "upper": IndicatorValue("BB_Upper", upper_band, datetime.now(), confidence),
                "middle": IndicatorValue("BB_Middle", sma, datetime.now(), confidence),
                "lower": IndicatorValue("BB_Lower", lower_band, datetime.now(), confidence),
                "width": IndicatorValue("BB_Width", upper_band - lower_band, datetime.now(), confidence)
            }
            
        except Exception as e:
            logger.error(f"볼린저 밴드 계산 오류: {e}")
            return None
    
    def calculate_moving_averages(self, prices: List[float], 
                                 periods: List[int] = [5, 10, 20, 50, 200]) -> Dict[str, IndicatorValue]:
        """이동평균 계산"""
        results = {}
        
        for period in periods:
            if len(prices) >= period:
                try:
                    ma_value = np.mean(prices[-period:])
                    confidence = min(1.0, len(prices) / period)
                    
                    results[f"SMA_{period}"] = IndicatorValue(
                        f"SMA_{period}", ma_value, datetime.now(), confidence
                    )
                except Exception as e:
                    logger.error(f"SMA {period} 계산 오류: {e}")
        
        return results
    
    def _calculate_ema(self, prices: List[float], period: int) -> float:
        """지수이동평균 계산"""
        if len(prices) < period:
            return prices[-1] if prices else 0
        
        alpha = 2 / (period + 1)
        ema = prices[0]
        
        for price in prices[1:]:
            ema = alpha * price + (1 - alpha) * ema
        
        return ema
    
    def calculate_stochastic(self, high_prices: List[float], 
                           low_prices: List[float], 
                           close_prices: List[float], 
                           k_period: int = 14, 
                           d_period: int = 3) -> Dict[str, IndicatorValue]:
        """스토캐스틱 계산"""
        if len(close_prices) < k_period:
            return None
        
        try:
            # %K 계산
            lowest_low = min(low_prices[-k_period:])
            highest_high = max(high_prices[-k_period:])
            current_close = close_prices[-1]
            
            if highest_high == lowest_low:
                k_percent = 50
            else:
                k_percent = ((current_close - lowest_low) / (highest_high - lowest_low)) * 100
            
            # %D 계산 (K의 이동평균)
            k_values = []
            for i in range(k_period):
                if i < len(close_prices) - k_period:
                    low_min = min(low_prices[-(k_period-i):])
                    high_max = max(high_prices[-(k_period-i):])
                    close_val = close_prices[-(i+1)]
                    if high_max == low_min:
                        k_val = 50
                    else:
                        k_val = ((close_val - low_min) / (high_max - low_min)) * 100
                    k_values.append(k_val)
            
            d_percent = np.mean(k_values) if k_values else k_percent
            
            confidence = min(1.0, len(close_prices) / k_period)
            
            return {
                "k": IndicatorValue("Stoch_K", k_percent, datetime.now(), confidence),
                "d": IndicatorValue("Stoch_D", d_percent, datetime.now(), confidence)
            }
            
        except Exception as e:
            logger.error(f"스토캐스틱 계산 오류: {e}")
            return None
    
    def calculate_atr(self, high_prices: List[float], 
                     low_prices: List[float], 
                     close_prices: List[float], 
                     period: int = 14) -> IndicatorValue:
        """ATR (Average True Range) 계산"""
        if len(close_prices) < period + 1:
            return None
        
        try:
            true_ranges = []
            
            for i in range(1, len(close_prices)):
                high = high_prices[i]
                low = low_prices[i]
                prev_close = close_prices[i-1]
                
                tr1 = high - low
                tr2 = abs(high - prev_close)
                tr3 = abs(low - prev_close)
                
                true_range = max(tr1, tr2, tr3)
                true_ranges.append(true_range)
            
            # ATR 계산 (지수이동평균 사용)
            atr = self._calculate_ema(true_ranges, period)
            
            confidence = min(1.0, len(close_prices) / period)
            
            return IndicatorValue(
                "ATR", atr, datetime.now(), confidence,
                metadata={"period": period, "method": "exponential"}
            )
            
        except Exception as e:
            logger.error(f"ATR 계산 오류: {e}")
            return None
```

## 🔧 **고급 지표 시스템**

### 📦 **고급 지표 계산기**

```python
# technical-analysis/advanced-indicators/advanced_indicator_calculator.py
import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional, Union
from dataclasses import dataclass
from datetime import datetime
import logging
import talib

logger = logging.getLogger(__name__)

class AdvancedIndicatorCalculator:
    """고급 기술적 지표 계산기"""
    
    def __init__(self):
        self.cache = {}
        self.custom_indicators = {}
    
    def calculate_ichimoku(self, high_prices: List[float], 
                          low_prices: List[float], 
                          close_prices: List[float]) -> Dict[str, IndicatorValue]:
        """일목균형표 (Ichimoku Kinko Hyo) 계산"""
        if len(close_prices) < 52:
            return None
        
        try:
            # 전환선 (Conversion Line)
            period9_high = max(high_prices[-9:])
            period9_low = min(low_prices[-9:])
            conversion = (period9_high + period9_low) / 2
            
            # 기준선 (Base Line)
            period26_high = max(high_prices[-26:])
            period26_low = min(low_prices[-26:])
            base = (period26_high + period26_low) / 2
            
            # 선행스팬1 (Leading Span A)
            leading_span_a = (conversion + base) / 2
            
            # 선행스팬2 (Leading Span B)
            period52_high = max(high_prices[-52:])
            period52_low = min(low_prices[-52:])
            leading_span_b = (period52_high + period52_low) / 2
            
            # 후행스팬 (Lagging Span)
            lagging_span = close_prices[-26] if len(close_prices) >= 26 else close_prices[-1]
            
            confidence = min(1.0, len(close_prices) / 52)
            timestamp = datetime.now()
            
            return {
                "conversion": IndicatorValue("Ichimoku_Conversion", conversion, timestamp, confidence),
                "base": IndicatorValue("Ichimoku_Base", base, timestamp, confidence),
                "leading_span_a": IndicatorValue("Ichimoku_Leading_A", leading_span_a, timestamp, confidence),
                "leading_span_b": IndicatorValue("Ichimoku_Leading_B", leading_span_b, timestamp, confidence),
                "lagging_span": IndicatorValue("Ichimoku_Lagging", lagging_span, timestamp, confidence)
            }
            
        except Exception as e:
            logger.error(f"일목균형표 계산 오류: {e}")
            return None
    
    def calculate_williams_r(self, high_prices: List[float], 
                           low_prices: List[float], 
                           close_prices: List[float], 
                           period: int = 14) -> IndicatorValue:
        """Williams %R 계산"""
        if len(close_prices) < period:
            return None
        
        try:
            highest_high = max(high_prices[-period:])
            lowest_low = min(low_prices[-period:])
            current_close = close_prices[-1]
            
            if highest_high == lowest_low:
                williams_r = -50
            else:
                williams_r = ((highest_high - current_close) / (highest_high - lowest_low)) * -100
            
            confidence = min(1.0, len(close_prices) / period)
            
            return IndicatorValue(
                "Williams_R", williams_r, datetime.now(), confidence,
                metadata={"period": period, "method": "standard"}
            )
            
        except Exception as e:
            logger.error(f"Williams %R 계산 오류: {e}")
            return None
    
    def calculate_cci(self, high_prices: List[float], 
                     low_prices: List[float], 
                     close_prices: List[float], 
                     period: int = 20) -> IndicatorValue:
        """CCI (Commodity Channel Index) 계산"""
        if len(close_prices) < period:
            return None
        
        try:
            # 전형적 가격 (Typical Price)
            typical_prices = [(h + l + c) / 3 for h, l, c in zip(high_prices, low_prices, close_prices)]
            
            # 이동평균
            sma = np.mean(typical_prices[-period:])
            
            # 평균편차
            mean_deviation = np.mean([abs(tp - sma) for tp in typical_prices[-period:]])
            
            current_tp = typical_prices[-1]
            
            if mean_deviation == 0:
                cci = 0
            else:
                cci = (current_tp - sma) / (0.015 * mean_deviation)
            
            confidence = min(1.0, len(close_prices) / period)
            
            return IndicatorValue(
                "CCI", cci, datetime.now(), confidence,
                metadata={"period": period, "method": "standard"}
            )
            
        except Exception as e:
            logger.error(f"CCI 계산 오류: {e}")
            return None
    
    def add_custom_indicator(self, name: str, calculation_func):
        """커스텀 지표 추가"""
        self.custom_indicators[name] = calculation_func
        logger.info(f"커스텀 지표 추가: {name}")
    
    def calculate_custom_indicator(self, name: str, *args, **kwargs) -> Optional[IndicatorValue]:
        """커스텀 지표 계산"""
        if name not in self.custom_indicators:
            logger.error(f"커스텀 지표를 찾을 수 없음: {name}")
            return None
        
        try:
            result = self.custom_indicators[name](*args, **kwargs)
            return result
        except Exception as e:
            logger.error(f"커스텀 지표 계산 오류 {name}: {e}")
            return None
```

## 🔧 **멀티 타임프레임 분석 시스템**

### 📦 **멀티 타임프레임 분석기**

```python
# technical-analysis/multi-timeframe/multi_timeframe_analyzer.py
import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional, Union
from dataclasses import dataclass
from datetime import datetime, timedelta
import logging
from enum import Enum

logger = logging.getLogger(__name__)

class Timeframe(Enum):
    """타임프레임"""
    MINUTE_1 = "1m"
    MINUTE_5 = "5m"
    MINUTE_15 = "15m"
    MINUTE_30 = "30m"
    HOUR_1 = "1h"
    HOUR_4 = "4h"
    DAY_1 = "1d"
    WEEK_1 = "1w"
    MONTH_1 = "1M"

@dataclass
class TimeframeSignal:
    """타임프레임별 신호"""
    timeframe: Timeframe
    signal_type: str  # 'BUY', 'SELL', 'HOLD'
    strength: float   # 0.0 ~ 1.0
    confidence: float # 0.0 ~ 1.0
    indicators: List[IndicatorValue]
    timestamp: datetime

@dataclass
class MultiTimeframeSignal:
    """멀티 타임프레임 통합 신호"""
    overall_signal: str  # 'BUY', 'SELL', 'HOLD'
    overall_strength: float  # 0.0 ~ 1.0
    overall_confidence: float  # 0.0 ~ 1.0
    timeframe_signals: Dict[Timeframe, TimeframeSignal]
    consistency_score: float  # 0.0 ~ 1.0
    timestamp: datetime

class MultiTimeframeAnalyzer:
    """멀티 타임프레임 분석기"""
    
    def __init__(self, timeframes: List[Timeframe] = None):
        self.timeframes = timeframes or [
            Timeframe.MINUTE_5, Timeframe.MINUTE_15, Timeframe.HOUR_1, 
            Timeframe.HOUR_4, Timeframe.DAY_1
        ]
        self.timeframe_weights = self._calculate_timeframe_weights()
        self.consistency_threshold = 0.7
    
    def _calculate_timeframe_weights(self) -> Dict[Timeframe, float]:
        """타임프레임별 가중치 계산"""
        weights = {}
        total_weight = 0
        
        for i, tf in enumerate(self.timeframes):
            # 짧은 타임프레임에 더 높은 가중치
            weight = 1.0 / (i + 1)
            weights[tf] = weight
            total_weight += weight
        
        # 정규화
        for tf in weights:
            weights[tf] /= total_weight
        
        return weights
    
    def analyze_multi_timeframe(self, market_data: Dict[Timeframe, Dict]) -> MultiTimeframeSignal:
        """멀티 타임프레임 분석"""
        timeframe_signals = {}
        
        # 각 타임프레임별 분석
        for timeframe in self.timeframes:
            if timeframe in market_data:
                signal = self._analyze_single_timeframe(timeframe, market_data[timeframe])
                if signal:
                    timeframe_signals[timeframe] = signal
        
        if not timeframe_signals:
            return None
        
        # 통합 신호 생성
        overall_signal = self._combine_timeframe_signals(timeframe_signals)
        consistency_score = self._calculate_consistency(timeframe_signals)
        
        return MultiTimeframeSignal(
            overall_signal=overall_signal["signal"],
            overall_strength=overall_signal["strength"],
            overall_confidence=overall_signal["confidence"],
            timeframe_signals=timeframe_signals,
            consistency_score=consistency_score,
            timestamp=datetime.now()
        )
    
    def _analyze_single_timeframe(self, timeframe: Timeframe, data: Dict) -> Optional[TimeframeSignal]:
        """단일 타임프레임 분석"""
        try:
            # 기본 지표 계산
            basic_calc = BasicIndicatorCalculator()
            advanced_calc = AdvancedIndicatorCalculator()
            
            indicators = []
            
            # RSI
            if 'close' in data:
                rsi = basic_calc.calculate_rsi(data['close'])
                if rsi:
                    indicators.append(rsi)
            
            # MACD
            if 'close' in data:
                macd_results = basic_calc.calculate_macd(data['close'])
                if macd_results:
                    indicators.extend(macd_results.values())
            
            # 볼린저 밴드
            if 'close' in data:
                bb_results = basic_calc.calculate_bollinger_bands(data['close'])
                if bb_results:
                    indicators.extend(bb_results.values())
            
            # 이동평균
            if 'close' in data:
                ma_results = basic_calc.calculate_moving_averages(data['close'])
                if ma_results:
                    indicators.extend(ma_results.values())
            
            # 신호 생성
            signal = self._generate_signal_from_indicators(indicators)
            
            return TimeframeSignal(
                timeframe=timeframe,
                signal_type=signal["type"],
                strength=signal["strength"],
                confidence=signal["confidence"],
                indicators=indicators,
                timestamp=datetime.now()
            )
            
        except Exception as e:
            logger.error(f"타임프레임 분석 오류 {timeframe}: {e}")
            return None
    
    def _generate_signal_from_indicators(self, indicators: List[IndicatorValue]) -> Dict:
        """지표로부터 신호 생성"""
        buy_signals = 0
        sell_signals = 0
        total_confidence = 0
        total_indicators = 0
        
        for indicator in indicators:
            if indicator.value is None:
                continue
            
            signal = self._interpret_indicator(indicator)
            if signal == "BUY":
                buy_signals += indicator.confidence
            elif signal == "SELL":
                sell_signals += indicator.confidence
            
            total_confidence += indicator.confidence
            total_indicators += 1
        
        if total_indicators == 0:
            return {"type": "HOLD", "strength": 0.0, "confidence": 0.0}
        
        # 신호 결정
        if buy_signals > sell_signals:
            signal_type = "BUY"
            strength = buy_signals / total_confidence
        elif sell_signals > buy_signals:
            signal_type = "SELL"
            strength = sell_signals / total_confidence
        else:
            signal_type = "HOLD"
            strength = 0.0
        
        confidence = total_confidence / total_indicators
        
        return {
            "type": signal_type,
            "strength": min(1.0, strength),
            "confidence": confidence
        }
    
    def _interpret_indicator(self, indicator: IndicatorValue) -> str:
        """지표 해석"""
        name = indicator.indicator_name
        value = indicator.value
        
        if name == "RSI":
            if value > 70:
                return "SELL"
            elif value < 30:
                return "BUY"
        elif name == "MACD":
            if value > 0:
                return "BUY"
            else:
                return "SELL"
        elif name.startswith("BB_"):
            if name == "BB_Upper" and value < 0:
                return "SELL"
            elif name == "BB_Lower" and value > 0:
                return "BUY"
        
        return "HOLD"
    
    def _combine_timeframe_signals(self, timeframe_signals: Dict[Timeframe, TimeframeSignal]) -> Dict:
        """타임프레임 신호 결합"""
        weighted_buy = 0.0
        weighted_sell = 0.0
        total_weight = 0.0
        total_confidence = 0.0
        
        for timeframe, signal in timeframe_signals.items():
            weight = self.timeframe_weights.get(timeframe, 0.0)
            
            if signal.signal_type == "BUY":
                weighted_buy += signal.strength * weight * signal.confidence
            elif signal.signal_type == "SELL":
                weighted_sell += signal.strength * weight * signal.confidence
            
            total_weight += weight
            total_confidence += signal.confidence
        
        if total_weight == 0:
            return {"signal": "HOLD", "strength": 0.0, "confidence": 0.0}
        
        # 신호 결정
        if weighted_buy > weighted_sell:
            signal_type = "BUY"
            strength = weighted_buy / total_weight
        elif weighted_sell > weighted_buy:
            signal_type = "SELL"
            strength = weighted_sell / total_weight
        else:
            signal_type = "HOLD"
            strength = 0.0
        
        confidence = total_confidence / len(timeframe_signals)
        
        return {
            "signal": signal_type,
            "strength": min(1.0, strength),
            "confidence": confidence
        }
    
    def _calculate_consistency(self, timeframe_signals: Dict[Timeframe, TimeframeSignal]) -> float:
        """일관성 점수 계산"""
        if len(timeframe_signals) < 2:
            return 1.0
        
        signals = [s.signal_type for s in timeframe_signals.values()]
        
        # 동일한 신호의 비율 계산
        buy_count = signals.count("BUY")
        sell_count = signals.count("SELL")
        hold_count = signals.count("HOLD")
        
        max_count = max(buy_count, sell_count, hold_count)
        consistency = max_count / len(signals)
        
        return consistency
```

## 🔧 **고급 패턴 인식 시스템**

### 📦 **캔들스틱 패턴 인식기**

```python
# technical-analysis/advanced-pattern-recognition/candlestick_pattern_recognizer.py
import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass
from datetime import datetime
import logging
from enum import Enum

logger = logging.getLogger(__name__)

class PatternType(Enum):
    """패턴 타입"""
    BULLISH = "bullish"
    BEARISH = "bearish"
    NEUTRAL = "neutral"
    REVERSAL = "reversal"
    CONTINUATION = "continuation"

class PatternStrength(Enum):
    """패턴 강도"""
    WEAK = "weak"
    MODERATE = "moderate"
    STRONG = "strong"
    VERY_STRONG = "very_strong"

@dataclass
class CandlestickPattern:
    """캔들스틱 패턴"""
    pattern_name: str
    pattern_type: PatternType
    strength: PatternStrength
    confidence: float
    start_index: int
    end_index: int
    description: str
    trading_signal: str
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None

class AdvancedCandlestickPatternRecognizer:
    """고급 캔들스틱 패턴 인식기"""
    
    def __init__(self):
        self.pattern_definitions = self._load_pattern_definitions()
        self.recognition_threshold = 0.7
    
    def _load_pattern_definitions(self) -> Dict[str, Dict]:
        """패턴 정의 로드"""
        return {
            'doji': {
                'description': 'Doji - 시장 불확실성',
                'type': PatternType.NEUTRAL,
                'conditions': ['body_ratio < 0.1', 'upper_shadow > 0', 'lower_shadow > 0'],
                'signal': 'HOLD',
                'strength': PatternStrength.MODERATE
            },
            'hammer': {
                'description': 'Hammer - 강세 반전 신호',
                'type': PatternType.BULLISH,
                'conditions': ['body_ratio < 0.3', 'lower_shadow > 2 * body', 'upper_shadow < 0.1'],
                'signal': 'BUY',
                'strength': PatternStrength.STRONG
            },
            'shooting_star': {
                'description': 'Shooting Star - 약세 반전 신호',
                'type': PatternType.BEARISH,
                'conditions': ['body_ratio < 0.3', 'upper_shadow > 2 * body', 'lower_shadow < 0.1'],
                'signal': 'SELL',
                'strength': PatternStrength.STRONG
            },
            'engulfing_bullish': {
                'description': 'Bullish Engulfing - 강세 반전',
                'type': PatternType.BULLISH,
                'conditions': ['prev_body < 0', 'curr_body > 0', 'curr_open < prev_close', 'curr_close > prev_open'],
                'signal': 'BUY',
                'strength': PatternStrength.VERY_STRONG
            },
            'engulfing_bearish': {
                'description': 'Bearish Engulfing - 약세 반전',
                'type': PatternType.BEARISH,
                'conditions': ['prev_body > 0', 'curr_body < 0', 'curr_open > prev_close', 'curr_close < prev_open'],
                'signal': 'SELL',
                'strength': PatternStrength.VERY_STRONG
            }
        }
    
    def recognize_patterns(self, candlestick_data: pd.DataFrame) -> List[CandlestickPattern]:
        """캔들스틱 패턴 인식"""
        try:
            patterns = []
            
            # 기본 캔들스틱 특성 계산
            candlestick_features = self._calculate_candlestick_features(candlestick_data)
            
            # 각 패턴 검사
            for pattern_name, pattern_def in self.pattern_definitions.items():
                detected_patterns = self._check_pattern(pattern_name, pattern_def, candlestick_features)
                patterns.extend(detected_patterns)
            
            # 신뢰도 순으로 정렬
            patterns.sort(key=lambda x: x.confidence, reverse=True)
            
            return patterns
            
        except Exception as e:
            logger.error(f"패턴 인식 오류: {e}")
            return []
    
    def _calculate_candlestick_features(self, data: pd.DataFrame) -> pd.DataFrame:
        """캔들스틱 특성 계산"""
        try:
            features = data.copy()
            
            # 기본 특성
            features['body'] = features['close'] - features['open']
            features['body_abs'] = np.abs(features['body'])
            features['upper_shadow'] = features['high'] - np.maximum(features['open'], features['close'])
            features['lower_shadow'] = np.minimum(features['open'], features['close']) - features['low']
            features['total_range'] = features['high'] - features['low']
            
            # 비율 특성
            features['body_ratio'] = features['body_abs'] / features['total_range']
            features['upper_shadow_ratio'] = features['upper_shadow'] / features['total_range']
            features['lower_shadow_ratio'] = features['lower_shadow'] / features['total_range']
            
            return features
            
        except Exception as e:
            logger.error(f"캔들스틱 특성 계산 오류: {e}")
            return data
```

## 🔧 **크로스 마켓 분석 시스템**

### 📦 **크로스 마켓 분석기**

```python
# technical-analysis/cross-market-analysis/cross_market_analyzer.py
import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass
from datetime import datetime, timedelta
import logging
from scipy import stats
from sklearn.decomposition import PCA
from sklearn.cluster import KMeans

logger = logging.getLogger(__name__)

@dataclass
class MarketCorrelation:
    """시장 상관관계"""
    asset1: str
    asset2: str
    correlation: float
    p_value: float
    rolling_correlation: List[float]
    regime_correlation: Dict[str, float]
    timestamp: datetime

@dataclass
class MarketRegime:
    """시장 체제"""
    regime_id: str
    regime_type: str  # 'risk_on', 'risk_off', 'neutral'
    volatility_level: float
    correlation_level: float
    dominant_assets: List[str]
    start_time: datetime
    end_time: Optional[datetime] = None
    confidence: float = 0.0

class CrossMarketAnalyzer:
    """크로스 마켓 분석기"""
    
    def __init__(self, lookback_period: int = 252):
        self.lookback_period = lookback_period
        self.correlation_matrix = pd.DataFrame()
        self.market_regimes = []
        self.asset_data = {}
    
    def add_asset_data(self, asset: str, data: pd.DataFrame):
        """자산 데이터 추가"""
        try:
            self.asset_data[asset] = data
            logger.info(f"자산 데이터 추가: {asset} - {len(data)}개 데이터")
        except Exception as e:
            logger.error(f"자산 데이터 추가 오류: {e}")
    
    def calculate_correlations(self) -> pd.DataFrame:
        """상관관계 계산"""
        try:
            # 수익률 계산
            returns_data = {}
            for asset, data in self.asset_data.items():
                if 'close' in data.columns:
                    returns_data[asset] = data['close'].pct_change().dropna()
            
            # 상관관계 행렬 계산
            returns_df = pd.DataFrame(returns_data)
            correlation_matrix = returns_df.corr()
            
            self.correlation_matrix = correlation_matrix
            
            return correlation_matrix
            
        except Exception as e:
            logger.error(f"상관관계 계산 오류: {e}")
            return pd.DataFrame()
    
    def detect_market_regime(self) -> MarketRegime:
        """시장 체제 감지"""
        try:
            if self.correlation_matrix.empty:
                self.calculate_correlations()
            
            # 주요 자산들의 변동성 계산
            volatilities = {}
            for asset, data in self.asset_data.items():
                if 'close' in data.columns:
                    returns = data['close'].pct_change().dropna()
                    volatilities[asset] = returns.std()
            
            # 평균 변동성
            avg_volatility = np.mean(list(volatilities.values()))
            
            # 상관관계 수준 계산
            correlation_level = self._calculate_correlation_level()
            
            # 체제 분류
            if avg_volatility > 0.02 and correlation_level > 0.7:
                regime_type = 'risk_off'
            elif avg_volatility < 0.01 and correlation_level < 0.3:
                regime_type = 'risk_on'
            else:
                regime_type = 'neutral'
            
            # 주요 자산 식별
            dominant_assets = self._identify_dominant_assets()
            
            # 신뢰도 계산
            confidence = self._calculate_regime_confidence(avg_volatility, correlation_level)
            
            regime = MarketRegime(
                regime_id=f"regime_{datetime.now().strftime('%Y%m%d_%H%M%S')}",
                regime_type=regime_type,
                volatility_level=avg_volatility,
                correlation_level=correlation_level,
                dominant_assets=dominant_assets,
                start_time=datetime.now(),
                confidence=confidence
            )
            
            self.market_regimes.append(regime)
            
            return regime
            
        except Exception as e:
            logger.error(f"시장 체제 감지 오류: {e}")
            return None
```

## 🔧 **옵션 분석 시스템**

### 📦 **옵션 분석기**

```python
# technical-analysis/options-analysis/options_analyzer.py
import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass
from datetime import datetime
import logging
from scipy.stats import norm

logger = logging.getLogger(__name__)

@dataclass
class OptionGreeks:
    """옵션 그릭스"""
    delta: float
    gamma: float
    theta: float
    vega: float
    rho: float
    timestamp: datetime

@dataclass
class OptionChain:
    """옵션 체인"""
    symbol: str
    expiration_date: datetime
    strike_prices: List[float]
    call_options: Dict[float, Dict]
    put_options: Dict[float, Dict]
    implied_volatility: Dict[float, float]
    timestamp: datetime

class OptionsAnalyzer:
    """옵션 분석기"""
    
    def __init__(self, risk_free_rate: float = 0.02):
        self.risk_free_rate = risk_free_rate
    
    def calculate_black_scholes(self, S: float, K: float, T: float, r: float, 
                              sigma: float, option_type: str = 'call') -> Dict[str, float]:
        """Black-Scholes 옵션 가격 계산"""
        try:
            d1 = (np.log(S / K) + (r + 0.5 * sigma**2) * T) / (sigma * np.sqrt(T))
            d2 = d1 - sigma * np.sqrt(T)
            
            if option_type.lower() == 'call':
                price = S * norm.cdf(d1) - K * np.exp(-r * T) * norm.cdf(d2)
                delta = norm.cdf(d1)
            else:  # put
                price = K * np.exp(-r * T) * norm.cdf(-d2) - S * norm.cdf(-d1)
                delta = norm.cdf(d1) - 1
            
            # 그릭스 계산
            gamma = norm.pdf(d1) / (S * sigma * np.sqrt(T))
            theta = (-S * norm.pdf(d1) * sigma / (2 * np.sqrt(T)) - 
                    r * K * np.exp(-r * T) * norm.cdf(d2)) if option_type == 'call' else \
                   (-S * norm.pdf(d1) * sigma / (2 * np.sqrt(T)) + 
                    r * K * np.exp(-r * T) * norm.cdf(-d2))
            vega = S * np.sqrt(T) * norm.pdf(d1)
            rho = K * T * np.exp(-r * T) * norm.cdf(d2) if option_type == 'call' else \
                  -K * T * np.exp(-r * T) * norm.cdf(-d2)
            
            return {
                'price': price,
                'delta': delta,
                'gamma': gamma,
                'theta': theta,
                'vega': vega,
                'rho': rho
            }
            
        except Exception as e:
            logger.error(f"Black-Scholes 계산 오류: {e}")
            return {}
    
    def calculate_implied_volatility(self, S: float, K: float, T: float, r: float, 
                                   option_price: float, option_type: str = 'call') -> float:
        """내재 변동성 계산"""
        try:
            def objective(sigma):
                calculated_price = self.calculate_black_scholes(S, K, T, r, sigma, option_type)['price']
                return calculated_price - option_price
            
            # Newton-Raphson 방법으로 내재 변동성 계산
            sigma = 0.3  # 초기값
            tolerance = 1e-5
            max_iterations = 100
            
            for i in range(max_iterations):
                price_diff = objective(sigma)
                if abs(price_diff) < tolerance:
                    break
                
                # Vega로 미분
                vega = self.calculate_black_scholes(S, K, T, r, sigma, option_type)['vega']
                if abs(vega) < 1e-10:
                    break
                
                sigma = sigma - price_diff / vega
                sigma = max(0.001, min(5.0, sigma))  # 범위 제한
            
            return sigma
            
        except Exception as e:
            logger.error(f"내재 변동성 계산 오류: {e}")
            return 0.0
    
    def analyze_option_chain(self, option_chain: OptionChain) -> Dict[str, Any]:
        """옵션 체인 분석"""
        try:
            analysis = {
                'put_call_ratio': 0.0,
                'skew': 0.0,
                'term_structure': {},
                'volatility_smile': {},
                'greeks_summary': {}
            }
            
            # Put-Call 비율 계산
            total_call_volume = sum(opt.get('volume', 0) for opt in option_chain.call_options.values())
            total_put_volume = sum(opt.get('volume', 0) for opt in option_chain.put_options.values())
            
            if total_call_volume > 0:
                analysis['put_call_ratio'] = total_put_volume / total_call_volume
            
            # 변동성 스큐 계산
            atm_strike = min(option_chain.strike_prices, key=lambda x: abs(x - option_chain.strike_prices[len(option_chain.strike_prices)//2]))
            
            if atm_strike in option_chain.implied_volatility:
                atm_iv = option_chain.implied_volatility[atm_strike]
                
                # OTM Put과 OTM Call의 변동성 차이
                otm_puts = [iv for strike, iv in option_chain.implied_volatility.items() 
                           if strike < atm_strike and strike in option_chain.put_options]
                otm_calls = [iv for strike, iv in option_chain.implied_volatility.items() 
                            if strike > atm_strike and strike in option_chain.call_options]
                
                if otm_puts and otm_calls:
                    avg_put_iv = np.mean(otm_puts)
                    avg_call_iv = np.mean(otm_calls)
                    analysis['skew'] = avg_put_iv - avg_call_iv
            
            return analysis
            
        except Exception as e:
            logger.error(f"옵션 체인 분석 오류: {e}")
            return {}
```

## 📊 **성과 지표**

### **목표 성과**
- **지표 정확도**: 70% 이상
- **신호 정확도**: 65% 이상
- **멀티 타임프레임 일관성**: 80% 이상
- **패턴 인식 정확도**: > 85% 패턴 감지 정확도
- **상관관계 분석**: < 100ms 크로스 에셋 분석
- **옵션 분석**: < 500ms 그릭스 계산
- **실시간 처리**: < 100ms
- **메모리 효율성**: < 500MB

### **성능 지표**
- **지표 계산 시간**: < 10ms per indicator
- **멀티 타임프레임 분석**: < 50ms
- **신호 생성 시간**: < 100ms
- **캐시 히트율**: > 90%
- **시스템 가동률**: > 99.5%

## 🔗 **관련 문서**

- [Phase 3.5.2: 전략 라이브러리](3.5.2_TRADING_STRATEGIES.md)
- [Phase 3.5.3: 뉴스 이벤트 분석](3.5.3_NEWS_EVENT_ANALYSIS.md)
- [Phase 3.5.4: 온라인 학습](3.5.4_ONLINE_LEARNING.md)
- [Phase 3.5.5: 설명 가능한 AI](3.5.5_EXPLAINABLE_AI.md)

## 🔧 **새로운 모듈 구현 코드**

### 📊 **포트폴리오 분석 시스템**

```python
# technical-analysis/portfolio-analysis/portfolio_analyzer.py
import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass
from datetime import datetime, timedelta
import logging

logger = logging.getLogger(__name__)

@dataclass
class AssetPerformance:
    """자산별 성과 데이터"""
    asset_id: str
    returns: List[float]
    volatility: float
    sharpe_ratio: float
    max_drawdown: float
    beta: float
    alpha: float

class PortfolioAnalyzer:
    """포트폴리오 분석기"""
    
    def __init__(self):
        self.risk_free_rate = 0.02  # 2% 무위험 수익률
        
    def analyze_asset_performance(self, asset_data: Dict[str, List[float]]) -> Dict[str, AssetPerformance]:
        """자산별 성과 분석"""
        results = {}
        
        for asset_id, prices in asset_data.items():
            if len(prices) < 2:
                continue
                
            # 수익률 계산
            returns = np.diff(prices) / prices[:-1]
            
            # 기본 통계
            avg_return = np.mean(returns)
            volatility = np.std(returns)
            
            # 샤프 비율
            sharpe_ratio = (avg_return - self.risk_free_rate) / volatility if volatility > 0 else 0
            
            # 최대 낙폭
            cumulative_returns = np.cumprod(1 + returns)
            running_max = np.maximum.accumulate(cumulative_returns)
            drawdown = (cumulative_returns - running_max) / running_max
            max_drawdown = np.min(drawdown)
            
            # 베타 계산 (시장 대비)
            market_returns = self._get_market_returns()
            if len(market_returns) == len(returns):
                beta = np.cov(returns, market_returns)[0, 1] / np.var(market_returns)
                alpha = avg_return - (self.risk_free_rate + beta * (np.mean(market_returns) - self.risk_free_rate))
            else:
                beta = alpha = 0
            
            results[asset_id] = AssetPerformance(
                asset_id=asset_id,
                returns=returns.tolist(),
                volatility=volatility,
                sharpe_ratio=sharpe_ratio,
                max_drawdown=max_drawdown,
                beta=beta,
                alpha=alpha
            )
        
        return results
    
    def risk_decomposition(self, portfolio_weights: Dict[str, float], 
                          asset_covariance: np.ndarray) -> Dict[str, float]:
        """리스크 분해"""
        try:
            weights = np.array(list(portfolio_weights.values()))
            
            # 포트폴리오 변동성
            portfolio_vol = np.sqrt(weights.T @ asset_covariance @ weights)
            
            # 각 자산의 기여도
            marginal_contrib = asset_covariance @ weights
            risk_contrib = weights * marginal_contrib / portfolio_vol
            
            return {
                'portfolio_volatility': portfolio_vol,
                'risk_contributions': dict(zip(portfolio_weights.keys(), risk_contrib))
            }
            
        except Exception as e:
            logger.error(f"리스크 분해 계산 오류: {e}")
            return {}
    
    def _get_market_returns(self) -> np.ndarray:
        """시장 수익률 (예시)"""
        # 실제 구현에서는 시장 지수 데이터 사용
        return np.random.normal(0.001, 0.02, 100)
```

### 🧠 **시장 심리 분석 시스템**

```python
# technical-analysis/market-sentiment-analysis/market_sentiment_analyzer.py
import numpy as np
import pandas as pd
from typing import Dict, List, Optional
from dataclasses import dataclass
import logging

logger = logging.getLogger(__name__)

@dataclass
class FearGreedData:
    """Fear & Greed Index 데이터"""
    value: float
    classification: str
    components: Dict[str, float]
    timestamp: datetime

class MarketSentimentAnalyzer:
    """시장 심리 분석기"""
    
    def __init__(self):
        self.fear_greed_thresholds = {
            'extreme_fear': 25,
            'fear': 45,
            'neutral': 55,
            'greed': 75,
            'extreme_greed': 100
        }
    
    def calculate_fear_greed_index(self, market_data: Dict[str, float]) -> FearGreedData:
        """Fear & Greed Index 계산"""
        try:
            components = {}
            
            # 변동성 (25%)
            volatility = market_data.get('volatility', 0)
            vol_score = max(0, 100 - (volatility * 100))
            components['volatility'] = vol_score * 0.25
            
            # 시장 모멘텀 (25%)
            momentum = market_data.get('momentum', 0)
            mom_score = 50 + (momentum * 50)
            components['momentum'] = mom_score * 0.25
            
            # 거래량 (20%)
            volume = market_data.get('volume_ratio', 1.0)
            vol_ratio_score = min(100, volume * 50)
            components['volume'] = vol_ratio_score * 0.20
            
            # 시장 강도 (15%)
            strength = market_data.get('market_strength', 0)
            strength_score = 50 + (strength * 50)
            components['strength'] = strength_score * 0.15
            
            # 안전자산 선호도 (15%)
            safe_haven = market_data.get('safe_haven_demand', 0)
            safe_score = 100 - (safe_haven * 100)
            components['safe_haven'] = safe_score * 0.15
            
            # 총점 계산
            total_score = sum(components.values())
            
            # 분류
            classification = self._classify_fear_greed(total_score)
            
            return FearGreedData(
                value=total_score,
                classification=classification,
                components=components,
                timestamp=datetime.now()
            )
            
        except Exception as e:
            logger.error(f"Fear & Greed Index 계산 오류: {e}")
            return FearGreedData(50, 'neutral', {}, datetime.now())
    
    def calculate_vix_equivalent(self, price_data: List[float], window: int = 30) -> float:
        """VIX 등가 지수 계산"""
        try:
            if len(price_data) < window + 1:
                return 0.0
            
            # 로그 수익률 계산
            returns = np.log(np.array(price_data[1:]) / np.array(price_data[:-1]))
            
            # 변동성 계산 (30일)
            volatility = np.std(returns[-window:]) * np.sqrt(252)  # 연율화
            
            # VIX 등가 (변동성 * 100)
            vix_equivalent = volatility * 100
            
            return vix_equivalent
            
        except Exception as e:
            logger.error(f"VIX 등가 계산 오류: {e}")
            return 0.0
    
    def detect_market_regime(self, market_data: Dict[str, float]) -> str:
        """시장 체제 감지"""
        try:
            volatility = market_data.get('volatility', 0)
            trend = market_data.get('trend', 0)
            volume = market_data.get('volume_ratio', 1.0)
            
            # 변동성 기반 체제 분류
            if volatility > 0.03:  # 3% 이상
                if trend > 0:
                    return 'high_volatility_bull'
                else:
                    return 'high_volatility_bear'
            elif volatility < 0.01:  # 1% 미만
                if volume < 0.8:
                    return 'low_volatility_sideways'
                else:
                    return 'low_volatility_trending'
            else:
                if abs(trend) > 0.01:
                    return 'moderate_volatility_trending'
                else:
                    return 'moderate_volatility_sideways'
                    
        except Exception as e:
            logger.error(f"시장 체제 감지 오류: {e}")
            return 'unknown'
    
    def _classify_fear_greed(self, score: float) -> str:
        """Fear & Greed 분류"""
        if score <= self.fear_greed_thresholds['extreme_fear']:
            return 'extreme_fear'
        elif score <= self.fear_greed_thresholds['fear']:
            return 'fear'
        elif score <= self.fear_greed_thresholds['neutral']:
            return 'neutral'
        elif score <= self.fear_greed_thresholds['greed']:
            return 'greed'
        else:
            return 'extreme_greed'
```

### 📈 **거래량 분석 시스템**

```python
# technical-analysis/volume-analysis/volume_analyzer.py
import numpy as np
import pandas as pd
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
import logging

logger = logging.getLogger(__name__)

@dataclass
class VolumeProfile:
    """거래량 프로파일"""
    price_levels: List[float]
    volume_at_price: List[float]
    poc_price: float  # Point of Control
    value_areas: List[Tuple[float, float]]

class VolumeAnalyzer:
    """거래량 분석기"""
    
    def __init__(self):
        self.volume_profile_bins = 100
        
    def calculate_volume_profile(self, price_data: List[float], 
                               volume_data: List[float]) -> VolumeProfile:
        """거래량 프로파일 계산"""
        try:
            if len(price_data) != len(volume_data):
                raise ValueError("가격과 거래량 데이터 길이가 다름")
            
            # 가격 범위 분할
            min_price = min(price_data)
            max_price = max(price_data)
            price_range = max_price - min_price
            
            if price_range == 0:
                return VolumeProfile([], [], 0, [])
            
            bin_size = price_range / self.volume_profile_bins
            price_levels = [min_price + i * bin_size for i in range(self.volume_profile_bins + 1)]
            
            # 각 가격 레벨별 거래량 집계
            volume_at_price = [0.0] * len(price_levels)
            
            for price, volume in zip(price_data, volume_data):
                bin_index = min(int((price - min_price) / bin_size), len(price_levels) - 1)
                volume_at_price[bin_index] += volume
            
            # Point of Control (가장 거래량이 많은 가격)
            poc_index = np.argmax(volume_at_price)
            poc_price = price_levels[poc_index]
            
            # Value Areas (총 거래량의 70%를 포함하는 영역)
            total_volume = sum(volume_at_price)
            target_volume = total_volume * 0.7
            
            # POC에서 시작하여 양방향으로 확장
            current_volume = volume_at_price[poc_index]
            left_index = poc_index
            right_index = poc_index
            
            while current_volume < target_volume and (left_index > 0 or right_index < len(volume_at_price) - 1):
                left_volume = volume_at_price[left_index - 1] if left_index > 0 else 0
                right_volume = volume_at_price[right_index + 1] if right_index < len(volume_at_price) - 1 else 0
                
                if left_volume > right_volume and left_index > 0:
                    left_index -= 1
                    current_volume += left_volume
                elif right_index < len(volume_at_price) - 1:
                    right_index += 1
                    current_volume += right_volume
                else:
                    break
            
            value_areas = [(price_levels[left_index], price_levels[right_index])]
            
            return VolumeProfile(
                price_levels=price_levels,
                volume_at_price=volume_at_price,
                poc_price=poc_price,
                value_areas=value_areas
            )
            
        except Exception as e:
            logger.error(f"거래량 프로파일 계산 오류: {e}")
            return VolumeProfile([], [], 0, [])
    
    def calculate_obv(self, price_data: List[float], volume_data: List[float]) -> List[float]:
        """On-Balance Volume (OBV) 계산"""
        try:
            if len(price_data) != len(volume_data):
                raise ValueError("가격과 거래량 데이터 길이가 다름")
            
            obv = [0.0]
            
            for i in range(1, len(price_data)):
                if price_data[i] > price_data[i-1]:
                    obv.append(obv[-1] + volume_data[i])
                elif price_data[i] < price_data[i-1]:
                    obv.append(obv[-1] - volume_data[i])
                else:
                    obv.append(obv[-1])
            
            return obv
            
        except Exception as e:
            logger.error(f"OBV 계산 오류: {e}")
            return [0.0] * len(price_data)
    
    def calculate_volume_weighted_average(self, price_data: List[float], 
                                        volume_data: List[float], 
                                        window: int = 20) -> List[float]:
        """거래량 가중 평균 계산"""
        try:
            if len(price_data) != len(volume_data):
                raise ValueError("가격과 거래량 데이터 길이가 다름")
            
            vwa = []
            
            for i in range(len(price_data)):
                start_idx = max(0, i - window + 1)
                end_idx = i + 1
                
                window_prices = price_data[start_idx:end_idx]
                window_volumes = volume_data[start_idx:end_idx]
                
                if sum(window_volumes) > 0:
                    vwa_value = sum(p * v for p, v in zip(window_prices, window_volumes)) / sum(window_volumes)
                else:
                    vwa_value = price_data[i]
                
                vwa.append(vwa_value)
            
            return vwa
            
        except Exception as e:
            logger.error(f"거래량 가중 평균 계산 오류: {e}")
            return price_data.copy()
    
    def detect_volume_patterns(self, volume_data: List[float], 
                             price_data: List[float]) -> Dict[str, bool]:
        """거래량 패턴 감지"""
        try:
            patterns = {
                'volume_spike': False,
                'volume_dry_up': False,
                'price_volume_divergence': False,
                'accumulation': False,
                'distribution': False
            }
            
            if len(volume_data) < 20:
                return patterns
            
            # 거래량 스파이크 감지
            avg_volume = np.mean(volume_data[-20:])
            current_volume = volume_data[-1]
            if current_volume > avg_volume * 2:
                patterns['volume_spike'] = True
            
            # 거래량 고갈 감지
            if current_volume < avg_volume * 0.5:
                patterns['volume_dry_up'] = True
            
            # 가격-거래량 괴리 감지
            if len(price_data) >= 10:
                price_trend = price_data[-1] - price_data[-10]
                volume_trend = volume_data[-1] - volume_data[-10]
                
                if (price_trend > 0 and volume_trend < 0) or (price_trend < 0 and volume_trend > 0):
                    patterns['price_volume_divergence'] = True
            
            # 누적/분산 패턴 감지
            if len(price_data) >= 20:
                recent_prices = price_data[-20:]
                recent_volumes = volume_data[-20:]
                
                price_trend = recent_prices[-1] - recent_prices[0]
                volume_trend = np.mean(recent_volumes[-5:]) - np.mean(recent_volumes[:5])
                
                if price_trend > 0 and volume_trend > 0:
                    patterns['accumulation'] = True
                elif price_trend < 0 and volume_trend > 0:
                    patterns['distribution'] = True
            
            return patterns
            
        except Exception as e:
            logger.error(f"거래량 패턴 감지 오류: {e}")
            return {'volume_spike': False, 'volume_dry_up': False, 
                   'price_volume_divergence': False, 'accumulation': False, 'distribution': False}
```

### 🎯 **자동 지지/저항 시스템**

```python
# technical-analysis/support-resistance/support_resistance_detector.py
import numpy as np
import pandas as pd
from typing import Dict, List, Optional, Tuple
from dataclasses import dataclass
import logging

logger = logging.getLogger(__name__)

@dataclass
class SupportResistanceLevel:
    """지지/저항 레벨"""
    price: float
    strength: float
    type: str  # 'support' or 'resistance'
    confidence: float
    touches: int
    last_touch: datetime

class SupportResistanceDetector:
    """자동 지지/저항 감지기"""
    
    def __init__(self):
        self.min_touches = 2
        self.touch_tolerance = 0.002  # 0.2% 터치 허용 오차
        self.strength_threshold = 0.6
        
    def calculate_fibonacci_levels(self, high: float, low: float) -> Dict[str, float]:
        """피보나치 레벨 계산"""
        try:
            diff = high - low
            
            levels = {
                '0.0': low,
                '0.236': low + 0.236 * diff,
                '0.382': low + 0.382 * diff,
                '0.5': low + 0.5 * diff,
                '0.618': low + 0.618 * diff,
                '0.786': low + 0.786 * diff,
                '1.0': high,
                '1.272': high + 0.272 * diff,
                '1.618': high + 0.618 * diff
            }
            
            return levels
            
        except Exception as e:
            logger.error(f"피보나치 레벨 계산 오류: {e}")
            return {}
    
    def calculate_pivot_points(self, high: float, low: float, close: float) -> Dict[str, float]:
        """Pivot Points 계산"""
        try:
            pivot = (high + low + close) / 3
            
            r1 = 2 * pivot - low
            r2 = pivot + (high - low)
            r3 = high + 2 * (pivot - low)
            
            s1 = 2 * pivot - high
            s2 = pivot - (high - low)
            s3 = low - 2 * (high - pivot)
            
            return {
                'pivot': pivot,
                'r1': r1, 'r2': r2, 'r3': r3,
                's1': s1, 's2': s2, 's3': s3
            }
            
        except Exception as e:
            logger.error(f"Pivot Points 계산 오류: {e}")
            return {}
    
    def detect_automatic_levels(self, price_data: List[float], 
                              volume_data: Optional[List[float]] = None) -> List[SupportResistanceLevel]:
        """자동 지지/저항 레벨 감지"""
        try:
            levels = []
            
            if len(price_data) < 50:
                return levels
            
            # 고점과 저점 찾기
            highs = self._find_peaks(price_data, 'high')
            lows = self._find_peaks(price_data, 'low')
            
            # 저항 레벨 (고점 기반)
            resistance_levels = self._cluster_levels(highs, 'resistance')
            for level in resistance_levels:
                levels.append(level)
            
            # 지지 레벨 (저점 기반)
            support_levels = self._cluster_levels(lows, 'support')
            for level in support_levels:
                levels.append(level)
            
            # 거래량 가중 레벨 (거래량 데이터가 있는 경우)
            if volume_data and len(volume_data) == len(price_data):
                volume_levels = self._detect_volume_based_levels(price_data, volume_data)
                levels.extend(volume_levels)
            
            # 강도별 정렬
            levels.sort(key=lambda x: x.strength, reverse=True)
            
            return levels
            
        except Exception as e:
            logger.error(f"자동 레벨 감지 오류: {e}")
            return []
    
    def _find_peaks(self, data: List[float], peak_type: str) -> List[Tuple[int, float]]:
        """고점/저점 찾기"""
        peaks = []
        window = 5
        
        for i in range(window, len(data) - window):
            if peak_type == 'high':
                if all(data[i] >= data[j] for j in range(i - window, i + window + 1)):
                    peaks.append((i, data[i]))
            else:  # low
                if all(data[i] <= data[j] for j in range(i - window, i + window + 1)):
                    peaks.append((i, data[i]))
        
        return peaks
    
    def _cluster_levels(self, peaks: List[Tuple[int, float]], level_type: str) -> List[SupportResistanceLevel]:
        """레벨 클러스터링"""
        levels = []
        
        if not peaks:
            return levels
        
        # 가격별 그룹핑
        price_groups = {}
        for idx, price in peaks:
            grouped = False
            for group_price in price_groups.keys():
                if abs(price - group_price) / group_price < self.touch_tolerance:
                    price_groups[group_price].append((idx, price))
                    grouped = True
                    break
            
            if not grouped:
                price_groups[price] = [(idx, price)]
        
        # 각 그룹에서 레벨 생성
        for group_price, touches in price_groups.items():
            if len(touches) >= self.min_touches:
                avg_price = np.mean([price for _, price in touches])
                strength = len(touches) / 10  # 터치 횟수 기반 강도
                confidence = min(1.0, strength / self.strength_threshold)
                
                levels.append(SupportResistanceLevel(
                    price=avg_price,
                    strength=strength,
                    type=level_type,
                    confidence=confidence,
                    touches=len(touches),
                    last_touch=datetime.now()  # 실제로는 타임스탬프 사용
                ))
        
        return levels
    
    def _detect_volume_based_levels(self, price_data: List[float], 
                                  volume_data: List[float]) -> List[SupportResistanceLevel]:
        """거래량 기반 레벨 감지"""
        levels = []
        
        # 거래량이 높은 가격대 찾기
        volume_threshold = np.percentile(volume_data, 80)
        
        for i, (price, volume) in enumerate(zip(price_data, volume_data)):
            if volume > volume_threshold:
                # 이미 감지된 레벨과 비교
                is_new_level = True
                for level in levels:
                    if abs(price - level.price) / level.price < self.touch_tolerance:
                        level.touches += 1
                        level.strength = min(1.0, level.touches / 5)
                        is_new_level = False
                        break
                
                if is_new_level:
                    levels.append(SupportResistanceLevel(
                        price=price,
                        strength=0.5,
                        type='volume_based',
                        confidence=0.7,
                        touches=1,
                        last_touch=datetime.now()
                    ))
        
        return levels
```

---

**마지막 업데이트**: 2025-01-26  
**프로젝트 상태**: 설계 완료, 개발 준비  
**다음 단계**: 기본 지표 계산기 구현 시작 