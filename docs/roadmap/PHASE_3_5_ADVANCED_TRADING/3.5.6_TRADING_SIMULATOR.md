# ğŸ® Phase 3.5.6: ê±°ë˜ ì‹œë®¬ë ˆì´í„° ì‹œìŠ¤í…œ

## ğŸ¯ ëª©í‘œ
- **ì •êµí•œ ë°±í…ŒìŠ¤íŒ… ì—”ì§„**: ë‹¤ì–‘í•œ ì‹œì¥ ì¡°ê±´ì—ì„œ ì „ëµ ê²€ì¦
- **ì›Œí¬í¬ì›Œë“œ í…ŒìŠ¤íŒ…**: ì‹œê°„ì— ë”°ë¥¸ ëª¨ë¸ ì„±ëŠ¥ ë³€í™” ë¶„ì„
- **ëª¬í…Œì¹´ë¥¼ë¡œ ì‹œë®¬ë ˆì´ì…˜**: í™•ë¥ ì  ì‹œë‚˜ë¦¬ì˜¤ ë¶„ì„
- **ë¦¬ìŠ¤í¬ ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸**: ê·¹ë‹¨ì  ì‹œì¥ ìƒí™© ëŒ€ì‘ ê²€ì¦

## ğŸ“Š ì„±ëŠ¥ ëª©í‘œ
- **ë°±í…ŒìŠ¤íŒ… ì†ë„**: 1ë…„ ë°ì´í„° < 30ì´ˆ
- **ì›Œí¬í¬ì›Œë“œ í…ŒìŠ¤íŠ¸**: 10ë…„ ë°ì´í„° < 5ë¶„
- **ëª¬í…Œì¹´ë¥¼ë¡œ ì‹œë®¬ë ˆì´ì…˜**: 10,000íšŒ < 10ë¶„
- **ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰**: < 2GB (ëŒ€ìš©ëŸ‰ ë°ì´í„° ì²˜ë¦¬ ì‹œ)

## ğŸ—ï¸ ì•„í‚¤í…ì²˜

```
advanced-trading/
â”œâ”€â”€ trading-simulator/
â”‚   â”œâ”€â”€ backtest-engine/
â”‚   â”‚   â”œâ”€â”€ simple-backtest.py
â”‚   â”‚   â”œâ”€â”€ walk-forward-backtest.py
â”‚   â”‚   â”œâ”€â”€ monte-carlo-simulation.py
â”‚   â”‚   â””â”€â”€ risk-scenario-test.py
â”‚   â”œâ”€â”€ data-provider/
â”‚   â”‚   â”œâ”€â”€ historical-data.py
â”‚   â”‚   â”œâ”€â”€ market-data-replay.py
â”‚   â”‚   â””â”€â”€ synthetic-data.py
â”‚   â”œâ”€â”€ strategy-executor/
â”‚   â”‚   â”œâ”€â”€ strategy-runner.py
â”‚   â”‚   â”œâ”€â”€ order-simulator.py
â”‚   â”‚   â””â”€â”€ slippage-model.py
â”‚   â”œâ”€â”€ performance-analyzer/
â”‚   â”‚   â”œâ”€â”€ metrics-calculator.py
â”‚   â”‚   â”œâ”€â”€ risk-analyzer.py
â”‚   â”‚   â””â”€â”€ report-generator.py
â”‚   â””â”€â”€ visualization/
â”‚       â”œâ”€â”€ performance-charts.py
â”‚       â”œâ”€â”€ equity-curve.py
â”‚       â””â”€â”€ risk-dashboard.py
```

## ğŸ”§ í•µì‹¬ êµ¬ì„± ìš”ì†Œ

### 1. ì •êµí•œ ë°±í…ŒìŠ¤íŒ… ì—”ì§„

```python
import pandas as pd
import numpy as np
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from datetime import datetime, timedelta
import logging

logger = logging.getLogger(__name__)

@dataclass
class BacktestConfig:
    """ë°±í…ŒìŠ¤íŒ… ì„¤ì •"""
    start_date: datetime
    end_date: datetime
    initial_capital: float
    commission_rate: float = 0.001
    slippage_model: str = 'fixed'
    slippage_bps: float = 1.0
    data_frequency: str = '1min'
    rebalance_frequency: str = 'daily'

class SophisticatedBacktestEngine:
    """ì •êµí•œ ë°±í…ŒìŠ¤íŒ… ì—”ì§„"""
    
    def __init__(self, config: BacktestConfig):
        self.config = config
        self.portfolio = Portfolio(config.initial_capital)
        self.trade_history = []
        self.equity_curve = []
        self.performance_metrics = {}
    
    def run_backtest(self, strategy, data: pd.DataFrame) -> Dict[str, Any]:
        """ë°±í…ŒìŠ¤íŒ… ì‹¤í–‰"""
        logger.info(f"ë°±í…ŒìŠ¤íŒ… ì‹œì‘: {self.config.start_date} ~ {self.config.end_date}")
        
        # ë°ì´í„° ì „ì²˜ë¦¬
        processed_data = self._preprocess_data(data)
        
        # ì „ëµ ì‹¤í–‰
        for timestamp, market_data in processed_data.iterrows():
            # ì‹œì¥ ë°ì´í„° ì—…ë°ì´íŠ¸
            self._update_market_data(market_data)
            
            # ì „ëµ ì‹ í˜¸ ìƒì„±
            signals = strategy.generate_signals(market_data)
            
            # ì£¼ë¬¸ ì‹¤í–‰
            self._execute_orders(signals, timestamp)
            
            # í¬íŠ¸í´ë¦¬ì˜¤ ì—…ë°ì´íŠ¸
            self._update_portfolio(timestamp)
            
            # ì„±ê³¼ ê¸°ë¡
            self._record_performance(timestamp)
        
        # ê²°ê³¼ ë¶„ì„
        return self._analyze_results()
    
    def _preprocess_data(self, data: pd.DataFrame) -> pd.DataFrame:
        """ë°ì´í„° ì „ì²˜ë¦¬"""
        # ê²°ì¸¡ê°’ ì²˜ë¦¬
        data = data.fillna(method='ffill')
        
        # ê¸°ìˆ ì  ì§€í‘œ ê³„ì‚°
        data = self._calculate_technical_indicators(data)
        
        # í•„í„°ë§
        mask = (data.index >= self.config.start_date) & (data.index <= self.config.end_date)
        return data[mask]
    
    def _calculate_technical_indicators(self, data: pd.DataFrame) -> pd.DataFrame:
        """ê¸°ìˆ ì  ì§€í‘œ ê³„ì‚°"""
        # ì´ë™í‰ê· 
        data['sma_20'] = data['close'].rolling(window=20).mean()
        data['sma_50'] = data['close'].rolling(window=50).mean()
        
        # RSI
        delta = data['close'].diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
        rs = gain / loss
        data['rsi'] = 100 - (100 / (1 + rs))
        
        # ë³¼ë¦°ì € ë°´ë“œ
        data['bb_middle'] = data['close'].rolling(window=20).mean()
        bb_std = data['close'].rolling(window=20).std()
        data['bb_upper'] = data['bb_middle'] + (bb_std * 2)
        data['bb_lower'] = data['bb_middle'] - (bb_std * 2)
        
        return data
    
    def _execute_orders(self, signals: Dict[str, Any], timestamp: datetime):
        """ì£¼ë¬¸ ì‹¤í–‰"""
        for symbol, signal in signals.items():
            if signal['action'] == 'buy':
                self._execute_buy_order(symbol, signal['quantity'], timestamp)
            elif signal['action'] == 'sell':
                self._execute_sell_order(symbol, signal['quantity'], timestamp)
    
    def _execute_buy_order(self, symbol: str, quantity: float, timestamp: datetime):
        """ë§¤ìˆ˜ ì£¼ë¬¸ ì‹¤í–‰"""
        current_price = self._get_current_price(symbol)
        
        # ìŠ¬ë¦¬í”¼ì§€ ì ìš©
        execution_price = self._apply_slippage(current_price, 'buy')
        
        # ìˆ˜ìˆ˜ë£Œ ê³„ì‚°
        commission = execution_price * quantity * self.config.commission_rate
        
        # ì£¼ë¬¸ ì‹¤í–‰
        if self.portfolio.cash >= (execution_price * quantity + commission):
            self.portfolio.buy(symbol, quantity, execution_price, commission)
            
            # ê±°ë˜ ê¸°ë¡
            self.trade_history.append({
                'timestamp': timestamp,
                'symbol': symbol,
                'action': 'buy',
                'quantity': quantity,
                'price': execution_price,
                'commission': commission
            })
    
    def _apply_slippage(self, price: float, side: str) -> float:
        """ìŠ¬ë¦¬í”¼ì§€ ì ìš©"""
        if self.config.slippage_model == 'fixed':
            slippage_bps = self.config.slippage_bps / 10000
            if side == 'buy':
                return price * (1 + slippage_bps)
            else:
                return price * (1 - slippage_bps)
        return price
    
    def _analyze_results(self) -> Dict[str, Any]:
        """ê²°ê³¼ ë¶„ì„"""
        equity_df = pd.DataFrame(self.equity_curve)
        
        # ê¸°ë³¸ ì„±ê³¼ ì§€í‘œ
        total_return = (equity_df['equity'].iloc[-1] / equity_df['equity'].iloc[0]) - 1
        annual_return = total_return * (252 / len(equity_df))
        
        # ë³€ë™ì„±
        daily_returns = equity_df['equity'].pct_change().dropna()
        volatility = daily_returns.std() * np.sqrt(252)
        
        # ìƒ¤í”„ ë¹„ìœ¨
        risk_free_rate = 0.02  # 2%
        sharpe_ratio = (annual_return - risk_free_rate) / volatility
        
        # ìµœëŒ€ ë‚™í­
        cumulative_returns = (1 + daily_returns).cumprod()
        running_max = cumulative_returns.expanding().max()
        drawdown = (cumulative_returns - running_max) / running_max
        max_drawdown = drawdown.min()
        
        return {
            'total_return': total_return,
            'annual_return': annual_return,
            'volatility': volatility,
            'sharpe_ratio': sharpe_ratio,
            'max_drawdown': max_drawdown,
            'trade_count': len(self.trade_history),
            'win_rate': self._calculate_win_rate(),
            'profit_factor': self._calculate_profit_factor(),
            'equity_curve': equity_df
        }
    
    def _calculate_win_rate(self) -> float:
        """ìŠ¹ë¥  ê³„ì‚°"""
        if not self.trade_history:
            return 0.0
        
        profitable_trades = sum(1 for trade in self.trade_history if trade.get('pnl', 0) > 0)
        return profitable_trades / len(self.trade_history)
    
    def _calculate_profit_factor(self) -> float:
        """ìˆ˜ìµ íŒ©í„° ê³„ì‚°"""
        gross_profit = sum(trade.get('pnl', 0) for trade in self.trade_history if trade.get('pnl', 0) > 0)
        gross_loss = abs(sum(trade.get('pnl', 0) for trade in self.trade_history if trade.get('pnl', 0) < 0))
        
        return gross_profit / gross_loss if gross_loss > 0 else float('inf')

class Portfolio:
    """í¬íŠ¸í´ë¦¬ì˜¤ ê´€ë¦¬"""
    
    def __init__(self, initial_cash: float):
        self.cash = initial_cash
        self.positions = {}
        self.total_value = initial_cash
    
    def buy(self, symbol: str, quantity: float, price: float, commission: float):
        """ë§¤ìˆ˜"""
        cost = price * quantity + commission
        self.cash -= cost
        
        if symbol in self.positions:
            # í‰ê·  ë§¤ìˆ˜ê°€ ê³„ì‚°
            total_quantity = self.positions[symbol]['quantity'] + quantity
            total_cost = (self.positions[symbol]['avg_price'] * self.positions[symbol]['quantity']) + cost
            self.positions[symbol] = {
                'quantity': total_quantity,
                'avg_price': total_cost / total_quantity
            }
        else:
            self.positions[symbol] = {
                'quantity': quantity,
                'avg_price': price
            }
    
    def sell(self, symbol: str, quantity: float, price: float, commission: float):
        """ë§¤ë„"""
        if symbol not in self.positions or self.positions[symbol]['quantity'] < quantity:
            return False
        
        proceeds = price * quantity - commission
        self.cash += proceeds
        
        self.positions[symbol]['quantity'] -= quantity
        if self.positions[symbol]['quantity'] == 0:
            del self.positions[symbol]
        
        return True
    
    def get_total_value(self, current_prices: Dict[str, float]) -> float:
        """ì´ ìì‚° ê°€ì¹˜ ê³„ì‚°"""
        portfolio_value = self.cash
        for symbol, position in self.positions.items():
            if symbol in current_prices:
                portfolio_value += position['quantity'] * current_prices[symbol]
        return portfolio_value
```

### 2. ì›Œí¬í¬ì›Œë“œ í…ŒìŠ¤íŒ…

```python
class WalkForwardBacktest:
    """ì›Œí¬í¬ì›Œë“œ ë°±í…ŒìŠ¤íŒ…"""
    
    def __init__(self, train_period: int, test_period: int, step_size: int):
        self.train_period = train_period  # í›ˆë ¨ ê¸°ê°„ (ì¼)
        self.test_period = test_period    # í…ŒìŠ¤íŠ¸ ê¸°ê°„ (ì¼)
        self.step_size = step_size        # ì´ë™ í¬ê¸° (ì¼)
        self.results = []
    
    def run_walk_forward(self, strategy_class, data: pd.DataFrame, 
                        strategy_params: Dict[str, Any]) -> List[Dict[str, Any]]:
        """ì›Œí¬í¬ì›Œë“œ í…ŒìŠ¤íŒ… ì‹¤í–‰"""
        start_date = data.index[0]
        end_date = data.index[-1]
        
        current_date = start_date + timedelta(days=self.train_period)
        
        while current_date + timedelta(days=self.test_period) <= end_date:
            # í›ˆë ¨ ê¸°ê°„
            train_start = current_date - timedelta(days=self.train_period)
            train_end = current_date
            train_data = data[(data.index >= train_start) & (data.index < train_end)]
            
            # í…ŒìŠ¤íŠ¸ ê¸°ê°„
            test_start = current_date
            test_end = current_date + timedelta(days=self.test_period)
            test_data = data[(data.index >= test_start) & (data.index < test_end)]
            
            # ì „ëµ í›ˆë ¨
            strategy = strategy_class(**strategy_params)
            strategy.train(train_data)
            
            # í…ŒìŠ¤íŠ¸ ì‹¤í–‰
            backtest_config = BacktestConfig(
                start_date=test_start,
                end_date=test_end,
                initial_capital=100000
            )
            
            backtest_engine = SophisticatedBacktestEngine(backtest_config)
            test_results = backtest_engine.run_backtest(strategy, test_data)
            
            # ê²°ê³¼ ì €ì¥
            self.results.append({
                'train_period': (train_start, train_end),
                'test_period': (test_start, test_end),
                'results': test_results,
                'strategy_params': strategy_params
            })
            
            # ë‹¤ìŒ ê¸°ê°„ìœ¼ë¡œ ì´ë™
            current_date += timedelta(days=self.step_size)
        
        return self.results
    
    def analyze_walk_forward_results(self) -> Dict[str, Any]:
        """ì›Œí¬í¬ì›Œë“œ ê²°ê³¼ ë¶„ì„"""
        if not self.results:
            return {}
        
        # ì„±ê³¼ ì§€í‘œ ì¶”ì¶œ
        returns = [result['results']['annual_return'] for result in self.results]
        sharpe_ratios = [result['results']['sharpe_ratio'] for result in self.results]
        max_drawdowns = [result['results']['max_drawdown'] for result in self.results]
        
        # ì„±ê³¼ ë³€í™” ë¶„ì„
        performance_trend = self._analyze_performance_trend(returns)
        
        # ì•ˆì •ì„± ë¶„ì„
        stability_metrics = self._analyze_stability(returns, sharpe_ratios)
        
        return {
            'avg_return': np.mean(returns),
            'avg_sharpe': np.mean(sharpe_ratios),
            'avg_max_drawdown': np.mean(max_drawdowns),
            'return_std': np.std(returns),
            'sharpe_std': np.std(sharpe_ratios),
            'performance_trend': performance_trend,
            'stability_metrics': stability_metrics,
            'total_periods': len(self.results)
        }
    
    def _analyze_performance_trend(self, returns: List[float]) -> Dict[str, Any]:
        """ì„±ê³¼ íŠ¸ë Œë“œ ë¶„ì„"""
        if len(returns) < 2:
            return {'trend': 'insufficient_data'}
        
        # ì„ í˜• íšŒê·€ë¡œ íŠ¸ë Œë“œ ë¶„ì„
        x = np.arange(len(returns))
        slope, intercept = np.polyfit(x, returns, 1)
        
        if slope > 0.001:
            trend = 'improving'
        elif slope < -0.001:
            trend = 'declining'
        else:
            trend = 'stable'
        
        return {
            'trend': trend,
            'slope': slope,
            'r_squared': np.corrcoef(x, returns)[0, 1] ** 2
        }
    
    def _analyze_stability(self, returns: List[float], 
                          sharpe_ratios: List[float]) -> Dict[str, Any]:
        """ì•ˆì •ì„± ë¶„ì„"""
        return {
            'return_consistency': 1 - (np.std(returns) / np.mean(returns)) if np.mean(returns) != 0 else 0,
            'sharpe_consistency': 1 - (np.std(sharpe_ratios) / np.mean(sharpe_ratios)) if np.mean(sharpe_ratios) != 0 else 0,
            'positive_periods': sum(1 for r in returns if r > 0) / len(returns)
        }
```

### 3. ëª¬í…Œì¹´ë¥¼ë¡œ ì‹œë®¬ë ˆì´ì…˜

```python
class MonteCarloSimulation:
    """ëª¬í…Œì¹´ë¥¼ë¡œ ì‹œë®¬ë ˆì´ì…˜"""
    
    def __init__(self, n_simulations: int = 10000):
        self.n_simulations = n_simulations
        self.simulation_results = []
    
    def run_monte_carlo(self, strategy_results: Dict[str, Any], 
                       time_horizon: int = 252) -> Dict[str, Any]:
        """ëª¬í…Œì¹´ë¥¼ë¡œ ì‹œë®¬ë ˆì´ì…˜ ì‹¤í–‰"""
        # ì‹¤ì œ ìˆ˜ìµë¥  ë¶„í¬ì—ì„œ ìƒ˜í”Œë§
        daily_returns = strategy_results['equity_curve']['equity'].pct_change().dropna()
        
        # ëª¬í…Œì¹´ë¥¼ë¡œ ì‹œë®¬ë ˆì´ì…˜
        for i in range(self.n_simulations):
            # ëœë¤ ìƒ˜í”Œë§
            simulated_returns = np.random.choice(
                daily_returns, 
                size=time_horizon, 
                replace=True
            )
            
            # ëˆ„ì  ìˆ˜ìµë¥  ê³„ì‚°
            cumulative_return = np.prod(1 + simulated_returns) - 1
            
            # ìµœëŒ€ ë‚™í­ ê³„ì‚°
            cumulative_curve = np.cumprod(1 + simulated_returns)
            running_max = np.maximum.accumulate(cumulative_curve)
            drawdown = (cumulative_curve - running_max) / running_max
            max_drawdown = np.min(drawdown)
            
            self.simulation_results.append({
                'simulation_id': i,
                'cumulative_return': cumulative_return,
                'max_drawdown': max_drawdown,
                'final_value': 1 + cumulative_return
            })
        
        return self._analyze_simulation_results()
    
    def _analyze_simulation_results(self) -> Dict[str, Any]:
        """ì‹œë®¬ë ˆì´ì…˜ ê²°ê³¼ ë¶„ì„"""
        returns = [result['cumulative_return'] for result in self.simulation_results]
        max_drawdowns = [result['max_drawdown'] for result in self.simulation_results]
        final_values = [result['final_value'] for result in self.simulation_results]
        
        # ë¶„ìœ„ìˆ˜ ê³„ì‚°
        percentiles = [5, 25, 50, 75, 95]
        return_percentiles = np.percentile(returns, percentiles)
        drawdown_percentiles = np.percentile(max_drawdowns, percentiles)
        
        # ìœ„í—˜ ì§€í‘œ
        var_95 = np.percentile(returns, 5)  # 95% VaR
        cvar_95 = np.mean([r for r in returns if r <= var_95])  # 95% CVaR
        
        # ì„±ê³µ í™•ë¥ 
        success_probability = sum(1 for r in returns if r > 0) / len(returns)
        
        return {
            'mean_return': np.mean(returns),
            'std_return': np.std(returns),
            'mean_drawdown': np.mean(max_drawdowns),
            'var_95': var_95,
            'cvar_95': cvar_95,
            'success_probability': success_probability,
            'return_percentiles': dict(zip(percentiles, return_percentiles)),
            'drawdown_percentiles': dict(zip(percentiles, drawdown_percentiles)),
            'best_case': max(returns),
            'worst_case': min(returns),
            'n_simulations': self.n_simulations
        }
    
    def generate_scenario_analysis(self, strategy_results: Dict[str, Any]) -> Dict[str, Any]:
        """ì‹œë‚˜ë¦¬ì˜¤ ë¶„ì„"""
        scenarios = {
            'bull_market': self._simulate_bull_market(strategy_results),
            'bear_market': self._simulate_bear_market(strategy_results),
            'high_volatility': self._simulate_high_volatility(strategy_results),
            'low_volatility': self._simulate_low_volatility(strategy_results)
        }
        
        return scenarios
    
    def _simulate_bull_market(self, strategy_results: Dict[str, Any]) -> Dict[str, Any]:
        """ìƒìŠ¹ì¥ ì‹œë‚˜ë¦¬ì˜¤"""
        daily_returns = strategy_results['equity_curve']['equity'].pct_change().dropna()
        
        # ìƒìŠ¹ì¥ ì¡°ê±´: í‰ê·  ìˆ˜ìµë¥  ì¦ê°€, ë³€ë™ì„± ê°ì†Œ
        bull_returns = daily_returns * 1.5 + 0.001  # ìˆ˜ìµë¥  50% ì¦ê°€, ì¼ì¼ 0.1% ì¶”ê°€ ìˆ˜ìµ
        
        return self._run_scenario_simulation(bull_returns)
    
    def _simulate_bear_market(self, strategy_results: Dict[str, Any]) -> Dict[str, Any]:
        """í•˜ë½ì¥ ì‹œë‚˜ë¦¬ì˜¤"""
        daily_returns = strategy_results['equity_curve']['equity'].pct_change().dropna()
        
        # í•˜ë½ì¥ ì¡°ê±´: í‰ê·  ìˆ˜ìµë¥  ê°ì†Œ, ë³€ë™ì„± ì¦ê°€
        bear_returns = daily_returns * 0.5 - 0.002  # ìˆ˜ìµë¥  50% ê°ì†Œ, ì¼ì¼ 0.2% ì¶”ê°€ ì†ì‹¤
        
        return self._run_scenario_simulation(bear_returns)
    
    def _simulate_high_volatility(self, strategy_results: Dict[str, Any]) -> Dict[str, Any]:
        """ê³ ë³€ë™ì„± ì‹œë‚˜ë¦¬ì˜¤"""
        daily_returns = strategy_results['equity_curve']['equity'].pct_change().dropna()
        
        # ê³ ë³€ë™ì„± ì¡°ê±´: ë³€ë™ì„± 2ë°° ì¦ê°€
        high_vol_returns = daily_returns * 2
        
        return self._run_scenario_simulation(high_vol_returns)
    
    def _simulate_low_volatility(self, strategy_results: Dict[str, Any]) -> Dict[str, Any]:
        """ì €ë³€ë™ì„± ì‹œë‚˜ë¦¬ì˜¤"""
        daily_returns = strategy_results['equity_curve']['equity'].pct_change().dropna()
        
        # ì €ë³€ë™ì„± ì¡°ê±´: ë³€ë™ì„± 50% ê°ì†Œ
        low_vol_returns = daily_returns * 0.5
        
        return self._run_scenario_simulation(low_vol_returns)
    
    def _run_scenario_simulation(self, scenario_returns: pd.Series) -> Dict[str, Any]:
        """ì‹œë‚˜ë¦¬ì˜¤ë³„ ì‹œë®¬ë ˆì´ì…˜ ì‹¤í–‰"""
        scenario_results = []
        
        for i in range(self.n_simulations):
            simulated_returns = np.random.choice(
                scenario_returns, 
                size=252, 
                replace=True
            )
            
            cumulative_return = np.prod(1 + simulated_returns) - 1
            scenario_results.append(cumulative_return)
        
        return {
            'mean_return': np.mean(scenario_results),
            'std_return': np.std(scenario_results),
            'var_95': np.percentile(scenario_results, 5),
            'success_probability': sum(1 for r in scenario_results if r > 0) / len(scenario_results)
        }
```

### 4. ë¦¬ìŠ¤í¬ ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸

```python
class RiskScenarioTest:
    """ë¦¬ìŠ¤í¬ ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸"""
    
    def __init__(self):
        self.scenarios = {
            'market_crash': self._market_crash_scenario,
            'flash_crash': self._flash_crash_scenario,
            'liquidity_crisis': self._liquidity_crisis_scenario,
            'volatility_spike': self._volatility_spike_scenario,
            'correlation_breakdown': self._correlation_breakdown_scenario
        }
    
    def run_risk_scenarios(self, strategy_results: Dict[str, Any], 
                          portfolio: Dict[str, float]) -> Dict[str, Any]:
        """ë¦¬ìŠ¤í¬ ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸ ì‹¤í–‰"""
        scenario_results = {}
        
        for scenario_name, scenario_func in self.scenarios.items():
            logger.info(f"ë¦¬ìŠ¤í¬ ì‹œë‚˜ë¦¬ì˜¤ ì‹¤í–‰: {scenario_name}")
            
            # ì‹œë‚˜ë¦¬ì˜¤ë³„ ì‹œì¥ ë°ì´í„° ìƒì„±
            scenario_data = scenario_func(strategy_results)
            
            # ì‹œë‚˜ë¦¬ì˜¤ í•˜ì—ì„œ ì „ëµ ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
            scenario_performance = self._test_scenario_performance(
                strategy_results, scenario_data, portfolio
            )
            
            scenario_results[scenario_name] = scenario_performance
        
        return scenario_results
    
    def _market_crash_scenario(self, strategy_results: Dict[str, Any]) -> Dict[str, Any]:
        """ì‹œì¥ í­ë½ ì‹œë‚˜ë¦¬ì˜¤"""
        return {
            'market_shock': -0.20,  # 20% í•˜ë½
            'volatility_multiplier': 3.0,  # ë³€ë™ì„± 3ë°°
            'correlation_increase': 0.8,  # ìƒê´€ê´€ê³„ ì¦ê°€
            'liquidity_reduction': 0.5,  # ìœ ë™ì„± 50% ê°ì†Œ
            'duration': 30  # 30ì¼ ì§€ì†
        }
    
    def _flash_crash_scenario(self, strategy_results: Dict[str, Any]) -> Dict[str, Any]:
        """í”Œë˜ì‹œ í¬ë˜ì‹œ ì‹œë‚˜ë¦¬ì˜¤"""
        return {
            'market_shock': -0.10,  # 10% ê¸‰ë½
            'volatility_multiplier': 5.0,  # ë³€ë™ì„± 5ë°°
            'correlation_increase': 0.9,  # ìƒê´€ê´€ê³„ ê¸‰ì¦
            'liquidity_reduction': 0.8,  # ìœ ë™ì„± 80% ê°ì†Œ
            'duration': 1  # 1ì¼ ì§€ì†
        }
    
    def _liquidity_crisis_scenario(self, strategy_results: Dict[str, Any]) -> Dict[str, Any]:
        """ìœ ë™ì„± ìœ„ê¸° ì‹œë‚˜ë¦¬ì˜¤"""
        return {
            'market_shock': -0.05,  # 5% í•˜ë½
            'volatility_multiplier': 2.0,  # ë³€ë™ì„± 2ë°°
            'correlation_increase': 0.6,  # ìƒê´€ê´€ê³„ ì¦ê°€
            'liquidity_reduction': 0.9,  # ìœ ë™ì„± 90% ê°ì†Œ
            'duration': 60  # 60ì¼ ì§€ì†
        }
    
    def _volatility_spike_scenario(self, strategy_results: Dict[str, Any]) -> Dict[str, Any]:
        """ë³€ë™ì„± ê¸‰ì¦ ì‹œë‚˜ë¦¬ì˜¤"""
        return {
            'market_shock': 0.0,  # ê°€ê²© ë³€í™” ì—†ìŒ
            'volatility_multiplier': 4.0,  # ë³€ë™ì„± 4ë°°
            'correlation_increase': 0.7,  # ìƒê´€ê´€ê³„ ì¦ê°€
            'liquidity_reduction': 0.3,  # ìœ ë™ì„± 30% ê°ì†Œ
            'duration': 15  # 15ì¼ ì§€ì†
        }
    
    def _correlation_breakdown_scenario(self, strategy_results: Dict[str, Any]) -> Dict[str, Any]:
        """ìƒê´€ê´€ê³„ ë¶•ê´´ ì‹œë‚˜ë¦¬ì˜¤"""
        return {
            'market_shock': -0.03,  # 3% í•˜ë½
            'volatility_multiplier': 1.5,  # ë³€ë™ì„± 1.5ë°°
            'correlation_increase': -0.5,  # ìƒê´€ê´€ê³„ ì—­ì „
            'liquidity_reduction': 0.2,  # ìœ ë™ì„± 20% ê°ì†Œ
            'duration': 45  # 45ì¼ ì§€ì†
        }
    
    def _test_scenario_performance(self, strategy_results: Dict[str, Any], 
                                 scenario_data: Dict[str, Any], 
                                 portfolio: Dict[str, float]) -> Dict[str, Any]:
        """ì‹œë‚˜ë¦¬ì˜¤ í•˜ì—ì„œ ì„±ëŠ¥ í…ŒìŠ¤íŠ¸"""
        # ì‹œë‚˜ë¦¬ì˜¤ ì ìš©ëœ ìˆ˜ìµë¥  ê³„ì‚°
        original_returns = strategy_results['equity_curve']['equity'].pct_change().dropna()
        
        # ì‹œë‚˜ë¦¬ì˜¤ íš¨ê³¼ ì ìš©
        scenario_returns = self._apply_scenario_effects(original_returns, scenario_data)
        
        # í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¹˜ ë³€í™” ê³„ì‚°
        portfolio_value_changes = self._calculate_portfolio_changes(
            scenario_returns, portfolio
        )
        
        # ë¦¬ìŠ¤í¬ ì§€í‘œ ê³„ì‚°
        risk_metrics = self._calculate_risk_metrics(portfolio_value_changes)
        
        return {
            'scenario_data': scenario_data,
            'portfolio_changes': portfolio_value_changes,
            'risk_metrics': risk_metrics,
            'worst_case_loss': min(portfolio_value_changes),
            'recovery_time': self._estimate_recovery_time(portfolio_value_changes)
        }
    
    def _apply_scenario_effects(self, returns: pd.Series, 
                              scenario_data: Dict[str, Any]) -> pd.Series:
        """ì‹œë‚˜ë¦¬ì˜¤ íš¨ê³¼ ì ìš©"""
        # ê¸°ë³¸ ì‹œì¥ ì¶©ê²©
        scenario_returns = returns + scenario_data['market_shock'] / 252
        
        # ë³€ë™ì„± ì¦ê°€
        volatility_multiplier = scenario_data['volatility_multiplier']
        scenario_returns = scenario_returns * volatility_multiplier
        
        # ìƒê´€ê´€ê³„ ë³€í™” (í¬íŠ¸í´ë¦¬ì˜¤ ë‹¤ê°í™” íš¨ê³¼ ê°ì†Œ)
        correlation_effect = scenario_data['correlation_increase']
        if correlation_effect > 0:
            # ìƒê´€ê´€ê³„ ì¦ê°€ë¡œ ì¸í•œ ì¶”ê°€ ë¦¬ìŠ¤í¬
            scenario_returns = scenario_returns * (1 + correlation_effect * 0.1)
        
        return scenario_returns
    
    def _calculate_portfolio_changes(self, returns: pd.Series, 
                                   portfolio: Dict[str, float]) -> List[float]:
        """í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¹˜ ë³€í™” ê³„ì‚°"""
        cumulative_returns = (1 + returns).cumprod()
        portfolio_changes = []
        
        for i, cumulative_return in enumerate(cumulative_returns):
            # í¬íŠ¸í´ë¦¬ì˜¤ ê°€ì¹˜ ë³€í™”
            portfolio_value = sum(
                weight * cumulative_return 
                for weight in portfolio.values()
            )
            portfolio_changes.append(portfolio_value - 1)
        
        return portfolio_changes
    
    def _calculate_risk_metrics(self, portfolio_changes: List[float]) -> Dict[str, float]:
        """ë¦¬ìŠ¤í¬ ì§€í‘œ ê³„ì‚°"""
        changes_array = np.array(portfolio_changes)
        
        return {
            'max_loss': np.min(changes_array),
            'var_95': np.percentile(changes_array, 5),
            'cvar_95': np.mean(changes_array[changes_array <= np.percentile(changes_array, 5)]),
            'volatility': np.std(changes_array),
            'skewness': self._calculate_skewness(changes_array),
            'kurtosis': self._calculate_kurtosis(changes_array)
        }
    
    def _calculate_skewness(self, data: np.ndarray) -> float:
        """ì™œë„ ê³„ì‚°"""
        mean = np.mean(data)
        std = np.std(data)
        if std == 0:
            return 0
        return np.mean(((data - mean) / std) ** 3)
    
    def _calculate_kurtosis(self, data: np.ndarray) -> float:
        """ì²¨ë„ ê³„ì‚°"""
        mean = np.mean(data)
        std = np.std(data)
        if std == 0:
            return 0
        return np.mean(((data - mean) / std) ** 4) - 3
    
    def _estimate_recovery_time(self, portfolio_changes: List[float]) -> int:
        """íšŒë³µ ì‹œê°„ ì¶”ì •"""
        if not portfolio_changes:
            return 0
        
        # ìµœëŒ€ ì†ì‹¤ ì§€ì  ì°¾ê¸°
        max_loss_idx = np.argmin(portfolio_changes)
        max_loss = portfolio_changes[max_loss_idx]
        
        # íšŒë³µ ì§€ì  ì°¾ê¸° (ìµœëŒ€ ì†ì‹¤ì˜ 50% íšŒë³µ)
        recovery_threshold = max_loss * 0.5
        
        for i in range(max_loss_idx + 1, len(portfolio_changes)):
            if portfolio_changes[i] >= recovery_threshold:
                return i - max_loss_idx
        
        return len(portfolio_changes) - max_loss_idx  # íšŒë³µí•˜ì§€ ëª»í•œ ê²½ìš°
```

## ğŸ“ˆ ì„±ê³¼ ì§€í‘œ

### ë°±í…ŒìŠ¤íŒ… ì„±ê³¼
- **ì´ ìˆ˜ìµë¥ **: ì—°ê°„ 15-25%
- **ìƒ¤í”„ ë¹„ìœ¨**: > 1.5
- **ìµœëŒ€ ë‚™í­**: < 15%
- **ìŠ¹ë¥ **: > 55%
- **ìˆ˜ìµ íŒ©í„°**: > 1.5

### ì›Œí¬í¬ì›Œë“œ ì„±ê³¼
- **ì„±ê³¼ ì•ˆì •ì„±**: ì—°ê°„ ìˆ˜ìµë¥  í‘œì¤€í¸ì°¨ < 10%
- **íŠ¸ë Œë“œ ì§€ì†ì„±**: ì„±ê³¼ ê°œì„ /ì•ˆì •ì  íŠ¸ë Œë“œ
- **ì ì‘ì„±**: ë‹¤ì–‘í•œ ì‹œì¥ í™˜ê²½ì—ì„œ ì¼ê´€ëœ ì„±ê³¼

### ëª¬í…Œì¹´ë¥¼ë¡œ ì‹œë®¬ë ˆì´ì…˜
- **ì„±ê³µ í™•ë¥ **: > 60%
- **95% VaR**: > -20%
- **ê·¹ë‹¨ì  ì†ì‹¤**: < -30%

### ë¦¬ìŠ¤í¬ ì‹œë‚˜ë¦¬ì˜¤
- **ì‹œì¥ í­ë½ ëŒ€ì‘**: ì†ì‹¤ < 25%
- **ìœ ë™ì„± ìœ„ê¸° ëŒ€ì‘**: ì†ì‹¤ < 15%
- **íšŒë³µ ì‹œê°„**: < 90ì¼

## ğŸ”„ ê°œë°œ ë¡œë“œë§µ

### 1ë‹¨ê³„: ê¸°ë³¸ ë°±í…ŒìŠ¤íŒ… ì—”ì§„ (2025-03-01 ~ 2025-03-15)
- [x] ê¸°ë³¸ ë°±í…ŒìŠ¤íŒ… ì—”ì§„ êµ¬í˜„
- [x] í¬íŠ¸í´ë¦¬ì˜¤ ê´€ë¦¬ ì‹œìŠ¤í…œ
- [x] ì„±ê³¼ ì§€í‘œ ê³„ì‚°
- [ ] ìŠ¬ë¦¬í”¼ì§€ ëª¨ë¸ êµ¬í˜„
- [ ] ìˆ˜ìˆ˜ë£Œ ëª¨ë¸ êµ¬í˜„

### 2ë‹¨ê³„: ì›Œí¬í¬ì›Œë“œ í…ŒìŠ¤íŒ… (2025-03-16 ~ 2025-03-31)
- [ ] ì›Œí¬í¬ì›Œë“œ ë°±í…ŒìŠ¤íŒ… êµ¬í˜„
- [ ] ì„±ê³¼ íŠ¸ë Œë“œ ë¶„ì„
- [ ] ì•ˆì •ì„± ì§€í‘œ ê³„ì‚°
- [ ] ì‹œê°í™” ëŒ€ì‹œë³´ë“œ

### 3ë‹¨ê³„: ëª¬í…Œì¹´ë¥¼ë¡œ ì‹œë®¬ë ˆì´ì…˜ (2025-04-01 ~ 2025-04-15)
- [ ] ëª¬í…Œì¹´ë¥¼ë¡œ ì‹œë®¬ë ˆì´ì…˜ êµ¬í˜„
- [ ] ì‹œë‚˜ë¦¬ì˜¤ ë¶„ì„
- [ ] ìœ„í—˜ ì§€í‘œ ê³„ì‚°
- [ ] í™•ë¥ ì  ì˜ˆì¸¡ ëª¨ë¸

### 4ë‹¨ê³„: ë¦¬ìŠ¤í¬ ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸ (2025-04-16 ~ 2025-04-30)
- [ ] ë¦¬ìŠ¤í¬ ì‹œë‚˜ë¦¬ì˜¤ ì •ì˜
- [ ] ê·¹ë‹¨ì  ìƒí™© ì‹œë®¬ë ˆì´ì…˜
- [ ] íšŒë³µ ì‹œê°„ ë¶„ì„
- [ ] ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸

### 5ë‹¨ê³„: í†µí•© ë° ìµœì í™” (2025-05-01 ~ 2025-05-15)
- [ ] ëª¨ë“  ëª¨ë“ˆ í†µí•©
- [ ] ì„±ëŠ¥ ìµœì í™”
- [ ] ì‚¬ìš©ì ì¸í„°í˜ì´ìŠ¤
- [ ] ë¬¸ì„œí™” ì™„ë£Œ

## ğŸ”— ê´€ë ¨ ë¬¸ì„œ
- [ê¸°ìˆ ì  ì§€í‘œ ë¶„ì„](3.5.1_TECHNICAL_ANALYSIS.md)
- [ê±°ë˜ ì „ëµ ë¼ì´ë¸ŒëŸ¬ë¦¬](3.5.2_TRADING_STRATEGIES.md)
- [ê³ ê¸‰ ìœ„í—˜ ê´€ë¦¬](3.5.7_ADVANCED_RISK_MANAGEMENT.md)
- [í¬íŠ¸í´ë¦¬ì˜¤ ìµœì í™”](3.5.10_PORTFOLIO_OPTIMIZATION.md) 