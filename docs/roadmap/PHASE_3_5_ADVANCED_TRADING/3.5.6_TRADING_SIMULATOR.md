# 🎮 Phase 3.5.6: 거래 시뮬레이터 시스템

## 🎯 목표
- **정교한 백테스팅 엔진**: 다양한 시장 조건에서 전략 검증
- **워크포워드 테스팅**: 시간에 따른 모델 성능 변화 분석
- **몬테카를로 시뮬레이션**: 확률적 시나리오 분석
- **리스크 시나리오 테스트**: 극단적 시장 상황 대응 검증

## 📊 성능 목표
- **백테스팅 속도**: 1년 데이터 < 30초
- **워크포워드 테스트**: 10년 데이터 < 5분
- **몬테카를로 시뮬레이션**: 10,000회 < 10분
- **메모리 사용량**: < 2GB (대용량 데이터 처리 시)

## 🏗️ 아키텍처

```
advanced-trading/
├── trading-simulator/
│   ├── backtest-engine/
│   │   ├── simple-backtest.py
│   │   ├── walk-forward-backtest.py
│   │   ├── monte-carlo-simulation.py
│   │   └── risk-scenario-test.py
│   ├── data-provider/
│   │   ├── historical-data.py
│   │   ├── market-data-replay.py
│   │   └── synthetic-data.py
│   ├── strategy-executor/
│   │   ├── strategy-runner.py
│   │   ├── order-simulator.py
│   │   └── slippage-model.py
│   ├── performance-analyzer/
│   │   ├── metrics-calculator.py
│   │   ├── risk-analyzer.py
│   │   └── report-generator.py
│   └── visualization/
│       ├── performance-charts.py
│       ├── equity-curve.py
│       └── risk-dashboard.py
```

## 🔧 핵심 구성 요소

### 1. 정교한 백테스팅 엔진

```python
import pandas as pd
import numpy as np
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
from datetime import datetime, timedelta
import logging

logger = logging.getLogger(__name__)

@dataclass
class BacktestConfig:
    """백테스팅 설정"""
    start_date: datetime
    end_date: datetime
    initial_capital: float
    commission_rate: float = 0.001
    slippage_model: str = 'fixed'
    slippage_bps: float = 1.0
    data_frequency: str = '1min'
    rebalance_frequency: str = 'daily'

class SophisticatedBacktestEngine:
    """정교한 백테스팅 엔진"""
    
    def __init__(self, config: BacktestConfig):
        self.config = config
        self.portfolio = Portfolio(config.initial_capital)
        self.trade_history = []
        self.equity_curve = []
        self.performance_metrics = {}
    
    def run_backtest(self, strategy, data: pd.DataFrame) -> Dict[str, Any]:
        """백테스팅 실행"""
        logger.info(f"백테스팅 시작: {self.config.start_date} ~ {self.config.end_date}")
        
        # 데이터 전처리
        processed_data = self._preprocess_data(data)
        
        # 전략 실행
        for timestamp, market_data in processed_data.iterrows():
            # 시장 데이터 업데이트
            self._update_market_data(market_data)
            
            # 전략 신호 생성
            signals = strategy.generate_signals(market_data)
            
            # 주문 실행
            self._execute_orders(signals, timestamp)
            
            # 포트폴리오 업데이트
            self._update_portfolio(timestamp)
            
            # 성과 기록
            self._record_performance(timestamp)
        
        # 결과 분석
        return self._analyze_results()
    
    def _preprocess_data(self, data: pd.DataFrame) -> pd.DataFrame:
        """데이터 전처리"""
        # 결측값 처리
        data = data.fillna(method='ffill')
        
        # 기술적 지표 계산
        data = self._calculate_technical_indicators(data)
        
        # 필터링
        mask = (data.index >= self.config.start_date) & (data.index <= self.config.end_date)
        return data[mask]
    
    def _calculate_technical_indicators(self, data: pd.DataFrame) -> pd.DataFrame:
        """기술적 지표 계산"""
        # 이동평균
        data['sma_20'] = data['close'].rolling(window=20).mean()
        data['sma_50'] = data['close'].rolling(window=50).mean()
        
        # RSI
        delta = data['close'].diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
        rs = gain / loss
        data['rsi'] = 100 - (100 / (1 + rs))
        
        # 볼린저 밴드
        data['bb_middle'] = data['close'].rolling(window=20).mean()
        bb_std = data['close'].rolling(window=20).std()
        data['bb_upper'] = data['bb_middle'] + (bb_std * 2)
        data['bb_lower'] = data['bb_middle'] - (bb_std * 2)
        
        return data
    
    def _execute_orders(self, signals: Dict[str, Any], timestamp: datetime):
        """주문 실행"""
        for symbol, signal in signals.items():
            if signal['action'] == 'buy':
                self._execute_buy_order(symbol, signal['quantity'], timestamp)
            elif signal['action'] == 'sell':
                self._execute_sell_order(symbol, signal['quantity'], timestamp)
    
    def _execute_buy_order(self, symbol: str, quantity: float, timestamp: datetime):
        """매수 주문 실행"""
        current_price = self._get_current_price(symbol)
        
        # 슬리피지 적용
        execution_price = self._apply_slippage(current_price, 'buy')
        
        # 수수료 계산
        commission = execution_price * quantity * self.config.commission_rate
        
        # 주문 실행
        if self.portfolio.cash >= (execution_price * quantity + commission):
            self.portfolio.buy(symbol, quantity, execution_price, commission)
            
            # 거래 기록
            self.trade_history.append({
                'timestamp': timestamp,
                'symbol': symbol,
                'action': 'buy',
                'quantity': quantity,
                'price': execution_price,
                'commission': commission
            })
    
    def _apply_slippage(self, price: float, side: str) -> float:
        """슬리피지 적용"""
        if self.config.slippage_model == 'fixed':
            slippage_bps = self.config.slippage_bps / 10000
            if side == 'buy':
                return price * (1 + slippage_bps)
            else:
                return price * (1 - slippage_bps)
        return price
    
    def _analyze_results(self) -> Dict[str, Any]:
        """결과 분석"""
        equity_df = pd.DataFrame(self.equity_curve)
        
        # 기본 성과 지표
        total_return = (equity_df['equity'].iloc[-1] / equity_df['equity'].iloc[0]) - 1
        annual_return = total_return * (252 / len(equity_df))
        
        # 변동성
        daily_returns = equity_df['equity'].pct_change().dropna()
        volatility = daily_returns.std() * np.sqrt(252)
        
        # 샤프 비율
        risk_free_rate = 0.02  # 2%
        sharpe_ratio = (annual_return - risk_free_rate) / volatility
        
        # 최대 낙폭
        cumulative_returns = (1 + daily_returns).cumprod()
        running_max = cumulative_returns.expanding().max()
        drawdown = (cumulative_returns - running_max) / running_max
        max_drawdown = drawdown.min()
        
        return {
            'total_return': total_return,
            'annual_return': annual_return,
            'volatility': volatility,
            'sharpe_ratio': sharpe_ratio,
            'max_drawdown': max_drawdown,
            'trade_count': len(self.trade_history),
            'win_rate': self._calculate_win_rate(),
            'profit_factor': self._calculate_profit_factor(),
            'equity_curve': equity_df
        }
    
    def _calculate_win_rate(self) -> float:
        """승률 계산"""
        if not self.trade_history:
            return 0.0
        
        profitable_trades = sum(1 for trade in self.trade_history if trade.get('pnl', 0) > 0)
        return profitable_trades / len(self.trade_history)
    
    def _calculate_profit_factor(self) -> float:
        """수익 팩터 계산"""
        gross_profit = sum(trade.get('pnl', 0) for trade in self.trade_history if trade.get('pnl', 0) > 0)
        gross_loss = abs(sum(trade.get('pnl', 0) for trade in self.trade_history if trade.get('pnl', 0) < 0))
        
        return gross_profit / gross_loss if gross_loss > 0 else float('inf')

class Portfolio:
    """포트폴리오 관리"""
    
    def __init__(self, initial_cash: float):
        self.cash = initial_cash
        self.positions = {}
        self.total_value = initial_cash
    
    def buy(self, symbol: str, quantity: float, price: float, commission: float):
        """매수"""
        cost = price * quantity + commission
        self.cash -= cost
        
        if symbol in self.positions:
            # 평균 매수가 계산
            total_quantity = self.positions[symbol]['quantity'] + quantity
            total_cost = (self.positions[symbol]['avg_price'] * self.positions[symbol]['quantity']) + cost
            self.positions[symbol] = {
                'quantity': total_quantity,
                'avg_price': total_cost / total_quantity
            }
        else:
            self.positions[symbol] = {
                'quantity': quantity,
                'avg_price': price
            }
    
    def sell(self, symbol: str, quantity: float, price: float, commission: float):
        """매도"""
        if symbol not in self.positions or self.positions[symbol]['quantity'] < quantity:
            return False
        
        proceeds = price * quantity - commission
        self.cash += proceeds
        
        self.positions[symbol]['quantity'] -= quantity
        if self.positions[symbol]['quantity'] == 0:
            del self.positions[symbol]
        
        return True
    
    def get_total_value(self, current_prices: Dict[str, float]) -> float:
        """총 자산 가치 계산"""
        portfolio_value = self.cash
        for symbol, position in self.positions.items():
            if symbol in current_prices:
                portfolio_value += position['quantity'] * current_prices[symbol]
        return portfolio_value
```

### 2. 워크포워드 테스팅

```python
class WalkForwardBacktest:
    """워크포워드 백테스팅"""
    
    def __init__(self, train_period: int, test_period: int, step_size: int):
        self.train_period = train_period  # 훈련 기간 (일)
        self.test_period = test_period    # 테스트 기간 (일)
        self.step_size = step_size        # 이동 크기 (일)
        self.results = []
    
    def run_walk_forward(self, strategy_class, data: pd.DataFrame, 
                        strategy_params: Dict[str, Any]) -> List[Dict[str, Any]]:
        """워크포워드 테스팅 실행"""
        start_date = data.index[0]
        end_date = data.index[-1]
        
        current_date = start_date + timedelta(days=self.train_period)
        
        while current_date + timedelta(days=self.test_period) <= end_date:
            # 훈련 기간
            train_start = current_date - timedelta(days=self.train_period)
            train_end = current_date
            train_data = data[(data.index >= train_start) & (data.index < train_end)]
            
            # 테스트 기간
            test_start = current_date
            test_end = current_date + timedelta(days=self.test_period)
            test_data = data[(data.index >= test_start) & (data.index < test_end)]
            
            # 전략 훈련
            strategy = strategy_class(**strategy_params)
            strategy.train(train_data)
            
            # 테스트 실행
            backtest_config = BacktestConfig(
                start_date=test_start,
                end_date=test_end,
                initial_capital=100000
            )
            
            backtest_engine = SophisticatedBacktestEngine(backtest_config)
            test_results = backtest_engine.run_backtest(strategy, test_data)
            
            # 결과 저장
            self.results.append({
                'train_period': (train_start, train_end),
                'test_period': (test_start, test_end),
                'results': test_results,
                'strategy_params': strategy_params
            })
            
            # 다음 기간으로 이동
            current_date += timedelta(days=self.step_size)
        
        return self.results
    
    def analyze_walk_forward_results(self) -> Dict[str, Any]:
        """워크포워드 결과 분석"""
        if not self.results:
            return {}
        
        # 성과 지표 추출
        returns = [result['results']['annual_return'] for result in self.results]
        sharpe_ratios = [result['results']['sharpe_ratio'] for result in self.results]
        max_drawdowns = [result['results']['max_drawdown'] for result in self.results]
        
        # 성과 변화 분석
        performance_trend = self._analyze_performance_trend(returns)
        
        # 안정성 분석
        stability_metrics = self._analyze_stability(returns, sharpe_ratios)
        
        return {
            'avg_return': np.mean(returns),
            'avg_sharpe': np.mean(sharpe_ratios),
            'avg_max_drawdown': np.mean(max_drawdowns),
            'return_std': np.std(returns),
            'sharpe_std': np.std(sharpe_ratios),
            'performance_trend': performance_trend,
            'stability_metrics': stability_metrics,
            'total_periods': len(self.results)
        }
    
    def _analyze_performance_trend(self, returns: List[float]) -> Dict[str, Any]:
        """성과 트렌드 분석"""
        if len(returns) < 2:
            return {'trend': 'insufficient_data'}
        
        # 선형 회귀로 트렌드 분석
        x = np.arange(len(returns))
        slope, intercept = np.polyfit(x, returns, 1)
        
        if slope > 0.001:
            trend = 'improving'
        elif slope < -0.001:
            trend = 'declining'
        else:
            trend = 'stable'
        
        return {
            'trend': trend,
            'slope': slope,
            'r_squared': np.corrcoef(x, returns)[0, 1] ** 2
        }
    
    def _analyze_stability(self, returns: List[float], 
                          sharpe_ratios: List[float]) -> Dict[str, Any]:
        """안정성 분석"""
        return {
            'return_consistency': 1 - (np.std(returns) / np.mean(returns)) if np.mean(returns) != 0 else 0,
            'sharpe_consistency': 1 - (np.std(sharpe_ratios) / np.mean(sharpe_ratios)) if np.mean(sharpe_ratios) != 0 else 0,
            'positive_periods': sum(1 for r in returns if r > 0) / len(returns)
        }
```

### 3. 몬테카를로 시뮬레이션

```python
class MonteCarloSimulation:
    """몬테카를로 시뮬레이션"""
    
    def __init__(self, n_simulations: int = 10000):
        self.n_simulations = n_simulations
        self.simulation_results = []
    
    def run_monte_carlo(self, strategy_results: Dict[str, Any], 
                       time_horizon: int = 252) -> Dict[str, Any]:
        """몬테카를로 시뮬레이션 실행"""
        # 실제 수익률 분포에서 샘플링
        daily_returns = strategy_results['equity_curve']['equity'].pct_change().dropna()
        
        # 몬테카를로 시뮬레이션
        for i in range(self.n_simulations):
            # 랜덤 샘플링
            simulated_returns = np.random.choice(
                daily_returns, 
                size=time_horizon, 
                replace=True
            )
            
            # 누적 수익률 계산
            cumulative_return = np.prod(1 + simulated_returns) - 1
            
            # 최대 낙폭 계산
            cumulative_curve = np.cumprod(1 + simulated_returns)
            running_max = np.maximum.accumulate(cumulative_curve)
            drawdown = (cumulative_curve - running_max) / running_max
            max_drawdown = np.min(drawdown)
            
            self.simulation_results.append({
                'simulation_id': i,
                'cumulative_return': cumulative_return,
                'max_drawdown': max_drawdown,
                'final_value': 1 + cumulative_return
            })
        
        return self._analyze_simulation_results()
    
    def _analyze_simulation_results(self) -> Dict[str, Any]:
        """시뮬레이션 결과 분석"""
        returns = [result['cumulative_return'] for result in self.simulation_results]
        max_drawdowns = [result['max_drawdown'] for result in self.simulation_results]
        final_values = [result['final_value'] for result in self.simulation_results]
        
        # 분위수 계산
        percentiles = [5, 25, 50, 75, 95]
        return_percentiles = np.percentile(returns, percentiles)
        drawdown_percentiles = np.percentile(max_drawdowns, percentiles)
        
        # 위험 지표
        var_95 = np.percentile(returns, 5)  # 95% VaR
        cvar_95 = np.mean([r for r in returns if r <= var_95])  # 95% CVaR
        
        # 성공 확률
        success_probability = sum(1 for r in returns if r > 0) / len(returns)
        
        return {
            'mean_return': np.mean(returns),
            'std_return': np.std(returns),
            'mean_drawdown': np.mean(max_drawdowns),
            'var_95': var_95,
            'cvar_95': cvar_95,
            'success_probability': success_probability,
            'return_percentiles': dict(zip(percentiles, return_percentiles)),
            'drawdown_percentiles': dict(zip(percentiles, drawdown_percentiles)),
            'best_case': max(returns),
            'worst_case': min(returns),
            'n_simulations': self.n_simulations
        }
    
    def generate_scenario_analysis(self, strategy_results: Dict[str, Any]) -> Dict[str, Any]:
        """시나리오 분석"""
        scenarios = {
            'bull_market': self._simulate_bull_market(strategy_results),
            'bear_market': self._simulate_bear_market(strategy_results),
            'high_volatility': self._simulate_high_volatility(strategy_results),
            'low_volatility': self._simulate_low_volatility(strategy_results)
        }
        
        return scenarios
    
    def _simulate_bull_market(self, strategy_results: Dict[str, Any]) -> Dict[str, Any]:
        """상승장 시나리오"""
        daily_returns = strategy_results['equity_curve']['equity'].pct_change().dropna()
        
        # 상승장 조건: 평균 수익률 증가, 변동성 감소
        bull_returns = daily_returns * 1.5 + 0.001  # 수익률 50% 증가, 일일 0.1% 추가 수익
        
        return self._run_scenario_simulation(bull_returns)
    
    def _simulate_bear_market(self, strategy_results: Dict[str, Any]) -> Dict[str, Any]:
        """하락장 시나리오"""
        daily_returns = strategy_results['equity_curve']['equity'].pct_change().dropna()
        
        # 하락장 조건: 평균 수익률 감소, 변동성 증가
        bear_returns = daily_returns * 0.5 - 0.002  # 수익률 50% 감소, 일일 0.2% 추가 손실
        
        return self._run_scenario_simulation(bear_returns)
    
    def _simulate_high_volatility(self, strategy_results: Dict[str, Any]) -> Dict[str, Any]:
        """고변동성 시나리오"""
        daily_returns = strategy_results['equity_curve']['equity'].pct_change().dropna()
        
        # 고변동성 조건: 변동성 2배 증가
        high_vol_returns = daily_returns * 2
        
        return self._run_scenario_simulation(high_vol_returns)
    
    def _simulate_low_volatility(self, strategy_results: Dict[str, Any]) -> Dict[str, Any]:
        """저변동성 시나리오"""
        daily_returns = strategy_results['equity_curve']['equity'].pct_change().dropna()
        
        # 저변동성 조건: 변동성 50% 감소
        low_vol_returns = daily_returns * 0.5
        
        return self._run_scenario_simulation(low_vol_returns)
    
    def _run_scenario_simulation(self, scenario_returns: pd.Series) -> Dict[str, Any]:
        """시나리오별 시뮬레이션 실행"""
        scenario_results = []
        
        for i in range(self.n_simulations):
            simulated_returns = np.random.choice(
                scenario_returns, 
                size=252, 
                replace=True
            )
            
            cumulative_return = np.prod(1 + simulated_returns) - 1
            scenario_results.append(cumulative_return)
        
        return {
            'mean_return': np.mean(scenario_results),
            'std_return': np.std(scenario_results),
            'var_95': np.percentile(scenario_results, 5),
            'success_probability': sum(1 for r in scenario_results if r > 0) / len(scenario_results)
        }
```

### 4. 리스크 시나리오 테스트

```python
class RiskScenarioTest:
    """리스크 시나리오 테스트"""
    
    def __init__(self):
        self.scenarios = {
            'market_crash': self._market_crash_scenario,
            'flash_crash': self._flash_crash_scenario,
            'liquidity_crisis': self._liquidity_crisis_scenario,
            'volatility_spike': self._volatility_spike_scenario,
            'correlation_breakdown': self._correlation_breakdown_scenario
        }
    
    def run_risk_scenarios(self, strategy_results: Dict[str, Any], 
                          portfolio: Dict[str, float]) -> Dict[str, Any]:
        """리스크 시나리오 테스트 실행"""
        scenario_results = {}
        
        for scenario_name, scenario_func in self.scenarios.items():
            logger.info(f"리스크 시나리오 실행: {scenario_name}")
            
            # 시나리오별 시장 데이터 생성
            scenario_data = scenario_func(strategy_results)
            
            # 시나리오 하에서 전략 성능 테스트
            scenario_performance = self._test_scenario_performance(
                strategy_results, scenario_data, portfolio
            )
            
            scenario_results[scenario_name] = scenario_performance
        
        return scenario_results
    
    def _market_crash_scenario(self, strategy_results: Dict[str, Any]) -> Dict[str, Any]:
        """시장 폭락 시나리오"""
        return {
            'market_shock': -0.20,  # 20% 하락
            'volatility_multiplier': 3.0,  # 변동성 3배
            'correlation_increase': 0.8,  # 상관관계 증가
            'liquidity_reduction': 0.5,  # 유동성 50% 감소
            'duration': 30  # 30일 지속
        }
    
    def _flash_crash_scenario(self, strategy_results: Dict[str, Any]) -> Dict[str, Any]:
        """플래시 크래시 시나리오"""
        return {
            'market_shock': -0.10,  # 10% 급락
            'volatility_multiplier': 5.0,  # 변동성 5배
            'correlation_increase': 0.9,  # 상관관계 급증
            'liquidity_reduction': 0.8,  # 유동성 80% 감소
            'duration': 1  # 1일 지속
        }
    
    def _liquidity_crisis_scenario(self, strategy_results: Dict[str, Any]) -> Dict[str, Any]:
        """유동성 위기 시나리오"""
        return {
            'market_shock': -0.05,  # 5% 하락
            'volatility_multiplier': 2.0,  # 변동성 2배
            'correlation_increase': 0.6,  # 상관관계 증가
            'liquidity_reduction': 0.9,  # 유동성 90% 감소
            'duration': 60  # 60일 지속
        }
    
    def _volatility_spike_scenario(self, strategy_results: Dict[str, Any]) -> Dict[str, Any]:
        """변동성 급증 시나리오"""
        return {
            'market_shock': 0.0,  # 가격 변화 없음
            'volatility_multiplier': 4.0,  # 변동성 4배
            'correlation_increase': 0.7,  # 상관관계 증가
            'liquidity_reduction': 0.3,  # 유동성 30% 감소
            'duration': 15  # 15일 지속
        }
    
    def _correlation_breakdown_scenario(self, strategy_results: Dict[str, Any]) -> Dict[str, Any]:
        """상관관계 붕괴 시나리오"""
        return {
            'market_shock': -0.03,  # 3% 하락
            'volatility_multiplier': 1.5,  # 변동성 1.5배
            'correlation_increase': -0.5,  # 상관관계 역전
            'liquidity_reduction': 0.2,  # 유동성 20% 감소
            'duration': 45  # 45일 지속
        }
    
    def _test_scenario_performance(self, strategy_results: Dict[str, Any], 
                                 scenario_data: Dict[str, Any], 
                                 portfolio: Dict[str, float]) -> Dict[str, Any]:
        """시나리오 하에서 성능 테스트"""
        # 시나리오 적용된 수익률 계산
        original_returns = strategy_results['equity_curve']['equity'].pct_change().dropna()
        
        # 시나리오 효과 적용
        scenario_returns = self._apply_scenario_effects(original_returns, scenario_data)
        
        # 포트폴리오 가치 변화 계산
        portfolio_value_changes = self._calculate_portfolio_changes(
            scenario_returns, portfolio
        )
        
        # 리스크 지표 계산
        risk_metrics = self._calculate_risk_metrics(portfolio_value_changes)
        
        return {
            'scenario_data': scenario_data,
            'portfolio_changes': portfolio_value_changes,
            'risk_metrics': risk_metrics,
            'worst_case_loss': min(portfolio_value_changes),
            'recovery_time': self._estimate_recovery_time(portfolio_value_changes)
        }
    
    def _apply_scenario_effects(self, returns: pd.Series, 
                              scenario_data: Dict[str, Any]) -> pd.Series:
        """시나리오 효과 적용"""
        # 기본 시장 충격
        scenario_returns = returns + scenario_data['market_shock'] / 252
        
        # 변동성 증가
        volatility_multiplier = scenario_data['volatility_multiplier']
        scenario_returns = scenario_returns * volatility_multiplier
        
        # 상관관계 변화 (포트폴리오 다각화 효과 감소)
        correlation_effect = scenario_data['correlation_increase']
        if correlation_effect > 0:
            # 상관관계 증가로 인한 추가 리스크
            scenario_returns = scenario_returns * (1 + correlation_effect * 0.1)
        
        return scenario_returns
    
    def _calculate_portfolio_changes(self, returns: pd.Series, 
                                   portfolio: Dict[str, float]) -> List[float]:
        """포트폴리오 가치 변화 계산"""
        cumulative_returns = (1 + returns).cumprod()
        portfolio_changes = []
        
        for i, cumulative_return in enumerate(cumulative_returns):
            # 포트폴리오 가치 변화
            portfolio_value = sum(
                weight * cumulative_return 
                for weight in portfolio.values()
            )
            portfolio_changes.append(portfolio_value - 1)
        
        return portfolio_changes
    
    def _calculate_risk_metrics(self, portfolio_changes: List[float]) -> Dict[str, float]:
        """리스크 지표 계산"""
        changes_array = np.array(portfolio_changes)
        
        return {
            'max_loss': np.min(changes_array),
            'var_95': np.percentile(changes_array, 5),
            'cvar_95': np.mean(changes_array[changes_array <= np.percentile(changes_array, 5)]),
            'volatility': np.std(changes_array),
            'skewness': self._calculate_skewness(changes_array),
            'kurtosis': self._calculate_kurtosis(changes_array)
        }
    
    def _calculate_skewness(self, data: np.ndarray) -> float:
        """왜도 계산"""
        mean = np.mean(data)
        std = np.std(data)
        if std == 0:
            return 0
        return np.mean(((data - mean) / std) ** 3)
    
    def _calculate_kurtosis(self, data: np.ndarray) -> float:
        """첨도 계산"""
        mean = np.mean(data)
        std = np.std(data)
        if std == 0:
            return 0
        return np.mean(((data - mean) / std) ** 4) - 3
    
    def _estimate_recovery_time(self, portfolio_changes: List[float]) -> int:
        """회복 시간 추정"""
        if not portfolio_changes:
            return 0
        
        # 최대 손실 지점 찾기
        max_loss_idx = np.argmin(portfolio_changes)
        max_loss = portfolio_changes[max_loss_idx]
        
        # 회복 지점 찾기 (최대 손실의 50% 회복)
        recovery_threshold = max_loss * 0.5
        
        for i in range(max_loss_idx + 1, len(portfolio_changes)):
            if portfolio_changes[i] >= recovery_threshold:
                return i - max_loss_idx
        
        return len(portfolio_changes) - max_loss_idx  # 회복하지 못한 경우
```

## 📈 성과 지표

### 백테스팅 성과
- **총 수익률**: 연간 15-25%
- **샤프 비율**: > 1.5
- **최대 낙폭**: < 15%
- **승률**: > 55%
- **수익 팩터**: > 1.5

### 워크포워드 성과
- **성과 안정성**: 연간 수익률 표준편차 < 10%
- **트렌드 지속성**: 성과 개선/안정적 트렌드
- **적응성**: 다양한 시장 환경에서 일관된 성과

### 몬테카를로 시뮬레이션
- **성공 확률**: > 60%
- **95% VaR**: > -20%
- **극단적 손실**: < -30%

### 리스크 시나리오
- **시장 폭락 대응**: 손실 < 25%
- **유동성 위기 대응**: 손실 < 15%
- **회복 시간**: < 90일

## 🔄 개발 로드맵

### 1단계: 기본 백테스팅 엔진 (2025-03-01 ~ 2025-03-15)
- [x] 기본 백테스팅 엔진 구현
- [x] 포트폴리오 관리 시스템
- [x] 성과 지표 계산
- [ ] 슬리피지 모델 구현
- [ ] 수수료 모델 구현

### 2단계: 워크포워드 테스팅 (2025-03-16 ~ 2025-03-31)
- [ ] 워크포워드 백테스팅 구현
- [ ] 성과 트렌드 분석
- [ ] 안정성 지표 계산
- [ ] 시각화 대시보드

### 3단계: 몬테카를로 시뮬레이션 (2025-04-01 ~ 2025-04-15)
- [ ] 몬테카를로 시뮬레이션 구현
- [ ] 시나리오 분석
- [ ] 위험 지표 계산
- [ ] 확률적 예측 모델

### 4단계: 리스크 시나리오 테스트 (2025-04-16 ~ 2025-04-30)
- [ ] 리스크 시나리오 정의
- [ ] 극단적 상황 시뮬레이션
- [ ] 회복 시간 분석
- [ ] 스트레스 테스트

### 5단계: 통합 및 최적화 (2025-05-01 ~ 2025-05-15)
- [ ] 모든 모듈 통합
- [ ] 성능 최적화
- [ ] 사용자 인터페이스
- [ ] 문서화 완료

## 🔗 관련 문서
- [기술적 지표 분석](3.5.1_TECHNICAL_ANALYSIS.md)
- [거래 전략 라이브러리](3.5.2_TRADING_STRATEGIES.md)
- [고급 위험 관리](3.5.7_ADVANCED_RISK_MANAGEMENT.md)
- [포트폴리오 최적화](3.5.10_PORTFOLIO_OPTIMIZATION.md) 