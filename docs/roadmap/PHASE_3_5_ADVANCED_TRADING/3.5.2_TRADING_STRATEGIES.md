# ğŸ¯ Phase 3.5.2: ê±°ë˜ ì „ëµ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì‹œìŠ¤í…œ (ê¸°ë³¸ + ê³ ê¸‰ í†µí•©)

## ğŸ“‹ **ê°œìš”**

### ğŸ¯ **ëª©í‘œ**
- **ê¸°ë³¸ ì „ëµ**: Scalping, Day Trading, Swing Trading, Arbitrage, Market Making, Grid Trading
- **ê³ ê¸‰ ì „ëµ**: ì–‘ì ì»´í“¨íŒ…, ê°ì • ê¸°ë°˜, ë§ˆì´í¬ë¡œ êµ¬ì¡°, ë¨¸ì‹ ëŸ¬ë‹ ì•™ìƒë¸”, ë¸”ë¡ì²´ì¸ ê¸°ë°˜
- **ë‹¤ì´ë‚˜ë¯¹ í¬íŠ¸í´ë¦¬ì˜¤ ë¦¬ë°¸ëŸ°ì‹±**: ì‹¤ì‹œê°„ í¬íŠ¸í´ë¦¬ì˜¤ ìµœì í™” ë° ìë™ ë¦¬ë°¸ëŸ°ì‹±
- **HFT ì‹¤í–‰ ìµœì í™”**: ê³ ë¹ˆë„ ê±°ë˜ë¥¼ ìœ„í•œ ì‹¤í–‰ ì „ëµ ìµœì í™”
- **ê³ ê¸‰ ë°±í…ŒìŠ¤íŒ…**: ì›Œí¬í¬ì›Œë“œ í…ŒìŠ¤íŠ¸, ëª¬í…Œì¹´ë¥¼ë¡œ ì‹œë®¬ë ˆì´ì…˜ í†µí•©
- **ê³ ê¸‰ ë¦¬ìŠ¤í¬ ê´€ë¦¬**: í¬ì§€ì…˜ í¬ê¸° ì¡°ì •, ìë³¸ í•œë„, ë³€ë™ì„± ê¸°ë°˜ ì „ëµ
- **ì „ëµ íŒ¨í„´ ë¼ì´ë¸ŒëŸ¬ë¦¬**: 50+ ê±°ë˜ ì „ëµ íŒ¨í„´ ë° í…œí”Œë¦¿
- **ì „ëµ í…œí”Œë¦¿ ì‹œìŠ¤í…œ**: ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ì „ëµ í…œí”Œë¦¿ ì œê³µ
- **ë°±í…ŒìŠ¤íŠ¸ ê²°ê³¼ ê´€ë¦¬**: ì „ëµë³„ ì„±ê³¼ ë¶„ì„ ë° ë¹„êµ
- **ì „ëµ ìµœì í™” ì—”ì§„**: íŒŒë¼ë¯¸í„° ìë™ íŠœë‹ ë° ìµœì í™”
- **AI ì „ëµ í•™ìŠµ**: AIê°€ ë‹¤ì–‘í•œ ì „ëµì„ í•™ìŠµí•˜ê³  ì¡°í•©

### ğŸ“Š **ì„±ëŠ¥ ëª©í‘œ**
- **ì „ëµ ì‹¤í–‰ ì†ë„**: < 50ms ì „ëµ ì‹ í˜¸ ìƒì„±
- **ë°±í…ŒìŠ¤íŠ¸ ì†ë„**: < 1ë¶„ 1ë…„ ë°ì´í„° ë°±í…ŒìŠ¤íŠ¸
- **ì „ëµ ìµœì í™”**: < 10ë¶„ íŒŒë¼ë¯¸í„° ìµœì í™”
- **ì–‘ì ì „ëµ ì„±ê³µë¥ **: > 70% ì–‘ì ì•Œê³ ë¦¬ì¦˜ ì„±ê³µë¥ 
- **ê°ì • ì „ëµ ì •í™•ë„**: > 65% ê°ì • ê¸°ë°˜ ì „ëµ ì •í™•ë„
- **ë§ˆì´í¬ë¡œ êµ¬ì¡° ì „ëµ**: > 80% ë§ˆì´í¬ë¡œ êµ¬ì¡° ì „ëµ ì •í™•ë„
- **ì•™ìƒë¸” ì „ëµ ì„±ê³µë¥ **: > 75% ì•™ìƒë¸” ì „ëµ ì„±ê³µë¥ 
- **ì‹¤ì‹œê°„ ì²˜ë¦¬**: < 100ms ê³ ê¸‰ ì „ëµ ì‹¤í–‰
- **ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰**: < 1GB per strategy
- **ì „ëµ ì„±ê³µë¥ **: > 60% (ë°±í…ŒìŠ¤íŠ¸ ê¸°ì¤€)

## ğŸ—ï¸ **ê±°ë˜ ì „ëµ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì•„í‚¤í…ì²˜**

### ğŸ“ **ì‹œìŠ¤í…œ êµ¬ì¡°**
```
trading-strategies/
â”œâ”€â”€ strategy-patterns/                   # ì „ëµ íŒ¨í„´
â”‚   â”œâ”€â”€ scalping-strategies/            # ìŠ¤ìº˜í•‘ ì „ëµ
â”‚   â”œâ”€â”€ day-trading-strategies/         # ë°ì´íŠ¸ë ˆì´ë”© ì „ëµ
â”‚   â”œâ”€â”€ swing-trading-strategies/       # ìŠ¤ìœ™íŠ¸ë ˆì´ë”© ì „ëµ
â”‚   â”œâ”€â”€ arbitrage-strategies/           # ì•„ë¹„íŠ¸ë¼ì§€ ì „ëµ
â”‚   â”œâ”€â”€ market-making-strategies/       # ë§ˆì¼“ë©”ì´í‚¹ ì „ëµ
â”‚   â””â”€â”€ grid-trading-strategies/        # ê·¸ë¦¬ë“œ íŠ¸ë ˆì´ë”©
â”œâ”€â”€ dynamic-portfolio-rebalancing/       # ë‹¤ì´ë‚˜ë¯¹ í¬íŠ¸í´ë¦¬ì˜¤ ë¦¬ë°¸ëŸ°ì‹±
â”‚   â”œâ”€â”€ portfolio-optimizer/            # í¬íŠ¸í´ë¦¬ì˜¤ ìµœì í™”
â”‚   â”œâ”€â”€ rebalancing-engine/             # ë¦¬ë°¸ëŸ°ì‹± ì—”ì§„
â”‚   â”œâ”€â”€ risk-budgeting/                 # ë¦¬ìŠ¤í¬ ì˜ˆì‚° ê´€ë¦¬
â”‚   â””â”€â”€ allocation-manager/             # ìì‚° ë°°ë¶„ ê´€ë¦¬
â”œâ”€â”€ hft-execution-optimization/          # HFT ì‹¤í–‰ ìµœì í™”
â”‚   â”œâ”€â”€ execution-strategies/           # ì‹¤í–‰ ì „ëµ
â”‚   â”œâ”€â”€ order-splitting/                # ì£¼ë¬¸ ë¶„í• 
â”‚   â”œâ”€â”€ market-impact-analysis/         # ì‹œì¥ ì˜í–¥ ë¶„ì„
â”‚   â””â”€â”€ latency-optimization/           # ì§€ì—° ìµœì í™”
â”œâ”€â”€ advanced-backtesting/                # ê³ ê¸‰ ë°±í…ŒìŠ¤íŒ…
â”‚   â”œâ”€â”€ walk-forward-testing/           # ì›Œí¬í¬ì›Œë“œ í…ŒìŠ¤íŠ¸
â”‚   â”œâ”€â”€ monte-carlo-simulation/         # ëª¬í…Œì¹´ë¥¼ë¡œ ì‹œë®¬ë ˆì´ì…˜
â”‚   â”œâ”€â”€ stress-testing/                 # ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸
â”‚   â””â”€â”€ scenario-analysis/              # ì‹œë‚˜ë¦¬ì˜¤ ë¶„ì„
â”œâ”€â”€ advanced-risk-management/            # ê³ ê¸‰ ë¦¬ìŠ¤í¬ ê´€ë¦¬
â”‚   â”œâ”€â”€ position-sizing/                # í¬ì§€ì…˜ í¬ê¸° ì¡°ì •
â”‚   â”œâ”€â”€ capital-limits/                 # ìë³¸ í•œë„ ê´€ë¦¬
â”‚   â”œâ”€â”€ volatility-based-strategies/    # ë³€ë™ì„± ê¸°ë°˜ ì „ëµ
â”‚   â””â”€â”€ risk-scoring/                   # ë¦¬ìŠ¤í¬ ì ìˆ˜ ê³„ì‚°
â”œâ”€â”€ strategy-templates/                  # ì „ëµ í…œí”Œë¦¿
â”‚   â”œâ”€â”€ template-engine/                # í…œí”Œë¦¿ ì—”ì§„
â”‚   â”œâ”€â”€ parameter-templates/            # íŒŒë¼ë¯¸í„° í…œí”Œë¦¿
â”‚   â”œâ”€â”€ condition-templates/            # ì¡°ê±´ í…œí”Œë¦¿
â”‚   â””â”€â”€ action-templates/               # ì•¡ì…˜ í…œí”Œë¦¿
â”œâ”€â”€ backtest-engine/                     # ë°±í…ŒìŠ¤íŠ¸ ì—”ì§„
â”‚   â”œâ”€â”€ historical-data-manager/        # íˆìŠ¤í† ë¦¬ ë°ì´í„° ê´€ë¦¬
â”‚   â”œâ”€â”€ strategy-executor/              # ì „ëµ ì‹¤í–‰ê¸°
â”‚   â”œâ”€â”€ performance-calculator/         # ì„±ê³¼ ê³„ì‚°ê¸°
â”‚   â””â”€â”€ result-analyzer/                # ê²°ê³¼ ë¶„ì„ê¸°
â”œâ”€â”€ strategy-optimization/               # ì „ëµ ìµœì í™”
â”‚   â”œâ”€â”€ parameter-optimizer/            # íŒŒë¼ë¯¸í„° ìµœì í™”
â”‚   â”œâ”€â”€ genetic-algorithm/              # ìœ ì „ ì•Œê³ ë¦¬ì¦˜
â”‚   â”œâ”€â”€ bayesian-optimization/          # ë² ì´ì§€ì•ˆ ìµœì í™”
â”‚   â””â”€â”€ hyperparameter-tuning/          # í•˜ì´í¼íŒŒë¼ë¯¸í„° íŠœë‹
â”œâ”€â”€ ai-strategy-learning/                # AI ì „ëµ í•™ìŠµ
â”‚   â”œâ”€â”€ strategy-classifier/            # ì „ëµ ë¶„ë¥˜ê¸°
â”‚   â”œâ”€â”€ strategy-combiner/              # ì „ëµ ê²°í•©ê¸°
â”‚   â”œâ”€â”€ meta-learning/                  # ë©”íƒ€ëŸ¬ë‹
â”‚   â””â”€â”€ adaptive-strategies/            # ì ì‘í˜• ì „ëµ
â”œâ”€â”€ strategy-management/                 # ì „ëµ ê´€ë¦¬
    â”œâ”€â”€ strategy-registry/              # ì „ëµ ë ˆì§€ìŠ¤íŠ¸ë¦¬
    â”œâ”€â”€ version-control/                # ë²„ì „ ê´€ë¦¬
    â”œâ”€â”€ deployment-manager/             # ë°°í¬ ê´€ë¦¬
    â””â”€â”€ monitoring-dashboard/           # ëª¨ë‹ˆí„°ë§ ëŒ€ì‹œë³´ë“œ
â”œâ”€â”€ advanced-strategies/                 # ê³ ê¸‰ ì „ëµ
    â”œâ”€â”€ quantum-strategies/             # ì–‘ì ì»´í“¨íŒ… ì „ëµ
    â”œâ”€â”€ sentiment-strategies/           # ê°ì • ê¸°ë°˜ ì „ëµ
    â”œâ”€â”€ microstructure-strategies/      # ë§ˆì´í¬ë¡œ êµ¬ì¡° ì „ëµ
    â”œâ”€â”€ ensemble-strategies/            # ë¨¸ì‹ ëŸ¬ë‹ ì•™ìƒë¸”
    â””â”€â”€ blockchain-strategies/          # ë¸”ë¡ì²´ì¸ ê¸°ë°˜ ì „ëµ
```

## ğŸ”§ **ê±°ë˜ ì „ëµ íŒ¨í„´ ì‹œìŠ¤í…œ**

### ğŸ“¦ **ê¸°ë³¸ ì „ëµ íŒ¨í„´**

```python
# trading-strategies/strategy-patterns/base_strategy.py
import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional, Union, Callable
from dataclasses import dataclass
from datetime import datetime, timedelta
import logging
from abc import ABC, abstractmethod
from enum import Enum

logger = logging.getLogger(__name__)

class SignalType(Enum):
    """ì‹ í˜¸ íƒ€ì…"""
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"
    CLOSE = "CLOSE"

class StrategyType(Enum):
    """ì „ëµ íƒ€ì…"""
    SCALPING = "scalping"
    DAY_TRADING = "day_trading"
    SWING_TRADING = "swing_trading"
    ARBITRAGE = "arbitrage"
    MARKET_MAKING = "market_making"
    GRID_TRADING = "grid_trading"

@dataclass
class StrategySignal:
    """ì „ëµ ì‹ í˜¸"""
    signal_type: SignalType
    symbol: str
    quantity: float
    price: Optional[float] = None
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    confidence: float = 0.0
    strategy_name: str = ""
    timestamp: datetime = None
    metadata: Dict[str, any] = None

@dataclass
class StrategyPerformance:
    """ì „ëµ ì„±ê³¼"""
    strategy_name: str
    total_trades: int
    winning_trades: int
    losing_trades: int
    win_rate: float
    total_return: float
    sharpe_ratio: float
    max_drawdown: float
    profit_factor: float
    avg_trade_duration: timedelta
    start_date: datetime
    end_date: datetime

class BaseStrategy(ABC):
    """ê¸°ë³¸ ì „ëµ í´ë˜ìŠ¤"""
    
    def __init__(self, name: str, strategy_type: StrategyType, parameters: Dict = None):
        self.name = name
        self.strategy_type = strategy_type
        self.parameters = parameters or {}
        self.positions = {}
        self.trade_history = []
        self.performance_metrics = {}
        self.is_active = False
    
    @abstractmethod
    def generate_signal(self, market_data: Dict) -> Optional[StrategySignal]:
        """ì‹ í˜¸ ìƒì„± (ì¶”ìƒ ë©”ì„œë“œ)"""
        pass
    
    @abstractmethod
    def should_exit(self, position: Dict, market_data: Dict) -> bool:
        """í¬ì§€ì…˜ ì¢…ë£Œ ì—¬ë¶€ í™•ì¸ (ì¶”ìƒ ë©”ì„œë“œ)"""
        pass
    
    def update_parameters(self, new_parameters: Dict):
        """íŒŒë¼ë¯¸í„° ì—…ë°ì´íŠ¸"""
        self.parameters.update(new_parameters)
        logger.info(f"ì „ëµ {self.name} íŒŒë¼ë¯¸í„° ì—…ë°ì´íŠ¸: {new_parameters}")
    
    def get_performance_summary(self) -> StrategyPerformance:
        """ì„±ê³¼ ìš”ì•½ ë°˜í™˜"""
        if not self.trade_history:
            return None
        
        total_trades = len(self.trade_history)
        winning_trades = len([t for t in self.trade_history if t['pnl'] > 0])
        losing_trades = total_trades - winning_trades
        win_rate = winning_trades / total_trades if total_trades > 0 else 0
        
        total_return = sum(t['pnl'] for t in self.trade_history)
        returns = [t['pnl'] for t in self.trade_history]
        
        # ìƒ¤í”„ ë¹„ìœ¨ ê³„ì‚°
        if returns:
            avg_return = np.mean(returns)
            std_return = np.std(returns)
            sharpe_ratio = avg_return / std_return if std_return > 0 else 0
        else:
            sharpe_ratio = 0
        
        # ìµœëŒ€ ë‚™í­ ê³„ì‚°
        cumulative_returns = np.cumsum(returns)
        running_max = np.maximum.accumulate(cumulative_returns)
        drawdowns = cumulative_returns - running_max
        max_drawdown = abs(np.min(drawdowns)) if len(drawdowns) > 0 else 0
        
        # ìˆ˜ìµ íŒ©í„° ê³„ì‚°
        gross_profit = sum(t['pnl'] for t in self.trade_history if t['pnl'] > 0)
        gross_loss = abs(sum(t['pnl'] for t in self.trade_history if t['pnl'] < 0))
        profit_factor = gross_profit / gross_loss if gross_loss > 0 else float('inf')
        
        # í‰ê·  ê±°ë˜ ì‹œê°„
        if self.trade_history:
            durations = [t['exit_time'] - t['entry_time'] for t in self.trade_history]
            avg_duration = sum(durations, timedelta()) / len(durations)
        else:
            avg_duration = timedelta()
        
        return StrategyPerformance(
            strategy_name=self.name,
            total_trades=total_trades,
            winning_trades=winning_trades,
            losing_trades=losing_trades,
            win_rate=win_rate,
            total_return=total_return,
            sharpe_ratio=sharpe_ratio,
            max_drawdown=max_drawdown,
            profit_factor=profit_factor,
            avg_trade_duration=avg_duration,
            start_date=self.trade_history[0]['entry_time'] if self.trade_history else datetime.now(),
            end_date=self.trade_history[-1]['exit_time'] if self.trade_history else datetime.now()
        )
```

### ğŸ“¦ **ìŠ¤ìº˜í•‘ ì „ëµ**

```python
# trading-strategies/strategy-patterns/scalping_strategies.py
from .base_strategy import BaseStrategy, StrategySignal, SignalType, StrategyType
import numpy as np
from typing import Dict, Optional
import logging

logger = logging.getLogger(__name__)

class ScalpingStrategy(BaseStrategy):
    """ìŠ¤ìº˜í•‘ ì „ëµ"""
    
    def __init__(self, name: str, parameters: Dict = None):
        default_params = {
            'min_profit_threshold': 0.001,  # 0.1% ìµœì†Œ ìˆ˜ìµ
            'max_loss_threshold': 0.0005,   # 0.05% ìµœëŒ€ ì†ì‹¤
            'position_size': 0.1,           # í¬ì§€ì…˜ í¬ê¸° (10%)
            'max_hold_time': 300,           # ìµœëŒ€ ë³´ìœ  ì‹œê°„ (5ë¶„)
            'entry_threshold': 0.0002,      # ì§„ì… ì„ê³„ê°’
            'exit_threshold': 0.0001        # ì²­ì‚° ì„ê³„ê°’
        }
        
        if parameters:
            default_params.update(parameters)
        
        super().__init__(name, StrategyType.SCALPING, default_params)
    
    def generate_signal(self, market_data: Dict) -> Optional[StrategySignal]:
        """ìŠ¤ìº˜í•‘ ì‹ í˜¸ ìƒì„±"""
        try:
            # í˜„ì¬ ê°€ê²©
            current_price = market_data.get('close', 0)
            if current_price <= 0:
                return None
            
            # ë‹¨ê¸° ì´ë™í‰ê· 
            short_ma = market_data.get('sma_5', current_price)
            long_ma = market_data.get('sma_20', current_price)
            
            # RSI
            rsi = market_data.get('rsi', 50)
            
            # ë³¼ë¦°ì € ë°´ë“œ
            bb_upper = market_data.get('bb_upper', current_price)
            bb_lower = market_data.get('bb_lower', current_price)
            bb_middle = market_data.get('bb_middle', current_price)
            
            # ìŠ¤ìº˜í•‘ ì‹ í˜¸ ë¡œì§
            signal = self._scalping_logic(
                current_price, short_ma, long_ma, rsi, 
                bb_upper, bb_lower, bb_middle
            )
            
            if signal:
                return StrategySignal(
                    signal_type=signal['type'],
                    symbol=market_data.get('symbol', ''),
                    quantity=self.parameters['position_size'],
                    price=current_price,
                    stop_loss=signal.get('stop_loss'),
                    take_profit=signal.get('take_profit'),
                    confidence=signal.get('confidence', 0.0),
                    strategy_name=self.name,
                    timestamp=datetime.now()
                )
            
            return None
            
        except Exception as e:
            logger.error(f"ìŠ¤ìº˜í•‘ ì‹ í˜¸ ìƒì„± ì˜¤ë¥˜: {e}")
            return None
    
    def _scalping_logic(self, price: float, short_ma: float, long_ma: float,
                       rsi: float, bb_upper: float, bb_lower: float, 
                       bb_middle: float) -> Optional[Dict]:
        """ìŠ¤ìº˜í•‘ ë¡œì§"""
        # ë§¤ìˆ˜ ì‹ í˜¸ ì¡°ê±´
        buy_conditions = [
            price > short_ma,  # ë‹¨ê¸° ì´ë™í‰ê·  ìœ„
            short_ma > long_ma,  # ê³¨ë“ í¬ë¡œìŠ¤
            rsi < 70,  # RSI ê³¼ë§¤ìˆ˜ ì•„ë‹˜
            price < bb_upper,  # ë³¼ë¦°ì € ìƒë‹¨ ì•„ë˜
            price > bb_middle  # ë³¼ë¦°ì € ì¤‘ê°„ì„  ìœ„
        ]
        
        # ë§¤ë„ ì‹ í˜¸ ì¡°ê±´
        sell_conditions = [
            price < short_ma,  # ë‹¨ê¸° ì´ë™í‰ê·  ì•„ë˜
            short_ma < long_ma,  # ë°ë“œí¬ë¡œìŠ¤
            rsi > 30,  # RSI ê³¼ë§¤ë„ ì•„ë‹˜
            price > bb_lower,  # ë³¼ë¦°ì € í•˜ë‹¨ ìœ„
            price < bb_middle  # ë³¼ë¦°ì € ì¤‘ê°„ì„  ì•„ë˜
        ]
        
        # ì‹ í˜¸ ìƒì„±
        if all(buy_conditions):
            stop_loss = price * (1 - self.parameters['max_loss_threshold'])
            take_profit = price * (1 + self.parameters['min_profit_threshold'])
            
            return {
                'type': SignalType.BUY,
                'stop_loss': stop_loss,
                'take_profit': take_profit,
                'confidence': 0.8
            }
        
        elif all(sell_conditions):
            stop_loss = price * (1 + self.parameters['max_loss_threshold'])
            take_profit = price * (1 - self.parameters['min_profit_threshold'])
            
            return {
                'type': SignalType.SELL,
                'stop_loss': stop_loss,
                'take_profit': take_profit,
                'confidence': 0.8
            }
        
        return None
    
    def should_exit(self, position: Dict, market_data: Dict) -> bool:
        """ìŠ¤ìº˜í•‘ í¬ì§€ì…˜ ì¢…ë£Œ í™•ì¸"""
        try:
            current_price = market_data.get('close', 0)
            entry_price = position.get('entry_price', 0)
            entry_time = position.get('entry_time')
            
            if not all([current_price, entry_price, entry_time]):
                return False
            
            # ì‹œê°„ ê¸°ë°˜ ì¢…ë£Œ
            time_held = datetime.now() - entry_time
            if time_held.total_seconds() > self.parameters['max_hold_time']:
                return True
            
            # ìˆ˜ìµ/ì†ì‹¤ ê¸°ë°˜ ì¢…ë£Œ
            if position.get('side') == 'BUY':
                profit_pct = (current_price - entry_price) / entry_price
                if profit_pct >= self.parameters['min_profit_threshold']:
                    return True
                if profit_pct <= -self.parameters['max_loss_threshold']:
                    return True
            
            elif position.get('side') == 'SELL':
                profit_pct = (entry_price - current_price) / entry_price
                if profit_pct >= self.parameters['min_profit_threshold']:
                    return True
                if profit_pct <= -self.parameters['max_loss_threshold']:
                    return True
            
            return False
            
        except Exception as e:
            logger.error(f"ìŠ¤ìº˜í•‘ ì¢…ë£Œ í™•ì¸ ì˜¤ë¥˜: {e}")
            return False
```

### ğŸ“¦ **ë°ì´ íŠ¸ë ˆì´ë”© ì „ëµ**

```python
# trading-strategies/strategy-patterns/day_trading_strategies.py
from .base_strategy import BaseStrategy, StrategySignal, SignalType, StrategyType
import numpy as np
from typing import Dict, Optional
import logging

logger = logging.getLogger(__name__)

class DayTradingStrategy(BaseStrategy):
    """ë°ì´ íŠ¸ë ˆì´ë”© ì „ëµ"""
    
    def __init__(self, name: str, parameters: Dict = None):
        default_params = {
            'min_profit_threshold': 0.005,  # 0.5% ìµœì†Œ ìˆ˜ìµ
            'max_loss_threshold': 0.003,    # 0.3% ìµœëŒ€ ì†ì‹¤
            'position_size': 0.2,           # í¬ì§€ì…˜ í¬ê¸° (20%)
            'max_hold_time': 3600,          # ìµœëŒ€ ë³´ìœ  ì‹œê°„ (1ì‹œê°„)
            'volume_threshold': 1000000,    # ê±°ë˜ëŸ‰ ì„ê³„ê°’
            'volatility_threshold': 0.02,   # ë³€ë™ì„± ì„ê³„ê°’
            'trend_strength_threshold': 0.6 # íŠ¸ë Œë“œ ê°•ë„ ì„ê³„ê°’
        }
        
        if parameters:
            default_params.update(parameters)
        
        super().__init__(name, StrategyType.DAY_TRADING, default_params)
    
    def generate_signal(self, market_data: Dict) -> Optional[StrategySignal]:
        """ë°ì´ íŠ¸ë ˆì´ë”© ì‹ í˜¸ ìƒì„±"""
        try:
            # ê¸°ë³¸ ë°ì´í„° í™•ì¸
            current_price = market_data.get('close', 0)
            volume = market_data.get('volume', 0)
            high = market_data.get('high', current_price)
            low = market_data.get('low', current_price)
            
            if current_price <= 0 or volume <= 0:
                return None
            
            # ê¸°ìˆ ì  ì§€í‘œ
            rsi = market_data.get('rsi', 50)
            macd = market_data.get('macd', 0)
            macd_signal = market_data.get('macd_signal', 0)
            bb_upper = market_data.get('bb_upper', current_price)
            bb_lower = market_data.get('bb_lower', current_price)
            
            # ë³€ë™ì„± ê³„ì‚°
            volatility = (high - low) / current_price
            
            # ê±°ë˜ëŸ‰ í™•ì¸
            if volume < self.parameters['volume_threshold']:
                return None
            
            # ë³€ë™ì„± í™•ì¸
            if volatility < self.parameters['volatility_threshold']:
                return None
            
            # ë°ì´ íŠ¸ë ˆì´ë”© ì‹ í˜¸ ë¡œì§
            signal = self._day_trading_logic(
                current_price, rsi, macd, macd_signal, 
                bb_upper, bb_lower, volatility, volume
            )
            
            if signal:
                return StrategySignal(
                    signal_type=signal['type'],
                    symbol=market_data.get('symbol', ''),
                    quantity=self.parameters['position_size'],
                    price=current_price,
                    stop_loss=signal.get('stop_loss'),
                    take_profit=signal.get('take_profit'),
                    confidence=signal.get('confidence', 0.0),
                    strategy_name=self.name,
                    timestamp=datetime.now()
                )
            
            return None
            
        except Exception as e:
            logger.error(f"ë°ì´ íŠ¸ë ˆì´ë”© ì‹ í˜¸ ìƒì„± ì˜¤ë¥˜: {e}")
            return None
    
    def _day_trading_logic(self, price: float, rsi: float, macd: float, 
                          macd_signal: float, bb_upper: float, bb_lower: float,
                          volatility: float, volume: float) -> Optional[Dict]:
        """ë°ì´ íŠ¸ë ˆì´ë”© ë¡œì§"""
        # ë§¤ìˆ˜ ì‹ í˜¸ ì¡°ê±´
        buy_conditions = [
            macd > macd_signal,  # MACD ê³¨ë“ í¬ë¡œìŠ¤
            rsi > 30 and rsi < 70,  # RSI ì¤‘ë¦½ êµ¬ê°„
            price > bb_lower,  # ë³¼ë¦°ì € í•˜ë‹¨ ìœ„
            volatility >= self.parameters['volatility_threshold'],
            volume >= self.parameters['volume_threshold']
        ]
        
        # ë§¤ë„ ì‹ í˜¸ ì¡°ê±´
        sell_conditions = [
            macd < macd_signal,  # MACD ë°ë“œí¬ë¡œìŠ¤
            rsi > 30 and rsi < 70,  # RSI ì¤‘ë¦½ êµ¬ê°„
            price < bb_upper,  # ë³¼ë¦°ì € ìƒë‹¨ ì•„ë˜
            volatility >= self.parameters['volatility_threshold'],
            volume >= self.parameters['volume_threshold']
        ]
        
        # ì‹ í˜¸ ìƒì„±
        if all(buy_conditions):
            stop_loss = price * (1 - self.parameters['max_loss_threshold'])
            take_profit = price * (1 + self.parameters['min_profit_threshold'])
            
            return {
                'type': SignalType.BUY,
                'stop_loss': stop_loss,
                'take_profit': take_profit,
                'confidence': 0.75
            }
        
        elif all(sell_conditions):
            stop_loss = price * (1 + self.parameters['max_loss_threshold'])
            take_profit = price * (1 - self.parameters['min_profit_threshold'])
            
            return {
                'type': SignalType.SELL,
                'stop_loss': stop_loss,
                'take_profit': take_profit,
                'confidence': 0.75
            }
        
        return None
    
    def should_exit(self, position: Dict, market_data: Dict) -> bool:
        """ë°ì´ íŠ¸ë ˆì´ë”© í¬ì§€ì…˜ ì¢…ë£Œ í™•ì¸"""
        try:
            current_price = market_data.get('close', 0)
            entry_price = position.get('entry_price', 0)
            entry_time = position.get('entry_time')
            
            if not all([current_price, entry_price, entry_time]):
                return False
            
            # ì‹œê°„ ê¸°ë°˜ ì¢…ë£Œ (ì¥ ë§ˆê°)
            current_hour = datetime.now().hour
            if current_hour >= 15:  # ì˜¤í›„ 3ì‹œ ì´í›„ ì¢…ë£Œ
                return True
            
            # ì‹œê°„ ê¸°ë°˜ ì¢…ë£Œ (ìµœëŒ€ ë³´ìœ  ì‹œê°„)
            time_held = datetime.now() - entry_time
            if time_held.total_seconds() > self.parameters['max_hold_time']:
                return True
            
            # ìˆ˜ìµ/ì†ì‹¤ ê¸°ë°˜ ì¢…ë£Œ
            if position.get('side') == 'BUY':
                profit_pct = (current_price - entry_price) / entry_price
                if profit_pct >= self.parameters['min_profit_threshold']:
                    return True
                if profit_pct <= -self.parameters['max_loss_threshold']:
                    return True
            
            elif position.get('side') == 'SELL':
                profit_pct = (entry_price - current_price) / entry_price
                if profit_pct >= self.parameters['min_profit_threshold']:
                    return True
                if profit_pct <= -self.parameters['max_loss_threshold']:
                    return True
            
            return False
            
        except Exception as e:
            logger.error(f"ë°ì´ íŠ¸ë ˆì´ë”© ì¢…ë£Œ í™•ì¸ ì˜¤ë¥˜: {e}")
            return False
```

## ğŸ”§ **ì „ëµ í…œí”Œë¦¿ ì‹œìŠ¤í…œ**

### ğŸ“¦ **ì „ëµ í…œí”Œë¦¿ ì—”ì§„**

```python
# trading-strategies/strategy-templates/template_engine.py
import json
import yaml
from typing import Dict, List, Any, Optional
from dataclasses import dataclass
import logging

logger = logging.getLogger(__name__)

@dataclass
class StrategyTemplate:
    """ì „ëµ í…œí”Œë¦¿"""
    name: str
    description: str
    strategy_type: str
    parameters: Dict[str, Any]
    conditions: List[Dict[str, Any]]
    actions: List[Dict[str, Any]]
    risk_management: Dict[str, Any]
    version: str = "1.0"

class StrategyTemplateEngine:
    """ì „ëµ í…œí”Œë¦¿ ì—”ì§„"""
    
    def __init__(self):
        self.templates = {}
        self.template_registry = {}
    
    def register_template(self, template: StrategyTemplate):
        """í…œí”Œë¦¿ ë“±ë¡"""
        self.templates[template.name] = template
        self.template_registry[template.name] = {
            'type': template.strategy_type,
            'version': template.version,
            'description': template.description
        }
        logger.info(f"ì „ëµ í…œí”Œë¦¿ ë“±ë¡: {template.name}")
    
    def create_strategy_from_template(self, template_name: str, 
                                    custom_parameters: Dict = None) -> Optional[BaseStrategy]:
        """í…œí”Œë¦¿ìœ¼ë¡œë¶€í„° ì „ëµ ìƒì„±"""
        if template_name not in self.templates:
            logger.error(f"í…œí”Œë¦¿ì„ ì°¾ì„ ìˆ˜ ì—†ìŒ: {template_name}")
            return None
        
        template = self.templates[template_name]
        
        # íŒŒë¼ë¯¸í„° ë³‘í•©
        parameters = template.parameters.copy()
        if custom_parameters:
            parameters.update(custom_parameters)
        
        # ì „ëµ íƒ€ì…ì— ë”°ë¥¸ ì „ëµ ìƒì„±
        if template.strategy_type == "scalping":
            return ScalpingStrategy(template.name, parameters)
        elif template.strategy_type == "day_trading":
            return DayTradingStrategy(template.name, parameters)
        elif template.strategy_type == "swing_trading":
            return SwingTradingStrategy(template.name, parameters)
        else:
            logger.error(f"ì§€ì›í•˜ì§€ ì•ŠëŠ” ì „ëµ íƒ€ì…: {template.strategy_type}")
            return None
    
    def save_template(self, template: StrategyTemplate, file_path: str):
        """í…œí”Œë¦¿ ì €ì¥"""
        try:
            template_data = {
                'name': template.name,
                'description': template.description,
                'strategy_type': template.strategy_type,
                'parameters': template.parameters,
                'conditions': template.conditions,
                'actions': template.actions,
                'risk_management': template.risk_management,
                'version': template.version
            }
            
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(template_data, f, indent=2, ensure_ascii=False)
            
            logger.info(f"í…œí”Œë¦¿ ì €ì¥ ì™„ë£Œ: {file_path}")
            
        except Exception as e:
            logger.error(f"í…œí”Œë¦¿ ì €ì¥ ì˜¤ë¥˜: {e}")
    
    def load_template(self, file_path: str) -> Optional[StrategyTemplate]:
        """í…œí”Œë¦¿ ë¡œë“œ"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                template_data = json.load(f)
            
            template = StrategyTemplate(
                name=template_data['name'],
                description=template_data['description'],
                strategy_type=template_data['strategy_type'],
                parameters=template_data['parameters'],
                conditions=template_data['conditions'],
                actions=template_data['actions'],
                risk_management=template_data['risk_management'],
                version=template_data.get('version', '1.0')
            )
            
            self.register_template(template)
            logger.info(f"í…œí”Œë¦¿ ë¡œë“œ ì™„ë£Œ: {file_path}")
            return template
            
        except Exception as e:
            logger.error(f"í…œí”Œë¦¿ ë¡œë“œ ì˜¤ë¥˜: {e}")
            return None
    
    def list_templates(self) -> List[Dict[str, Any]]:
        """í…œí”Œë¦¿ ëª©ë¡ ë°˜í™˜"""
        return list(self.template_registry.values())
    
    def get_template_info(self, template_name: str) -> Optional[Dict[str, Any]]:
        """í…œí”Œë¦¿ ì •ë³´ ë°˜í™˜"""
        if template_name in self.template_registry:
            return self.template_registry[template_name]
        return None
```

## ğŸ”§ **ê³ ê¸‰ ì „ëµ ì‹œìŠ¤í…œ**

### ğŸ“¦ **ì–‘ì ì»´í“¨íŒ… ì „ëµ**

```python
# trading-strategies/advanced-strategies/quantum_strategies.py
import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass
from datetime import datetime
import logging
from qiskit import QuantumCircuit, Aer, execute
from qiskit.algorithms import VQE, QAOA
from qiskit.circuit.library import TwoLocal

logger = logging.getLogger(__name__)

@dataclass
class QuantumPortfolioOptimization:
    """ì–‘ì í¬íŠ¸í´ë¦¬ì˜¤ ìµœì í™”"""
    assets: List[str]
    weights: List[float]
    expected_return: float
    risk: float
    sharpe_ratio: float
    quantum_circuit: Optional[QuantumCircuit] = None

class QuantumTradingStrategy:
    """ì–‘ì ì»´í“¨íŒ… ê¸°ë°˜ ê±°ë˜ ì „ëµ"""
    
    def __init__(self, backend_name: str = 'qasm_simulator'):
        self.backend = Aer.get_backend(backend_name)
        self.optimization_history = []
    
    def optimize_portfolio_quantum(self, returns_data: pd.DataFrame, 
                                 risk_free_rate: float = 0.02) -> QuantumPortfolioOptimization:
        """ì–‘ì ì»´í“¨íŒ…ì„ ì´ìš©í•œ í¬íŠ¸í´ë¦¬ì˜¤ ìµœì í™”"""
        try:
            # ìˆ˜ìµë¥  ë° ê³µë¶„ì‚° í–‰ë ¬ ê³„ì‚°
            returns = returns_data.pct_change().dropna()
            covariance_matrix = returns.cov()
            expected_returns = returns.mean()
            
            # QAOAë¥¼ ì´ìš©í•œ í¬íŠ¸í´ë¦¬ì˜¤ ìµœì í™”
            num_assets = len(returns.columns)
            
            # ì–‘ì íšŒë¡œ ìƒì„±
            qc = QuantumCircuit(num_assets, num_assets)
            
            # ì´ˆê¸° ìƒíƒœ ì¤€ë¹„ (ê· ë“± ê°€ì¤‘ì¹˜)
            for i in range(num_assets):
                qc.h(i)
            
            # QAOA íŒŒë¼ë¯¸í„°
            p = 2  # QAOA ê¹Šì´
            gamma = np.random.uniform(0, 2*np.pi, p)
            beta = np.random.uniform(0, np.pi, p)
            
            # ë¹„ìš© í•¨ìˆ˜ (í¬íŠ¸í´ë¦¬ì˜¤ ë¶„ì‚°)
            for layer in range(p):
                # ë¹„ìš© í•´ë°€í† ë‹ˆì•ˆ
                for i in range(num_assets):
                    for j in range(i+1, num_assets):
                        if covariance_matrix.iloc[i, j] != 0:
                            qc.cx(i, j)
                            qc.rz(gamma[layer] * covariance_matrix.iloc[i, j], j)
                            qc.cx(i, j)
                
                # ë¯¹ì‹± í•´ë°€í† ë‹ˆì•ˆ
                for i in range(num_assets):
                    qc.rx(beta[layer], i)
            
            # ì¸¡ì •
            qc.measure_all()
            
            # ì–‘ì íšŒë¡œ ì‹¤í–‰
            job = execute(qc, self.backend, shots=1000)
            result = job.result()
            counts = result.get_counts()
            
            # ìµœì  ê°€ì¤‘ì¹˜ ì¶”ì¶œ
            optimal_bitstring = max(counts, key=counts.get)
            weights = [int(bit) for bit in optimal_bitstring]
            weights = np.array(weights) / np.sum(weights)
            
            # í¬íŠ¸í´ë¦¬ì˜¤ ì„±ê³¼ ê³„ì‚°
            portfolio_return = np.sum(weights * expected_returns)
            portfolio_risk = np.sqrt(weights.T @ covariance_matrix @ weights)
            sharpe_ratio = (portfolio_return - risk_free_rate) / portfolio_risk
            
            optimization = QuantumPortfolioOptimization(
                assets=list(returns.columns),
                weights=weights.tolist(),
                expected_return=portfolio_return,
                risk=portfolio_risk,
                sharpe_ratio=sharpe_ratio,
                quantum_circuit=qc
            )
            
            self.optimization_history.append(optimization)
            
            return optimization
            
        except Exception as e:
            logger.error(f"ì–‘ì í¬íŠ¸í´ë¦¬ì˜¤ ìµœì í™” ì˜¤ë¥˜: {e}")
            return None
```

### ğŸ“¦ **ê°ì • ê¸°ë°˜ ì „ëµ**

```python
# trading-strategies/advanced-strategies/sentiment_strategies.py
import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass
from datetime import datetime
import logging
from textblob import TextBlob
import tweepy
import requests

logger = logging.getLogger(__name__)

@dataclass
class SentimentSignal:
    """ê°ì • ì‹ í˜¸"""
    source: str  # 'twitter', 'news', 'reddit'
    sentiment_score: float  # -1.0 ~ 1.0
    confidence: float
    volume: int
    timestamp: datetime
    text: str

class SentimentBasedStrategy:
    """ê°ì • ê¸°ë°˜ ê±°ë˜ ì „ëµ"""
    
    def __init__(self, twitter_api_key: str = None, news_api_key: str = None):
        self.twitter_api_key = twitter_api_key
        self.news_api_key = news_api_key
        self.sentiment_history = []
        self.sentiment_threshold = 0.3
    
    def collect_social_sentiment(self, symbol: str, keywords: List[str]) -> List[SentimentSignal]:
        """ì†Œì…œ ë¯¸ë””ì–´ ê°ì • ìˆ˜ì§‘"""
        try:
            signals = []
            
            # Twitter ê°ì • ë¶„ì„
            if self.twitter_api_key:
                twitter_signals = self._analyze_twitter_sentiment(symbol, keywords)
                signals.extend(twitter_signals)
            
            # Reddit ê°ì • ë¶„ì„
            reddit_signals = self._analyze_reddit_sentiment(symbol, keywords)
            signals.extend(reddit_signals)
            
            # ë‰´ìŠ¤ ê°ì • ë¶„ì„
            if self.news_api_key:
                news_signals = self._analyze_news_sentiment(symbol, keywords)
                signals.extend(news_signals)
            
            return signals
            
        except Exception as e:
            logger.error(f"ì†Œì…œ ê°ì • ìˆ˜ì§‘ ì˜¤ë¥˜: {e}")
            return []
    
    def _analyze_twitter_sentiment(self, symbol: str, keywords: List[str]) -> List[SentimentSignal]:
        """Twitter ê°ì • ë¶„ì„"""
        try:
            signals = []
            
            # Twitter API í˜¸ì¶œ (ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” tweepy ì‚¬ìš©)
            # tweets = self.twitter_api.search_tweets(q=f"{symbol} {' '.join(keywords)}", count=100)
            
            # ì˜ˆì‹œ ë°ì´í„°
            tweets = [
                {"text": f"$AAPL is going to the moon! ğŸš€", "created_at": datetime.now()},
                {"text": f"$AAPL earnings look terrible", "created_at": datetime.now()},
                {"text": f"$AAPL new product announcement", "created_at": datetime.now()}
            ]
            
            for tweet in tweets:
                blob = TextBlob(tweet['text'])
                sentiment_score = blob.sentiment.polarity
                
                signal = SentimentSignal(
                    source='twitter',
                    sentiment_score=sentiment_score,
                    confidence=abs(sentiment_score),
                    volume=1,
                    timestamp=tweet['created_at'],
                    text=tweet['text']
                )
                signals.append(signal)
            
            return signals
            
        except Exception as e:
            logger.error(f"Twitter ê°ì • ë¶„ì„ ì˜¤ë¥˜: {e}")
            return []
    
    def generate_sentiment_signal(self, sentiment_signals: List[SentimentSignal]) -> Dict[str, Any]:
        """ê°ì • ê¸°ë°˜ ê±°ë˜ ì‹ í˜¸ ìƒì„±"""
        try:
            if not sentiment_signals:
                return {"signal": "HOLD", "confidence": 0.0, "reason": "ê°ì • ë°ì´í„° ì—†ìŒ"}
            
            # ê°€ì¤‘ í‰ê·  ê°ì • ì ìˆ˜ ê³„ì‚°
            total_weight = 0
            weighted_sentiment = 0
            
            for signal in sentiment_signals:
                weight = signal.confidence * signal.volume
                weighted_sentiment += signal.sentiment_score * weight
                total_weight += weight
            
            if total_weight == 0:
                return {"signal": "HOLD", "confidence": 0.0, "reason": "ìœ íš¨í•œ ê°ì • ë°ì´í„° ì—†ìŒ"}
            
            avg_sentiment = weighted_sentiment / total_weight
            
            # ì‹ í˜¸ ê²°ì •
            if avg_sentiment > self.sentiment_threshold:
                signal_type = "BUY"
                confidence = min(1.0, avg_sentiment)
            elif avg_sentiment < -self.sentiment_threshold:
                signal_type = "SELL"
                confidence = min(1.0, abs(avg_sentiment))
            else:
                signal_type = "HOLD"
                confidence = 0.0
            
            return {
                "signal": signal_type,
                "confidence": confidence,
                "sentiment_score": avg_sentiment,
                "signal_count": len(sentiment_signals),
                "reason": f"ê°ì • ê¸°ë°˜ ì‹ í˜¸: {avg_sentiment:.3f}"
            }
            
        except Exception as e:
            logger.error(f"ê°ì • ì‹ í˜¸ ìƒì„± ì˜¤ë¥˜: {e}")
            return {"signal": "HOLD", "confidence": 0.0, "reason": f"ì˜¤ë¥˜: {str(e)}"}
```

### ğŸ“¦ **ë§ˆì´í¬ë¡œ êµ¬ì¡° ì „ëµ**

```python
# trading-strategies/advanced-strategies/microstructure_strategies.py
import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional, Any
from dataclasses import dataclass
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

@dataclass
class OrderBookSnapshot:
    """ì£¼ë¬¸ì¥ ìŠ¤ëƒ…ìƒ·"""
    timestamp: datetime
    symbol: str
    bids: List[Tuple[float, float]]  # (ê°€ê²©, ìˆ˜ëŸ‰)
    asks: List[Tuple[float, float]]  # (ê°€ê²©, ìˆ˜ëŸ‰)
    spread: float
    mid_price: float
    order_imbalance: float

@dataclass
class MicrostructureSignal:
    """ë§ˆì´í¬ë¡œ êµ¬ì¡° ì‹ í˜¸"""
    signal_type: str
    strength: float
    confidence: float
    order_imbalance: float
    spread_change: float
    volume_profile: Dict[str, float]
    timestamp: datetime

class MicrostructureStrategy:
    """ë§ˆì´í¬ë¡œ êµ¬ì¡° ê¸°ë°˜ ê±°ë˜ ì „ëµ"""
    
    def __init__(self, lookback_period: int = 100):
        self.lookback_period = lookback_period
        self.order_book_history = []
        self.liquidity_threshold = 0.1
    
    def analyze_order_book(self, order_book: OrderBookSnapshot) -> MicrostructureSignal:
        """ì£¼ë¬¸ì¥ ë¶„ì„"""
        try:
            # ì£¼ë¬¸ ë¶ˆê· í˜• ê³„ì‚°
            bid_volume = sum(quantity for _, quantity in order_book.bids)
            ask_volume = sum(quantity for _, quantity in order_book.asks)
            order_imbalance = (bid_volume - ask_volume) / (bid_volume + ask_volume)
            
            # ìŠ¤í”„ë ˆë“œ ë³€í™” ê³„ì‚°
            spread_change = 0.0
            if len(self.order_book_history) > 0:
                prev_spread = self.order_book_history[-1].spread
                spread_change = (order_book.spread - prev_spread) / prev_spread
            
            # ìœ ë™ì„± í”„ë¡œíŒŒì¼ ë¶„ì„
            volume_profile = self._analyze_volume_profile(order_book)
            
            # ì‹ í˜¸ ìƒì„±
            signal = self._generate_microstructure_signal(
                order_imbalance, spread_change, volume_profile
            )
            
            # íˆìŠ¤í† ë¦¬ ì—…ë°ì´íŠ¸
            self.order_book_history.append(order_book)
            if len(self.order_book_history) > self.lookback_period:
                self.order_book_history.pop(0)
            
            return signal
            
        except Exception as e:
            logger.error(f"ì£¼ë¬¸ì¥ ë¶„ì„ ì˜¤ë¥˜: {e}")
            return None
    
    def _analyze_volume_profile(self, order_book: OrderBookSnapshot) -> Dict[str, float]:
        """ê±°ë˜ëŸ‰ í”„ë¡œíŒŒì¼ ë¶„ì„"""
        try:
            profile = {
                'bid_volume': sum(quantity for _, quantity in order_book.bids),
                'ask_volume': sum(quantity for _, quantity in order_book.asks),
                'bid_depth': len(order_book.bids),
                'ask_depth': len(order_book.asks),
                'avg_bid_size': np.mean([quantity for _, quantity in order_book.bids]) if order_book.bids else 0,
                'avg_ask_size': np.mean([quantity for _, quantity in order_book.asks]) if order_book.asks else 0
            }
            
            return profile
            
        except Exception as e:
            logger.error(f"ê±°ë˜ëŸ‰ í”„ë¡œíŒŒì¼ ë¶„ì„ ì˜¤ë¥˜: {e}")
            return {}
    
    def _generate_microstructure_signal(self, order_imbalance: float, 
                                      spread_change: float, 
                                      volume_profile: Dict[str, float]) -> MicrostructureSignal:
        """ë§ˆì´í¬ë¡œ êµ¬ì¡° ì‹ í˜¸ ìƒì„±"""
        try:
            signal_type = "HOLD"
            strength = 0.0
            confidence = 0.0
            
            # ì£¼ë¬¸ ë¶ˆê· í˜• ê¸°ë°˜ ì‹ í˜¸
            if abs(order_imbalance) > self.liquidity_threshold:
                if order_imbalance > 0:
                    signal_type = "BUY"
                    strength = min(1.0, order_imbalance)
                else:
                    signal_type = "SELL"
                    strength = min(1.0, abs(order_imbalance))
            
            # ìŠ¤í”„ë ˆë“œ ë³€í™” ê³ ë ¤
            if abs(spread_change) > 0.1:  # 10% ì´ìƒ ìŠ¤í”„ë ˆë“œ ë³€í™”
                if spread_change > 0:  # ìŠ¤í”„ë ˆë“œ í™•ëŒ€ (ìœ ë™ì„± ê°ì†Œ)
                    if signal_type == "BUY":
                        strength *= 0.8  # ì‹ í˜¸ ê°•ë„ ê°ì†Œ
                    elif signal_type == "SELL":
                        strength *= 1.2  # ì‹ í˜¸ ê°•ë„ ì¦ê°€
                else:  # ìŠ¤í”„ë ˆë“œ ì¶•ì†Œ (ìœ ë™ì„± ì¦ê°€)
                    if signal_type == "BUY":
                        strength *= 1.2  # ì‹ í˜¸ ê°•ë„ ì¦ê°€
                    elif signal_type == "SELL":
                        strength *= 0.8  # ì‹ í˜¸ ê°•ë„ ê°ì†Œ
            
            # ì‹ ë¢°ë„ ê³„ì‚°
            confidence = min(1.0, strength * 0.8 + 0.2)  # ê¸°ë³¸ ì‹ ë¢°ë„ 20%
            
            return MicrostructureSignal(
                signal_type=signal_type,
                strength=strength,
                confidence=confidence,
                order_imbalance=order_imbalance,
                spread_change=spread_change,
                volume_profile=volume_profile,
                timestamp=datetime.now()
            )
            
        except Exception as e:
            logger.error(f"ë§ˆì´í¬ë¡œ êµ¬ì¡° ì‹ í˜¸ ìƒì„± ì˜¤ë¥˜: {e}")
            return MicrostructureSignal(
                signal_type="HOLD",
                strength=0.0,
                confidence=0.0,
                order_imbalance=0.0,
                spread_change=0.0,
                volume_profile={},
                timestamp=datetime.now()
            )
```

## ğŸ“Š **ì„±ê³¼ ì§€í‘œ**

### **ëª©í‘œ ì„±ê³¼**
- **ì „ëµ ì„±ê³µë¥ **: 60% ì´ìƒ
- **ë°±í…ŒìŠ¤íŠ¸ ì •í™•ë„**: 70% ì´ìƒ
- **ì „ëµ ìµœì í™” ì‹œê°„**: < 10ë¶„
- **í…œí”Œë¦¿ ì¬ì‚¬ìš©ë¥ **: 80% ì´ìƒ
- **AI í•™ìŠµ ì •í™•ë„**: 65% ì´ìƒ
- **ì–‘ì ì „ëµ ì„±ê³µë¥ **: > 70% ì–‘ì ì•Œê³ ë¦¬ì¦˜ ì„±ê³µë¥ 
- **ê°ì • ì „ëµ ì •í™•ë„**: > 65% ê°ì • ê¸°ë°˜ ì „ëµ ì •í™•ë„
- **ë§ˆì´í¬ë¡œ êµ¬ì¡° ì „ëµ**: > 80% ë§ˆì´í¬ë¡œ êµ¬ì¡° ì „ëµ ì •í™•ë„
- **ì•™ìƒë¸” ì „ëµ ì„±ê³µë¥ **: > 75% ì•™ìƒë¸” ì „ëµ ì„±ê³µë¥ 

### **ì„±ëŠ¥ ì§€í‘œ**
- **ì „ëµ ì‹¤í–‰ ì†ë„**: < 50ms
- **ë°±í…ŒìŠ¤íŠ¸ ì†ë„**: < 1ë¶„/1ë…„
- **í…œí”Œë¦¿ ìƒì„± ì‹œê°„**: < 1ì´ˆ
- **ê³ ê¸‰ ì „ëµ ì‹¤í–‰**: < 100ms
- **ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰**: < 1GB per strategy
- **ì‹œìŠ¤í…œ ê°€ë™ë¥ **: > 99.5%

## ğŸ”— **ê´€ë ¨ ë¬¸ì„œ**

- [Phase 3.5.1: ê¸°ìˆ ì  ì§€í‘œ ë¶„ì„](3.5.1_TECHNICAL_ANALYSIS.md)
- [Phase 3.5.3: ë‰´ìŠ¤ ì´ë²¤íŠ¸ ë¶„ì„](3.5.3_NEWS_EVENT_ANALYSIS.md)
- [Phase 3.5.4: ì˜¨ë¼ì¸ í•™ìŠµ](3.5.4_ONLINE_LEARNING.md)
- [Phase 3.5.5: ì„¤ëª… ê°€ëŠ¥í•œ AI](3.5.5_EXPLAINABLE_AI.md)

## ğŸ”§ **ìƒˆë¡œìš´ ëª¨ë“ˆ êµ¬í˜„ ì½”ë“œ**

### ğŸ“Š **ë‹¤ì´ë‚˜ë¯¹ í¬íŠ¸í´ë¦¬ì˜¤ ë¦¬ë°¸ëŸ°ì‹± ì‹œìŠ¤í…œ**

```python
# trading-strategies/dynamic-portfolio-rebalancing/portfolio_rebalancer.py
import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass
from datetime import datetime, timedelta
import logging

logger = logging.getLogger(__name__)

@dataclass
class PortfolioAllocation:
    """í¬íŠ¸í´ë¦¬ì˜¤ ë°°ë¶„"""
    asset_id: str
    target_weight: float
    current_weight: float
    rebalance_amount: float
    risk_contribution: float

class DynamicPortfolioRebalancer:
    """ë‹¤ì´ë‚˜ë¯¹ í¬íŠ¸í´ë¦¬ì˜¤ ë¦¬ë°¸ëŸ°ì„œ"""
    
    def __init__(self, rebalance_threshold: float = 0.05):
        self.rebalance_threshold = rebalance_threshold
        self.risk_free_rate = 0.02
        
    def calculate_optimal_weights(self, asset_data: Dict[str, Dict], 
                                risk_budget: Dict[str, float]) -> Dict[str, float]:
        """ìµœì  ê°€ì¤‘ì¹˜ ê³„ì‚° (Risk Parity ê¸°ë°˜)"""
        try:
            # ìˆ˜ìµë¥  ë° ê³µë¶„ì‚° í–‰ë ¬ ê³„ì‚°
            returns_data = {}
            for asset_id, data in asset_data.items():
                if 'returns' in data and len(data['returns']) > 0:
                    returns_data[asset_id] = data['returns']
            
            if len(returns_data) < 2:
                return {}
            
            # ê³µë¶„ì‚° í–‰ë ¬ ê³„ì‚°
            returns_df = pd.DataFrame(returns_data)
            cov_matrix = returns_df.cov()
            
            # Risk Parity ìµœì í™”
            n_assets = len(returns_data)
            initial_weights = np.array([1/n_assets] * n_assets)
            
            # ë°˜ë³µì  ìµœì í™”
            max_iterations = 100
            tolerance = 1e-6
            
            for iteration in range(max_iterations):
                # í˜„ì¬ ë¦¬ìŠ¤í¬ ê¸°ì—¬ë„ ê³„ì‚°
                portfolio_vol = np.sqrt(initial_weights.T @ cov_matrix @ initial_weights)
                risk_contrib = (cov_matrix @ initial_weights) * initial_weights / portfolio_vol
                
                # ë¦¬ìŠ¤í¬ ì˜ˆì‚°ê³¼ì˜ ì°¨ì´ ê³„ì‚°
                target_risk = np.array([risk_budget.get(asset, 1/n_assets) for asset in returns_data.keys()])
                risk_diff = risk_contrib - target_risk * portfolio_vol
                
                # ê°€ì¤‘ì¹˜ ì¡°ì •
                if np.max(np.abs(risk_diff)) < tolerance:
                    break
                
                # ê°„ë‹¨í•œ ê·¸ë¼ë””ì–¸íŠ¸ ë””ì„¼íŠ¸
                adjustment = -0.1 * risk_diff / portfolio_vol
                initial_weights += adjustment
                initial_weights = np.maximum(0, initial_weights)  # ìŒìˆ˜ ê°€ì¤‘ì¹˜ ë°©ì§€
                initial_weights /= np.sum(initial_weights)  # ì •ê·œí™”
            
            return dict(zip(returns_data.keys(), initial_weights))
            
        except Exception as e:
            logger.error(f"ìµœì  ê°€ì¤‘ì¹˜ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return {}
    
    def check_rebalance_needed(self, current_weights: Dict[str, float], 
                             target_weights: Dict[str, float]) -> bool:
        """ë¦¬ë°¸ëŸ°ì‹± í•„ìš” ì—¬ë¶€ í™•ì¸"""
        try:
            for asset_id in current_weights:
                if asset_id in target_weights:
                    weight_diff = abs(current_weights[asset_id] - target_weights[asset_id])
                    if weight_diff > self.rebalance_threshold:
                        return True
            return False
            
        except Exception as e:
            logger.error(f"ë¦¬ë°¸ëŸ°ì‹± í•„ìš” ì—¬ë¶€ í™•ì¸ ì˜¤ë¥˜: {e}")
            return False
    
    def calculate_rebalance_trades(self, current_weights: Dict[str, float], 
                                 target_weights: Dict[str, float], 
                                 portfolio_value: float) -> List[Dict]:
        """ë¦¬ë°¸ëŸ°ì‹± ê±°ë˜ ê³„ì‚°"""
        try:
            trades = []
            
            for asset_id in set(current_weights.keys()) | set(target_weights.keys()):
                current_weight = current_weights.get(asset_id, 0)
                target_weight = target_weights.get(asset_id, 0)
                
                current_value = current_weight * portfolio_value
                target_value = target_weight * portfolio_value
                trade_value = target_value - current_value
                
                if abs(trade_value) > portfolio_value * 0.001:  # 0.1% ì´ìƒ ì°¨ì´
                    trades.append({
                        'asset_id': asset_id,
                        'trade_type': 'BUY' if trade_value > 0 else 'SELL',
                        'trade_value': abs(trade_value),
                        'weight_change': target_weight - current_weight
                    })
            
            return trades
            
        except Exception as e:
            logger.error(f"ë¦¬ë°¸ëŸ°ì‹± ê±°ë˜ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return []
    
    def risk_budget_optimization(self, asset_data: Dict[str, Dict], 
                               risk_budget: Dict[str, float]) -> Dict[str, float]:
        """ë¦¬ìŠ¤í¬ ì˜ˆì‚° ìµœì í™”"""
        try:
            # ê° ìì‚°ì˜ ë³€ë™ì„± ê³„ì‚°
            volatilities = {}
            for asset_id, data in asset_data.items():
                if 'returns' in data and len(data['returns']) > 0:
                    volatilities[asset_id] = np.std(data['returns'])
            
            # ë¦¬ìŠ¤í¬ ì˜ˆì‚° ê¸°ë°˜ ê°€ì¤‘ì¹˜ ê³„ì‚°
            total_risk_budget = sum(risk_budget.values())
            weights = {}
            
            for asset_id, risk_allocation in risk_budget.items():
                if asset_id in volatilities and volatilities[asset_id] > 0:
                    weights[asset_id] = risk_allocation / (volatilities[asset_id] * total_risk_budget)
                else:
                    weights[asset_id] = 0
            
            # ì •ê·œí™”
            total_weight = sum(weights.values())
            if total_weight > 0:
                weights = {k: v / total_weight for k, v in weights.items()}
            
            return weights
            
        except Exception as e:
            logger.error(f"ë¦¬ìŠ¤í¬ ì˜ˆì‚° ìµœì í™” ì˜¤ë¥˜: {e}")
            return {}
```

### âš¡ **HFT ì‹¤í–‰ ìµœì í™” ì‹œìŠ¤í…œ**

```python
# trading-strategies/hft-execution-optimization/hft_execution_optimizer.py
import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass
from datetime import datetime, timedelta
import logging

logger = logging.getLogger(__name__)

@dataclass
class ExecutionStrategy:
    """ì‹¤í–‰ ì „ëµ"""
    strategy_type: str
    parameters: Dict[str, float]
    expected_impact: float
    execution_time: float

class HFTExecutionOptimizer:
    """HFT ì‹¤í–‰ ìµœì í™”ê¸°"""
    
    def __init__(self):
        self.min_order_size = 100
        self.max_order_size = 10000
        self.impact_model = 'linear'
        
    def optimize_order_splitting(self, total_quantity: int, 
                               market_impact_model: str = 'linear') -> List[int]:
        """ì£¼ë¬¸ ë¶„í•  ìµœì í™”"""
        try:
            if total_quantity <= self.min_order_size:
                return [total_quantity]
            
            # ì‹œì¥ ì˜í–¥ ëª¨ë¸ì— ë”°ë¥¸ ìµœì  ë¶„í• 
            if market_impact_model == 'linear':
                # ì„ í˜• ì˜í–¥ ëª¨ë¸: ê· ë“± ë¶„í• 
                num_splits = max(1, int(np.sqrt(total_quantity / self.min_order_size)))
                split_size = total_quantity // num_splits
                remainder = total_quantity % num_splits
                
                splits = [split_size] * num_splits
                if remainder > 0:
                    splits[0] += remainder
                
            elif market_impact_model == 'square_root':
                # ì œê³±ê·¼ ì˜í–¥ ëª¨ë¸: ì ì§„ì  ê°ì†Œ
                splits = []
                remaining = total_quantity
                
                while remaining > 0:
                    split_size = min(remaining, int(np.sqrt(remaining)))
                    splits.append(split_size)
                    remaining -= split_size
                    
            else:  # exponential
                # ì§€ìˆ˜ì  ì˜í–¥ ëª¨ë¸: ê¸‰ê²©í•œ ê°ì†Œ
                splits = []
                remaining = total_quantity
                decay_factor = 0.7
                
                while remaining > 0:
                    split_size = min(remaining, int(remaining * decay_factor))
                    if split_size < self.min_order_size:
                        split_size = min(remaining, self.min_order_size)
                    splits.append(split_size)
                    remaining -= split_size
            
            return splits
            
        except Exception as e:
            logger.error(f"ì£¼ë¬¸ ë¶„í•  ìµœì í™” ì˜¤ë¥˜: {e}")
            return [total_quantity]
    
    def calculate_market_impact(self, order_size: int, 
                              market_volume: float, 
                              volatility: float) -> float:
        """ì‹œì¥ ì˜í–¥ ê³„ì‚°"""
        try:
            # ê¸°ë³¸ ì˜í–¥ ëª¨ë¸
            volume_ratio = order_size / market_volume
            base_impact = 0.1 * volume_ratio  # ê¸°ë³¸ 10% ì˜í–¥
            
            # ë³€ë™ì„± ì¡°ì •
            volatility_adjustment = 1 + (volatility - 0.02) * 10  # 2% ê¸°ì¤€
            
            # ìµœì¢… ì˜í–¥
            impact = base_impact * volatility_adjustment
            
            return max(0, min(1, impact))  # 0-100% ë²”ìœ„ ì œí•œ
            
        except Exception as e:
            logger.error(f"ì‹œì¥ ì˜í–¥ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return 0.0
    
    def optimize_execution_timing(self, market_data: Dict[str, List], 
                                target_quantity: int) -> List[Dict]:
        """ì‹¤í–‰ íƒ€ì´ë° ìµœì í™”"""
        try:
            # ì‹œì¥ ìƒí™© ë¶„ì„
            volume_profile = self._analyze_volume_profile(market_data.get('volume', []))
            volatility_profile = self._analyze_volatility_profile(market_data.get('returns', []))
            
            # ìµœì  ì‹¤í–‰ ì‹œê°„ëŒ€ ì°¾ê¸°
            optimal_times = []
            
            for i, (volume, volatility) in enumerate(zip(volume_profile, volatility_profile)):
                # ê±°ë˜ëŸ‰ì´ ë†’ê³  ë³€ë™ì„±ì´ ë‚®ì€ ì‹œê°„ëŒ€ ì„ í˜¸
                volume_score = volume / max(volume_profile) if volume_profile else 0
                volatility_score = 1 - (volatility / max(volatility_profile)) if volatility_profile else 0
                
                combined_score = 0.7 * volume_score + 0.3 * volatility_score
                
                if combined_score > 0.6:  # ì„ê³„ê°’
                    optimal_times.append({
                        'time_index': i,
                        'score': combined_score,
                        'volume': volume,
                        'volatility': volatility
                    })
            
            # ì ìˆ˜ë³„ ì •ë ¬
            optimal_times.sort(key=lambda x: x['score'], reverse=True)
            
            return optimal_times
            
        except Exception as e:
            logger.error(f"ì‹¤í–‰ íƒ€ì´ë° ìµœì í™” ì˜¤ë¥˜: {e}")
            return []
    
    def calculate_optimal_order_size(self, market_volume: float, 
                                   volatility: float, 
                                   urgency: float) -> int:
        """ìµœì  ì£¼ë¬¸ í¬ê¸° ê³„ì‚°"""
        try:
            # ê¸°ë³¸ ì£¼ë¬¸ í¬ê¸° (ì‹œì¥ ê±°ë˜ëŸ‰ì˜ 1%)
            base_size = int(market_volume * 0.01)
            
            # ë³€ë™ì„± ì¡°ì •
            volatility_adjustment = 1 / (1 + volatility * 10)  # ë³€ë™ì„± ë†’ì„ìˆ˜ë¡ ì‘ì€ ì£¼ë¬¸
            
            # ê¸´ê¸‰ë„ ì¡°ì •
            urgency_adjustment = 1 + urgency * 2  # ê¸´ê¸‰í• ìˆ˜ë¡ í° ì£¼ë¬¸
            
            # ìµœì¢… ì£¼ë¬¸ í¬ê¸°
            optimal_size = int(base_size * volatility_adjustment * urgency_adjustment)
            
            # ë²”ìœ„ ì œí•œ
            optimal_size = max(self.min_order_size, min(self.max_order_size, optimal_size))
            
            return optimal_size
            
        except Exception as e:
            logger.error(f"ìµœì  ì£¼ë¬¸ í¬ê¸° ê³„ì‚° ì˜¤ë¥˜: {e}")
            return self.min_order_size
    
    def _analyze_volume_profile(self, volume_data: List[float]) -> List[float]:
        """ê±°ë˜ëŸ‰ í”„ë¡œíŒŒì¼ ë¶„ì„"""
        if not volume_data:
            return []
        
        # ì‹œê°„ëŒ€ë³„ í‰ê·  ê±°ë˜ëŸ‰
        hourly_volumes = []
        for hour in range(24):
            hour_data = [v for i, v in enumerate(volume_data) if i % 24 == hour]
            if hour_data:
                hourly_volumes.append(np.mean(hour_data))
            else:
                hourly_volumes.append(0)
        
        return hourly_volumes
    
    def _analyze_volatility_profile(self, returns_data: List[float]) -> List[float]:
        """ë³€ë™ì„± í”„ë¡œíŒŒì¼ ë¶„ì„"""
        if not returns_data:
            return []
        
        # ì‹œê°„ëŒ€ë³„ ë³€ë™ì„±
        hourly_volatilities = []
        for hour in range(24):
            hour_data = [r for i, r in enumerate(returns_data) if i % 24 == hour]
            if hour_data:
                hourly_volatilities.append(np.std(hour_data))
            else:
                hourly_volatilities.append(0)
        
        return hourly_volatilities
```

### ğŸ”¬ **ê³ ê¸‰ ë°±í…ŒìŠ¤íŒ… ì‹œìŠ¤í…œ**

```python
# trading-strategies/advanced-backtesting/advanced_backtest_engine.py
import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional, Callable
from dataclasses import dataclass
from datetime import datetime, timedelta
import logging
from scipy import stats

logger = logging.getLogger(__name__)

@dataclass
class BacktestResult:
    """ë°±í…ŒìŠ¤íŠ¸ ê²°ê³¼"""
    total_return: float
    sharpe_ratio: float
    max_drawdown: float
    win_rate: float
    profit_factor: float
    calmar_ratio: float
    trades: List[Dict]

class AdvancedBacktestEngine:
    """ê³ ê¸‰ ë°±í…ŒìŠ¤íŠ¸ ì—”ì§„"""
    
    def __init__(self):
        self.risk_free_rate = 0.02
        self.min_trades = 10
        
    def walk_forward_test(self, strategy_func: Callable, 
                         data: pd.DataFrame, 
                         window_size: int = 252,
                         step_size: int = 63) -> List[BacktestResult]:
        """ì›Œí¬í¬ì›Œë“œ í…ŒìŠ¤íŠ¸"""
        try:
            results = []
            total_length = len(data)
            
            for start_idx in range(0, total_length - window_size, step_size):
                end_idx = start_idx + window_size
                
                # í›ˆë ¨ ë°ì´í„°
                train_data = data.iloc[start_idx:end_idx]
                
                # ì „ëµ ì‹¤í–‰
                strategy_result = strategy_func(train_data)
                
                # ì„±ê³¼ ê³„ì‚°
                result = self._calculate_performance(strategy_result)
                results.append(result)
            
            return results
            
        except Exception as e:
            logger.error(f"ì›Œí¬í¬ì›Œë“œ í…ŒìŠ¤íŠ¸ ì˜¤ë¥˜: {e}")
            return []
    
    def monte_carlo_simulation(self, strategy_func: Callable, 
                             data: pd.DataFrame, 
                             num_simulations: int = 1000,
                             simulation_length: int = 252) -> Dict[str, List[float]]:
        """ëª¬í…Œì¹´ë¥¼ë¡œ ì‹œë®¬ë ˆì´ì…˜"""
        try:
            returns_distribution = []
            sharpe_distribution = []
            max_dd_distribution = []
            
            for sim in range(num_simulations):
                # ë¶€íŠ¸ìŠ¤íŠ¸ë© ìƒ˜í”Œë§
                bootstrap_indices = np.random.choice(len(data), simulation_length, replace=True)
                bootstrap_data = data.iloc[bootstrap_indices].reset_index(drop=True)
                
                # ì „ëµ ì‹¤í–‰
                strategy_result = strategy_func(bootstrap_data)
                
                # ì„±ê³¼ ê³„ì‚°
                result = self._calculate_performance(strategy_result)
                
                returns_distribution.append(result.total_return)
                sharpe_distribution.append(result.sharpe_ratio)
                max_dd_distribution.append(result.max_drawdown)
            
            return {
                'returns': returns_distribution,
                'sharpe_ratios': sharpe_distribution,
                'max_drawdowns': max_dd_distribution
            }
            
        except Exception as e:
            logger.error(f"ëª¬í…Œì¹´ë¥¼ë¡œ ì‹œë®¬ë ˆì´ì…˜ ì˜¤ë¥˜: {e}")
            return {}
    
    def stress_test(self, strategy_func: Callable, 
                   data: pd.DataFrame, 
                   stress_scenarios: List[Dict]) -> Dict[str, BacktestResult]:
        """ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸"""
        try:
            stress_results = {}
            
            for scenario_name, scenario_params in stress_scenarios.items():
                # ìŠ¤íŠ¸ë ˆìŠ¤ ì‹œë‚˜ë¦¬ì˜¤ ì ìš©
                stressed_data = self._apply_stress_scenario(data, scenario_params)
                
                # ì „ëµ ì‹¤í–‰
                strategy_result = strategy_func(stressed_data)
                
                # ì„±ê³¼ ê³„ì‚°
                result = self._calculate_performance(strategy_result)
                stress_results[scenario_name] = result
            
            return stress_results
            
        except Exception as e:
            logger.error(f"ìŠ¤íŠ¸ë ˆìŠ¤ í…ŒìŠ¤íŠ¸ ì˜¤ë¥˜: {e}")
            return {}
    
    def scenario_analysis(self, strategy_func: Callable, 
                         data: pd.DataFrame, 
                         scenarios: List[Dict]) -> Dict[str, Dict]:
        """ì‹œë‚˜ë¦¬ì˜¤ ë¶„ì„"""
        try:
            scenario_results = {}
            
            for scenario in scenarios:
                scenario_name = scenario.get('name', 'unknown')
                scenario_data = self._create_scenario_data(data, scenario)
                
                # ì „ëµ ì‹¤í–‰
                strategy_result = strategy_func(scenario_data)
                
                # ì„±ê³¼ ê³„ì‚°
                result = self._calculate_performance(strategy_result)
                
                scenario_results[scenario_name] = {
                    'performance': result,
                    'scenario_params': scenario
                }
            
            return scenario_results
            
        except Exception as e:
            logger.error(f"ì‹œë‚˜ë¦¬ì˜¤ ë¶„ì„ ì˜¤ë¥˜: {e}")
            return {}
    
    def _calculate_performance(self, strategy_result: Dict) -> BacktestResult:
        """ì„±ê³¼ ê³„ì‚°"""
        try:
            trades = strategy_result.get('trades', [])
            
            if len(trades) < self.min_trades:
                return BacktestResult(0, 0, 0, 0, 0, 0, trades)
            
            # ìˆ˜ìµë¥  ê³„ì‚°
            returns = [trade.get('return', 0) for trade in trades]
            total_return = np.sum(returns)
            
            # ìƒ¤í”„ ë¹„ìœ¨
            if len(returns) > 1:
                sharpe_ratio = (np.mean(returns) - self.risk_free_rate) / np.std(returns)
            else:
                sharpe_ratio = 0
            
            # ìµœëŒ€ ë‚™í­
            cumulative_returns = np.cumsum(returns)
            running_max = np.maximum.accumulate(cumulative_returns)
            drawdowns = cumulative_returns - running_max
            max_drawdown = np.min(drawdowns)
            
            # ìŠ¹ë¥ 
            winning_trades = [r for r in returns if r > 0]
            win_rate = len(winning_trades) / len(returns)
            
            # ìˆ˜ìµ íŒ©í„°
            total_profit = sum([r for r in returns if r > 0])
            total_loss = abs(sum([r for r in returns if r < 0]))
            profit_factor = total_profit / total_loss if total_loss > 0 else float('inf')
            
            # ì¹¼ë§ˆ ë¹„ìœ¨
            calmar_ratio = total_return / abs(max_drawdown) if max_drawdown != 0 else 0
            
            return BacktestResult(
                total_return=total_return,
                sharpe_ratio=sharpe_ratio,
                max_drawdown=max_drawdown,
                win_rate=win_rate,
                profit_factor=profit_factor,
                calmar_ratio=calmar_ratio,
                trades=trades
            )
            
        except Exception as e:
            logger.error(f"ì„±ê³¼ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return BacktestResult(0, 0, 0, 0, 0, 0, [])
    
    def _apply_stress_scenario(self, data: pd.DataFrame, scenario: Dict) -> pd.DataFrame:
        """ìŠ¤íŠ¸ë ˆìŠ¤ ì‹œë‚˜ë¦¬ì˜¤ ì ìš©"""
        stressed_data = data.copy()
        
        # ê°€ê²© ì¶©ê²©
        if 'price_shock' in scenario:
            shock = scenario['price_shock']
            stressed_data['close'] *= (1 + shock)
        
        # ë³€ë™ì„± ì¦ê°€
        if 'volatility_multiplier' in scenario:
            multiplier = scenario['volatility_multiplier']
            stressed_data['returns'] *= multiplier
        
        # ê±°ë˜ëŸ‰ ê°ì†Œ
        if 'volume_reduction' in scenario:
            reduction = scenario['volume_reduction']
            stressed_data['volume'] *= (1 - reduction)
        
        return stressed_data
    
    def _create_scenario_data(self, data: pd.DataFrame, scenario: Dict) -> pd.DataFrame:
        """ì‹œë‚˜ë¦¬ì˜¤ ë°ì´í„° ìƒì„±"""
        scenario_data = data.copy()
        
        # ì‹œì¥ ìƒí™© ì‹œë®¬ë ˆì´ì…˜
        if scenario.get('market_crash'):
            # ì‹œì¥ í­ë½ ì‹œë‚˜ë¦¬ì˜¤
            crash_period = scenario.get('crash_period', 30)
            crash_magnitude = scenario.get('crash_magnitude', -0.2)
            
            for i in range(min(crash_period, len(scenario_data))):
                scenario_data.iloc[-(i+1), scenario_data.columns.get_loc('close')] *= (1 + crash_magnitude)
        
        elif scenario.get('bull_market'):
            # ìƒìŠ¹ì¥ ì‹œë‚˜ë¦¬ì˜¤
            bull_period = scenario.get('bull_period', 60)
            bull_magnitude = scenario.get('bull_magnitude', 0.1)
            
            for i in range(min(bull_period, len(scenario_data))):
                scenario_data.iloc[-(i+1), scenario_data.columns.get_loc('close')] *= (1 + bull_magnitude)
        
        return scenario_data
```

### ğŸ›¡ï¸ **ê³ ê¸‰ ë¦¬ìŠ¤í¬ ê´€ë¦¬ ì‹œìŠ¤í…œ**

```python
# trading-strategies/advanced-risk-management/advanced_risk_manager.py
import numpy as np
import pandas as pd
from typing import Dict, List, Tuple, Optional
from dataclasses import dataclass
from datetime import datetime, timedelta
import logging

logger = logging.getLogger(__name__)

@dataclass
class RiskMetrics:
    """ë¦¬ìŠ¤í¬ ë©”íŠ¸ë¦­"""
    var_95: float
    cvar_95: float
    max_drawdown: float
    volatility: float
    beta: float
    sharpe_ratio: float

class AdvancedRiskManager:
    """ê³ ê¸‰ ë¦¬ìŠ¤í¬ ê´€ë¦¬ì"""
    
    def __init__(self, initial_capital: float = 100000):
        self.initial_capital = initial_capital
        self.current_capital = initial_capital
        self.max_position_size = 0.1  # 10% ìµœëŒ€ í¬ì§€ì…˜
        self.max_portfolio_risk = 0.02  # 2% ìµœëŒ€ í¬íŠ¸í´ë¦¬ì˜¤ ë¦¬ìŠ¤í¬
        
    def calculate_position_size(self, signal_strength: float, 
                              volatility: float, 
                              account_size: float,
                              risk_per_trade: float = 0.01) -> float:
        """í¬ì§€ì…˜ í¬ê¸° ê³„ì‚° (Kelly Criterion ê¸°ë°˜)"""
        try:
            # Kelly Criterion
            win_rate = 0.5 + signal_strength * 0.3  # ì‹ í˜¸ ê°•ë„ ê¸°ë°˜ ìŠ¹ë¥ 
            avg_win = 0.02  # í‰ê·  ìˆ˜ìµ
            avg_loss = 0.01  # í‰ê·  ì†ì‹¤
            
            kelly_fraction = (win_rate * avg_win - (1 - win_rate) * avg_loss) / avg_win
            
            # ë³€ë™ì„± ì¡°ì •
            volatility_adjustment = 1 / (1 + volatility * 10)
            
            # ìµœì¢… í¬ì§€ì…˜ í¬ê¸°
            position_size = kelly_fraction * volatility_adjustment * risk_per_trade
            
            # ë²”ìœ„ ì œí•œ
            position_size = max(0.001, min(self.max_position_size, position_size))
            
            return position_size * account_size
            
        except Exception as e:
            logger.error(f"í¬ì§€ì…˜ í¬ê¸° ê³„ì‚° ì˜¤ë¥˜: {e}")
            return account_size * 0.01  # ê¸°ë³¸ 1%
    
    def calculate_var_cvar(self, returns: List[float], 
                          confidence_level: float = 0.95) -> Tuple[float, float]:
        """VaR ë° CVaR ê³„ì‚°"""
        try:
            if len(returns) < 30:
                return 0.0, 0.0
            
            returns_array = np.array(returns)
            
            # VaR ê³„ì‚°
            var_percentile = (1 - confidence_level) * 100
            var = np.percentile(returns_array, var_percentile)
            
            # CVaR ê³„ì‚°
            cvar = np.mean(returns_array[returns_array <= var])
            
            return abs(var), abs(cvar)
            
        except Exception as e:
            logger.error(f"VaR/CVaR ê³„ì‚° ì˜¤ë¥˜: {e}")
            return 0.0, 0.0
    
    def volatility_based_position_sizing(self, current_volatility: float, 
                                       target_volatility: float,
                                       current_position: float) -> float:
        """ë³€ë™ì„± ê¸°ë°˜ í¬ì§€ì…˜ í¬ê¸° ì¡°ì •"""
        try:
            # ë³€ë™ì„± ë¹„ìœ¨
            vol_ratio = current_volatility / target_volatility
            
            # í¬ì§€ì…˜ í¬ê¸° ì¡°ì •
            if vol_ratio > 1.5:  # ë³€ë™ì„± ë†’ìŒ
                adjustment = 0.5
            elif vol_ratio > 1.2:
                adjustment = 0.7
            elif vol_ratio < 0.5:  # ë³€ë™ì„± ë‚®ìŒ
                adjustment = 1.5
            elif vol_ratio < 0.8:
                adjustment = 1.2
            else:
                adjustment = 1.0
            
            new_position = current_position * adjustment
            
            return new_position
            
        except Exception as e:
            logger.error(f"ë³€ë™ì„± ê¸°ë°˜ í¬ì§€ì…˜ í¬ê¸° ì¡°ì • ì˜¤ë¥˜: {e}")
            return current_position
    
    def capital_limit_management(self, current_positions: Dict[str, float],
                               total_capital: float,
                               max_capital_usage: float = 0.8) -> Dict[str, float]:
        """ìë³¸ í•œë„ ê´€ë¦¬"""
        try:
            total_exposure = sum(current_positions.values())
            max_allowed_exposure = total_capital * max_capital_usage
            
            if total_exposure <= max_allowed_exposure:
                return current_positions
            
            # ë¹„ë¡€ì  ì¶•ì†Œ
            reduction_factor = max_allowed_exposure / total_exposure
            adjusted_positions = {}
            
            for asset, position in current_positions.items():
                adjusted_positions[asset] = position * reduction_factor
            
            return adjusted_positions
            
        except Exception as e:
            logger.error(f"ìë³¸ í•œë„ ê´€ë¦¬ ì˜¤ë¥˜: {e}")
            return current_positions
    
    def risk_scoring(self, portfolio_data: Dict[str, Dict]) -> float:
        """ë¦¬ìŠ¤í¬ ì ìˆ˜ ê³„ì‚°"""
        try:
            risk_score = 0.0
            
            # ë³€ë™ì„± ì ìˆ˜ (30%)
            volatilities = []
            for asset_data in portfolio_data.values():
                if 'returns' in asset_data:
                    vol = np.std(asset_data['returns'])
                    volatilities.append(vol)
            
            if volatilities:
                avg_volatility = np.mean(volatilities)
                volatility_score = min(1.0, avg_volatility * 10)  # 10% ê¸°ì¤€
                risk_score += volatility_score * 0.3
            
            # ìƒê´€ê´€ê³„ ì ìˆ˜ (25%)
            correlation_score = 0.0
            if len(portfolio_data) > 1:
                returns_data = {}
                for asset_id, data in portfolio_data.items():
                    if 'returns' in data:
                        returns_data[asset_id] = data['returns']
                
                if len(returns_data) > 1:
                    returns_df = pd.DataFrame(returns_data)
                    corr_matrix = returns_df.corr()
                    avg_correlation = (corr_matrix.sum().sum() - len(corr_matrix)) / (len(corr_matrix) ** 2 - len(corr_matrix))
                    correlation_score = max(0, avg_correlation)
                    risk_score += correlation_score * 0.25
            
            # ì§‘ì¤‘ë„ ì ìˆ˜ (25%)
            position_sizes = [data.get('position_size', 0) for data in portfolio_data.values()]
            if position_sizes:
                concentration = max(position_sizes) / sum(position_sizes) if sum(position_sizes) > 0 else 0
                concentration_score = concentration
                risk_score += concentration_score * 0.25
            
            # ìœ ë™ì„± ì ìˆ˜ (20%)
            liquidity_scores = []
            for data in portfolio_data.values():
                volume = data.get('volume', 0)
                price = data.get('price', 1)
                liquidity = volume * price if price > 0 else 0
                liquidity_score = 1 / (1 + liquidity / 1000000)  # 100ë§Œ ê¸°ì¤€
                liquidity_scores.append(liquidity_score)
            
            if liquidity_scores:
                avg_liquidity_score = np.mean(liquidity_scores)
                risk_score += avg_liquidity_score * 0.2
            
            return min(1.0, risk_score)
            
        except Exception as e:
            logger.error(f"ë¦¬ìŠ¤í¬ ì ìˆ˜ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return 0.5
    
    def dynamic_stop_loss(self, entry_price: float, 
                         current_price: float,
                         volatility: float,
                         atr: float) -> float:
        """ë™ì  ì†ì ˆê°€ ê³„ì‚°"""
        try:
            # ATR ê¸°ë°˜ ì†ì ˆê°€
            atr_stop = entry_price - (2 * atr)
            
            # ë³€ë™ì„± ê¸°ë°˜ ì†ì ˆê°€
            vol_stop = entry_price * (1 - volatility * 2)
            
            # ìµœëŒ€ ì†ì‹¤ í•œë„
            max_loss_stop = entry_price * 0.95  # 5% ìµœëŒ€ ì†ì‹¤
            
            # ê°€ì¥ ë³´ìˆ˜ì ì¸ ì†ì ˆê°€ ì„ íƒ
            stop_loss = max(atr_stop, vol_stop, max_loss_stop)
            
            return stop_loss
            
        except Exception as e:
            logger.error(f"ë™ì  ì†ì ˆê°€ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return entry_price * 0.95
```

---

**ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸**: 2025-01-26  
**í”„ë¡œì íŠ¸ ìƒíƒœ**: ì„¤ê³„ ì™„ë£Œ, ê°œë°œ ì¤€ë¹„  
**ë‹¤ìŒ ë‹¨ê³„**: ë‰´ìŠ¤ ì´ë²¤íŠ¸ ë¶„ì„ ì‹œìŠ¤í…œ êµ¬í˜„ 