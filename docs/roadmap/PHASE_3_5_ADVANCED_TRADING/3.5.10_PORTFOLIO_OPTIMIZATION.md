# π“ Phase 3.5.10: ν¬νΈν΄λ¦¬μ¤ μµμ ν™” μ‹μ¤ν…

## π― λ©ν‘
- **Modern Portfolio Theory**: λ§μ½”μ„μΈ  ν¬νΈν΄λ¦¬μ¤ μ΄λ΅  κΈ°λ° μµμ ν™”
- **Black-Litterman λ¨λΈ**: μ‹μ¥ κ· ν•κ³Ό ν¬μμ κ²¬ν•΄ κ²°ν•©
- **Risk Parity**: μ„ν— κΈ°λ° μμ‚° λ°°λ¶„
- **Dynamic Rebalancing**: λ™μ  ν¬νΈν΄λ¦¬μ¤ μ¬μ΅°μ •

## π“ μ„±λ¥ λ©ν‘
- **μµμ ν™” κ³„μ‚° μ†λ„**: < 5μ΄ (100κ° μμ‚°)
- **μ¬μ΅°μ • λΉλ„**: μΌμΌ μλ™ μ¬μ΅°μ •
- **μ„ν— κ΄€λ¦¬**: VaR < 2% (μΌκ°„)
- **μμµλ¥  λ©ν‘**: μ—°κ°„ 15-25%

## π—οΈ μ•„ν‚¤ν…μ²

```
advanced-trading/
β”β”€β”€ portfolio-optimization/
β”‚   β”β”€β”€ modern-portfolio-theory/
β”‚   β”‚   β”β”€β”€ efficient-frontier.py
β”‚   β”‚   β”β”€β”€ risk-return-optimizer.py
β”‚   β”‚   β””β”€β”€ portfolio-analyzer.py
β”‚   β”β”€β”€ black-litterman/
β”‚   β”‚   β”β”€β”€ market-equilibrium.py
β”‚   β”‚   β”β”€β”€ investor-views.py
β”‚   β”‚   β””β”€β”€ bl-optimizer.py
β”‚   β”β”€β”€ risk-parity/
β”‚   β”‚   β”β”€β”€ risk-contribution.py
β”‚   β”‚   β”β”€β”€ equal-risk-weighting.py
β”‚   β”‚   β””β”€β”€ risk-budgeting.py
β”‚   β”β”€β”€ dynamic-rebalancing/
β”‚   β”‚   β”β”€β”€ rebalancing-strategy.py
β”‚   β”‚   β”β”€β”€ threshold-manager.py
β”‚   β”‚   β””β”€β”€ cost-optimizer.py
β”‚   β””β”€β”€ performance-evaluation/
β”‚       β”β”€β”€ performance-metrics.py
β”‚       β”β”€β”€ attribution-analysis.py
β”‚       β””β”€β”€ benchmark-comparison.py
```

## π”§ ν•µμ‹¬ κµ¬μ„± μ”μ†

### 1. Modern Portfolio Theory

```python
import numpy as np
import pandas as pd
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass
from datetime import datetime, timedelta
import logging
from scipy.optimize import minimize
import cvxpy as cp

logger = logging.getLogger(__name__)

@dataclass
class PortfolioConfig:
    """ν¬νΈν΄λ¦¬μ¤ μ„¤μ •"""
    risk_free_rate: float = 0.02  # 2%
    target_return: float = 0.15   # 15%
    max_position_size: float = 0.2  # 20%
    min_position_size: float = 0.01  # 1%
    rebalancing_frequency: str = 'daily'
    transaction_cost: float = 0.001  # 0.1%

class ModernPortfolioTheory:
    """Modern Portfolio Theory κµ¬ν„"""
    
    def __init__(self, config: PortfolioConfig):
        self.config = config
        self.returns_data = None
        self.covariance_matrix = None
        self.expected_returns = None
    
    def calculate_efficient_frontier(self, returns_data: pd.DataFrame, 
                                   n_portfolios: int = 100) -> Dict[str, Any]:
        """ν¨μ¨μ  ν”„λ΅ ν‹°μ–΄ κ³„μ‚°"""
        try:
            self.returns_data = returns_data
            self._calculate_statistics()
            
            # λ‹¤μ–‘ν• λ©ν‘ μμµλ¥ μ— λ€ν• μµμ  ν¬νΈν΄λ¦¬μ¤ κ³„μ‚°
            target_returns = np.linspace(
                self.expected_returns.min(),
                self.expected_returns.max(),
                n_portfolios
            )
            
            efficient_portfolios = []
            
            for target_return in target_returns:
                try:
                    optimal_weights = self._optimize_portfolio(target_return)
                    portfolio_risk = self._calculate_portfolio_risk(optimal_weights)
                    portfolio_return = self._calculate_portfolio_return(optimal_weights)
                    
                    efficient_portfolios.append({
                        'weights': optimal_weights,
                        'expected_return': portfolio_return,
                        'risk': portfolio_risk,
                        'sharpe_ratio': (portfolio_return - self.config.risk_free_rate) / portfolio_risk
                    })
                except Exception as e:
                    logger.warning(f"Failed to optimize for target return {target_return}: {e}")
                    continue
            
            return {
                'efficient_frontier': efficient_portfolios,
                'min_variance_portfolio': self._find_minimum_variance_portfolio(),
                'tangency_portfolio': self._find_tangency_portfolio(),
                'statistics': {
                    'expected_returns': self.expected_returns.to_dict(),
                    'covariance_matrix': self.covariance_matrix.to_dict()
                }
            }
            
        except Exception as e:
            logger.error(f"Efficient frontier calculation failed: {e}")
            raise
    
    def _calculate_statistics(self):
        """ν†µκ³„ κ³„μ‚°"""
        # κΈ°λ€ μμµλ¥  κ³„μ‚° (κ³Όκ±° ν‰κ· )
        self.expected_returns = self.returns_data.mean() * 252  # μ—°κ°„ν™”
        
        # κ³µλ¶„μ‚° ν–‰λ ¬ κ³„μ‚°
        self.covariance_matrix = self.returns_data.cov() * 252  # μ—°κ°„ν™”
    
    def _optimize_portfolio(self, target_return: float) -> np.ndarray:
        """ν¬νΈν΄λ¦¬μ¤ μµμ ν™”"""
        n_assets = len(self.expected_returns)
        
        # μµμ ν™” λ³€μ (κ°€μ¤‘μΉ)
        weights = cp.Variable(n_assets)
        
        # λ©ν‘ ν•¨μ: μ„ν— μµμ†ν™”
        portfolio_risk = cp.quad_form(weights, self.covariance_matrix.values)
        
        # μ μ•½ μ΅°κ±΄
        constraints = [
            cp.sum(weights) == 1,  # κ°€μ¤‘μΉ ν•© = 1
            weights >= self.config.min_position_size,  # μµμ† ν¬μ§€μ…
            weights <= self.config.max_position_size,  # μµλ€ ν¬μ§€μ…
            self.expected_returns @ weights >= target_return  # λ©ν‘ μμµλ¥ 
        ]
        
        # μµμ ν™” λ¬Έμ 
        problem = cp.Problem(cp.Minimize(portfolio_risk), constraints)
        problem.solve()
        
        if problem.status == cp.OPTIMAL:
            return weights.value
        else:
            raise ValueError(f"Optimization failed: {problem.status}")
    
    def _calculate_portfolio_risk(self, weights: np.ndarray) -> float:
        """ν¬νΈν΄λ¦¬μ¤ μ„ν— κ³„μ‚°"""
        return np.sqrt(weights.T @ self.covariance_matrix.values @ weights)
    
    def _calculate_portfolio_return(self, weights: np.ndarray) -> float:
        """ν¬νΈν΄λ¦¬μ¤ μμµλ¥  κ³„μ‚°"""
        return weights.T @ self.expected_returns.values
    
    def _find_minimum_variance_portfolio(self) -> Dict[str, Any]:
        """μµμ† λ¶„μ‚° ν¬νΈν΄λ¦¬μ¤ μ°ΎκΈ°"""
        n_assets = len(self.expected_returns)
        weights = cp.Variable(n_assets)
        
        portfolio_risk = cp.quad_form(weights, self.covariance_matrix.values)
        
        constraints = [
            cp.sum(weights) == 1,
            weights >= self.config.min_position_size,
            weights <= self.config.max_position_size
        ]
        
        problem = cp.Problem(cp.Minimize(portfolio_risk), constraints)
        problem.solve()
        
        if problem.status == cp.OPTIMAL:
            optimal_weights = weights.value
            return {
                'weights': optimal_weights,
                'expected_return': self._calculate_portfolio_return(optimal_weights),
                'risk': self._calculate_portfolio_risk(optimal_weights)
            }
        else:
            raise ValueError("Minimum variance portfolio optimization failed")
    
    def _find_tangency_portfolio(self) -> Dict[str, Any]:
        """νƒ±μ  μ‹ ν¬νΈν΄λ¦¬μ¤ μ°ΎκΈ° (μµκ³  μƒ¤ν”„ λΉ„μ¨)"""
        n_assets = len(self.expected_returns)
        weights = cp.Variable(n_assets)
        
        portfolio_return = self.expected_returns @ weights
        portfolio_risk = cp.quad_form(weights, self.covariance_matrix.values)
        sharpe_ratio = (portfolio_return - self.config.risk_free_rate) / portfolio_risk
        
        constraints = [
            cp.sum(weights) == 1,
            weights >= self.config.min_position_size,
            weights <= self.config.max_position_size
        ]
        
        problem = cp.Problem(cp.Maximize(sharpe_ratio), constraints)
        problem.solve()
        
        if problem.status == cp.OPTIMAL:
            optimal_weights = weights.value
            return {
                'weights': optimal_weights,
                'expected_return': self._calculate_portfolio_return(optimal_weights),
                'risk': self._calculate_portfolio_risk(optimal_weights),
                'sharpe_ratio': (self._calculate_portfolio_return(optimal_weights) - self.config.risk_free_rate) / self._calculate_portfolio_risk(optimal_weights)
            }
        else:
            raise ValueError("Tangency portfolio optimization failed")

class RiskReturnOptimizer:
    """μ„ν—-μμµλ¥  μµμ ν™”"""
    
    def __init__(self, config: PortfolioConfig):
        self.config = config
        self.mpt = ModernPortfolioTheory(config)
    
    def optimize_for_target_risk(self, returns_data: pd.DataFrame, 
                               target_risk: float) -> Dict[str, Any]:
        """λ©ν‘ μ„ν—μ— λ€ν• μµμ ν™”"""
        try:
            self.mpt.returns_data = returns_data
            self.mpt._calculate_statistics()
            
            n_assets = len(self.mpt.expected_returns)
            weights = cp.Variable(n_assets)
            
            # λ©ν‘ ν•¨μ: μμµλ¥  μµλ€ν™”
            portfolio_return = self.mpt.expected_returns @ weights
            
            # μ μ•½ μ΅°κ±΄
            constraints = [
                cp.sum(weights) == 1,
                weights >= self.config.min_position_size,
                weights <= self.config.max_position_size,
                cp.quad_form(weights, self.mpt.covariance_matrix.values) <= target_risk**2
            ]
            
            problem = cp.Problem(cp.Maximize(portfolio_return), constraints)
            problem.solve()
            
            if problem.status == cp.OPTIMAL:
                optimal_weights = weights.value
                return {
                    'weights': optimal_weights,
                    'expected_return': self.mpt._calculate_portfolio_return(optimal_weights),
                    'risk': self.mpt._calculate_portfolio_risk(optimal_weights),
                    'sharpe_ratio': (self.mpt._calculate_portfolio_return(optimal_weights) - self.config.risk_free_rate) / self.mpt._calculate_portfolio_risk(optimal_weights)
                }
            else:
                raise ValueError(f"Risk optimization failed: {problem.status}")
                
        except Exception as e:
            logger.error(f"Risk optimization failed: {e}")
            raise
    
    def optimize_for_target_return(self, returns_data: pd.DataFrame, 
                                 target_return: float) -> Dict[str, Any]:
        """λ©ν‘ μμµλ¥ μ— λ€ν• μµμ ν™”"""
        try:
            self.mpt.returns_data = returns_data
            self.mpt._calculate_statistics()
            
            optimal_weights = self.mpt._optimize_portfolio(target_return)
            
            return {
                'weights': optimal_weights,
                'expected_return': self.mpt._calculate_portfolio_return(optimal_weights),
                'risk': self.mpt._calculate_portfolio_risk(optimal_weights),
                'sharpe_ratio': (self.mpt._calculate_portfolio_return(optimal_weights) - self.config.risk_free_rate) / self.mpt._calculate_portfolio_risk(optimal_weights)
            }
            
        except Exception as e:
            logger.error(f"Return optimization failed: {e}")
            raise
```

### 2. Black-Litterman λ¨λΈ

```python
class BlackLittermanModel:
    """Black-Litterman λ¨λΈ"""
    
    def __init__(self, config: PortfolioConfig):
        self.config = config
        self.market_cap_weights = None
        self.risk_aversion = 2.5
        self.tau = 0.05  # λ¶ν™•μ‹¤μ„± νλΌλ―Έν„°
    
    def set_market_cap_weights(self, market_caps: Dict[str, float]):
        """μ‹κ°€μ΄μ•΅ κ°€μ¤‘μΉ μ„¤μ •"""
        total_market_cap = sum(market_caps.values())
        self.market_cap_weights = np.array([market_caps[asset] / total_market_cap for asset in market_caps.keys()])
    
    def calculate_market_equilibrium_returns(self, covariance_matrix: pd.DataFrame) -> np.ndarray:
        """μ‹μ¥ κ· ν• μμµλ¥  κ³„μ‚°"""
        if self.market_cap_weights is None:
            raise ValueError("Market cap weights not set")
        
        # μ‹μ¥ κ· ν• μμµλ¥  = risk_aversion * covariance_matrix * market_cap_weights
        equilibrium_returns = self.risk_aversion * covariance_matrix.values @ self.market_cap_weights
        
        return equilibrium_returns
    
    def add_investor_views(self, views: List[Dict[str, Any]]) -> Tuple[np.ndarray, np.ndarray]:
        """ν¬μμ κ²¬ν•΄ μ¶”κ°€"""
        n_assets = len(self.market_cap_weights)
        n_views = len(views)
        
        # κ²¬ν•΄ ν–‰λ ¬ Pμ™€ κ²¬ν•΄ λ²΅ν„° Q μƒμ„±
        P = np.zeros((n_views, n_assets))
        Q = np.zeros(n_views)
        
        for i, view in enumerate(views):
            # κ²¬ν•΄ ν•μ‹: {'assets': ['asset1', 'asset2'], 'weights': [0.5, -0.5], 'return': 0.05}
            assets = view['assets']
            weights = view['weights']
            expected_return = view['return']
            
            # P ν–‰λ ¬ κµ¬μ„±
            for j, asset in enumerate(assets):
                asset_index = list(self.market_cap_weights.index).index(asset)
                P[i, asset_index] = weights[j]
            
            Q[i] = expected_return
        
        return P, Q
    
    def calculate_black_litterman_returns(self, covariance_matrix: pd.DataFrame, 
                                        views: List[Dict[str, Any]], 
                                        view_confidences: List[float]) -> np.ndarray:
        """Black-Litterman μμµλ¥  κ³„μ‚°"""
        # μ‹μ¥ κ· ν• μμµλ¥ 
        pi = self.calculate_market_equilibrium_returns(covariance_matrix)
        
        # ν¬μμ κ²¬ν•΄
        P, Q = self.add_investor_views(views)
        
        # κ²¬ν•΄ λ¶ν™•μ‹¤μ„± ν–‰λ ¬ Omega
        Omega = np.diag([1/conf for conf in view_confidences])
        
        # Black-Litterman μμµλ¥  κ³„μ‚°
        tau_sigma = self.tau * covariance_matrix.values
        M1 = np.linalg.inv(tau_sigma)
        M2 = P.T @ np.linalg.inv(Omega) @ P
        M3 = np.linalg.inv(tau_sigma) @ pi
        M4 = P.T @ np.linalg.inv(Omega) @ Q
        
        bl_returns = np.linalg.inv(M1 + M2) @ (M3 + M4)
        
        return bl_returns
    
    def optimize_black_litterman_portfolio(self, returns_data: pd.DataFrame, 
                                         views: List[Dict[str, Any]], 
                                         view_confidences: List[float]) -> Dict[str, Any]:
        """Black-Litterman ν¬νΈν΄λ¦¬μ¤ μµμ ν™”"""
        try:
            # ν†µκ³„ κ³„μ‚°
            covariance_matrix = returns_data.cov() * 252
            
            # Black-Litterman μμµλ¥  κ³„μ‚°
            bl_returns = self.calculate_black_litterman_returns(
                covariance_matrix, views, view_confidences
            )
            
            # μµμ ν™”
            n_assets = len(bl_returns)
            weights = cp.Variable(n_assets)
            
            # λ©ν‘ ν•¨μ: μμµλ¥  μµλ€ν™”
            portfolio_return = bl_returns @ weights
            
            # μ μ•½ μ΅°κ±΄
            constraints = [
                cp.sum(weights) == 1,
                weights >= self.config.min_position_size,
                weights <= self.config.max_position_size
            ]
            
            problem = cp.Problem(cp.Maximize(portfolio_return), constraints)
            problem.solve()
            
            if problem.status == cp.OPTIMAL:
                optimal_weights = weights.value
                portfolio_risk = np.sqrt(optimal_weights.T @ covariance_matrix.values @ optimal_weights)
                
                return {
                    'weights': optimal_weights,
                    'expected_return': portfolio_return.value,
                    'risk': portfolio_risk,
                    'sharpe_ratio': (portfolio_return.value - self.config.risk_free_rate) / portfolio_risk,
                    'black_litterman_returns': bl_returns
                }
            else:
                raise ValueError(f"Black-Litterman optimization failed: {problem.status}")
                
        except Exception as e:
            logger.error(f"Black-Litterman optimization failed: {e}")
            raise
```

### 3. Risk Parity

```python
class RiskParityOptimizer:
    """Risk Parity μµμ ν™”"""
    
    def __init__(self, config: PortfolioConfig):
        self.config = config
    
    def calculate_risk_parity_weights(self, returns_data: pd.DataFrame) -> Dict[str, Any]:
        """Risk Parity κ°€μ¤‘μΉ κ³„μ‚°"""
        try:
            # κ³µλ¶„μ‚° ν–‰λ ¬ κ³„μ‚°
            covariance_matrix = returns_data.cov() * 252
            
            n_assets = len(returns_data.columns)
            
            # μµμ ν™” λ³€μ
            weights = cp.Variable(n_assets)
            
            # λ©ν‘ ν•¨μ: μ„ν— κΈ°μ—¬λ„μ λ¶„μ‚° μµμ†ν™”
            portfolio_risk = cp.quad_form(weights, covariance_matrix.values)
            
            # κ° μμ‚°μ μ„ν— κΈ°μ—¬λ„
            risk_contributions = []
            for i in range(n_assets):
                risk_contrib = weights[i] * (covariance_matrix.values[i, :] @ weights)
                risk_contributions.append(risk_contrib)
            
            # μ„ν— κΈ°μ—¬λ„μ λ¶„μ‚°
            risk_contrib_var = cp.sum_squares(cp.hstack(risk_contributions) - portfolio_risk / n_assets)
            
            # μ μ•½ μ΅°κ±΄
            constraints = [
                cp.sum(weights) == 1,
                weights >= self.config.min_position_size,
                weights <= self.config.max_position_size
            ]
            
            # μµμ ν™” λ¬Έμ 
            problem = cp.Problem(cp.Minimize(risk_contrib_var), constraints)
            problem.solve()
            
            if problem.status == cp.OPTIMAL:
                optimal_weights = weights.value
                
                # μ„ν— κΈ°μ—¬λ„ κ³„μ‚°
                actual_risk_contributions = []
                for i in range(n_assets):
                    risk_contrib = optimal_weights[i] * (covariance_matrix.values[i, :] @ optimal_weights)
                    actual_risk_contributions.append(risk_contrib)
                
                return {
                    'weights': optimal_weights,
                    'risk_contributions': actual_risk_contributions,
                    'portfolio_risk': np.sqrt(optimal_weights.T @ covariance_matrix.values @ optimal_weights),
                    'risk_parity_score': np.std(actual_risk_contributions)  # λ‚®μ„μλ΅ μΆ‹μ
                }
            else:
                raise ValueError(f"Risk parity optimization failed: {problem.status}")
                
        except Exception as e:
            logger.error(f"Risk parity optimization failed: {e}")
            raise
    
    def calculate_equal_risk_contribution(self, returns_data: pd.DataFrame) -> Dict[str, Any]:
        """λ™μΌ μ„ν— κΈ°μ—¬λ„ κ³„μ‚°"""
        try:
            covariance_matrix = returns_data.cov() * 252
            n_assets = len(returns_data.columns)
            
            # λ©ν‘ μ„ν— κΈ°μ—¬λ„ (λ¨λ“  μμ‚°μ΄ λ™μΌ)
            target_risk_contrib = 1.0 / n_assets
            
            # λ°λ³µμ  μµμ ν™”
            weights = np.ones(n_assets) / n_assets  # μ΄κΈ°κ°’: λ™μΌ κ°€μ¤‘μΉ
            
            max_iterations = 100
            tolerance = 1e-6
            
            for iteration in range(max_iterations):
                old_weights = weights.copy()
                
                # κ° μμ‚°μ μ„ν— κΈ°μ—¬λ„ κ³„μ‚°
                portfolio_risk = np.sqrt(weights.T @ covariance_matrix.values @ weights)
                risk_contributions = []
                
                for i in range(n_assets):
                    risk_contrib = weights[i] * (covariance_matrix.values[i, :] @ weights) / portfolio_risk
                    risk_contributions.append(risk_contrib)
                
                # κ°€μ¤‘μΉ μ΅°μ •
                for i in range(n_assets):
                    if risk_contributions[i] > 0:
                        weights[i] *= target_risk_contrib / risk_contributions[i]
                
                # μ •κ·ν™”
                weights = weights / np.sum(weights)
                
                # μλ ΄ ν™•μΈ
                if np.max(np.abs(weights - old_weights)) < tolerance:
                    break
            
            # μµμΆ… μ„ν— κΈ°μ—¬λ„ κ³„μ‚°
            portfolio_risk = np.sqrt(weights.T @ covariance_matrix.values @ weights)
            final_risk_contributions = []
            
            for i in range(n_assets):
                risk_contrib = weights[i] * (covariance_matrix.values[i, :] @ weights) / portfolio_risk
                final_risk_contributions.append(risk_contrib)
            
            return {
                'weights': weights,
                'risk_contributions': final_risk_contributions,
                'portfolio_risk': portfolio_risk,
                'iterations': iteration + 1,
                'converged': iteration < max_iterations - 1
            }
            
        except Exception as e:
            logger.error(f"Equal risk contribution calculation failed: {e}")
            raise
```

### 4. Dynamic Rebalancing

```python
class DynamicRebalancing:
    """λ™μ  μ¬μ΅°μ •"""
    
    def __init__(self, config: PortfolioConfig):
        self.config = config
        self.rebalancing_threshold = 0.05  # 5%
        self.rebalancing_history = []
    
    def check_rebalancing_needs(self, current_weights: Dict[str, float], 
                              target_weights: Dict[str, float]) -> Dict[str, Any]:
        """μ¬μ΅°μ • ν•„μ”μ„± ν™•μΈ"""
        rebalancing_needs = {
            'needs_rebalancing': False,
            'deviations': {},
            'total_deviation': 0.0,
            'assets_to_rebalance': []
        }
        
        total_deviation = 0.0
        
        for asset in current_weights.keys():
            if asset in target_weights:
                current_weight = current_weights[asset]
                target_weight = target_weights[asset]
                deviation = abs(current_weight - target_weight)
                
                rebalancing_needs['deviations'][asset] = {
                    'current': current_weight,
                    'target': target_weight,
                    'deviation': deviation,
                    'exceeds_threshold': deviation > self.rebalancing_threshold
                }
                
                total_deviation += deviation
                
                if deviation > self.rebalancing_threshold:
                    rebalancing_needs['assets_to_rebalance'].append(asset)
        
        rebalancing_needs['total_deviation'] = total_deviation
        rebalancing_needs['needs_rebalancing'] = total_deviation > self.rebalancing_threshold * len(current_weights)
        
        return rebalancing_needs
    
    def calculate_rebalancing_trades(self, current_weights: Dict[str, float], 
                                   target_weights: Dict[str, float], 
                                   portfolio_value: float) -> Dict[str, Any]:
        """μ¬μ΅°μ • κ±°λ κ³„μ‚°"""
        trades = {
            'trades': {},
            'total_cost': 0.0,
            'estimated_slippage': 0.0
        }
        
        for asset in target_weights.keys():
            if asset in current_weights:
                current_value = current_weights[asset] * portfolio_value
                target_value = target_weights[asset] * portfolio_value
                trade_value = target_value - current_value
                
                if abs(trade_value) > portfolio_value * 0.001:  # 0.1% μ΄μƒ
                    trades['trades'][asset] = {
                        'current_value': current_value,
                        'target_value': target_value,
                        'trade_value': trade_value,
                        'trade_type': 'buy' if trade_value > 0 else 'sell',
                        'trade_size': abs(trade_value)
                    }
                    
                    # κ±°λ λΉ„μ© κ³„μ‚°
                    trade_cost = abs(trade_value) * self.config.transaction_cost
                    trades['total_cost'] += trade_cost
                    
                    # μ¬λ¦¬ν”Όμ§€ μ¶”μ • (κ±°λ κ·λ¨μ— λΉ„λ΅€)
                    slippage = abs(trade_value) * 0.0001  # 0.01% μ¬λ¦¬ν”Όμ§€
                    trades['estimated_slippage'] += slippage
        
        return trades
    
    def optimize_rebalancing_cost(self, current_weights: Dict[str, float], 
                                target_weights: Dict[str, float], 
                                portfolio_value: float) -> Dict[str, Any]:
        """μ¬μ΅°μ • λΉ„μ© μµμ ν™”"""
        try:
            # κ±°λ λΉ„μ©μ„ κ³ λ ¤ν• μµμ ν™”
            assets = list(target_weights.keys())
            n_assets = len(assets)
            
            # μµμ ν™” λ³€μ: μƒλ΅μ΄ κ°€μ¤‘μΉ
            new_weights = cp.Variable(n_assets)
            
            # λ©ν‘ ν•¨μ: κ±°λ λΉ„μ© μµμ†ν™”
            trade_costs = 0
            for i, asset in enumerate(assets):
                current_weight = current_weights.get(asset, 0)
                trade_size = cp.abs(new_weights[i] - current_weight) * portfolio_value
                trade_costs += trade_size * self.config.transaction_cost
            
            # μ μ•½ μ΅°κ±΄
            constraints = [
                cp.sum(new_weights) == 1,
                new_weights >= self.config.min_position_size,
                new_weights <= self.config.max_position_size
            ]
            
            # λ©ν‘ κ°€μ¤‘μΉμ™€μ νΈμ°¨ μ ν•
            for i, asset in enumerate(assets):
                target_weight = target_weights[asset]
                constraints.append(cp.abs(new_weights[i] - target_weight) <= 0.02)  # 2% νΈμ°¨ ν—μ©
            
            problem = cp.Problem(cp.Minimize(trade_costs), constraints)
            problem.solve()
            
            if problem.status == cp.OPTIMAL:
                optimized_weights = new_weights.value
                
                # μµμ ν™”λ κ±°λ κ³„μ‚°
                optimized_trades = {}
                total_cost = 0
                
                for i, asset in enumerate(assets):
                    current_weight = current_weights.get(asset, 0)
                    optimized_weight = optimized_weights[i]
                    trade_value = (optimized_weight - current_weight) * portfolio_value
                    
                    if abs(trade_value) > portfolio_value * 0.001:
                        optimized_trades[asset] = {
                            'current_weight': current_weight,
                            'optimized_weight': optimized_weight,
                            'trade_value': trade_value,
                            'trade_cost': abs(trade_value) * self.config.transaction_cost
                        }
                        total_cost += abs(trade_value) * self.config.transaction_cost
                
                return {
                    'optimized_weights': dict(zip(assets, optimized_weights)),
                    'optimized_trades': optimized_trades,
                    'total_cost': total_cost,
                    'cost_savings': self._calculate_cost_savings(current_weights, target_weights, optimized_weights, portfolio_value)
                }
            else:
                raise ValueError(f"Cost optimization failed: {problem.status}")
                
        except Exception as e:
            logger.error(f"Cost optimization failed: {e}")
            raise
    
    def _calculate_cost_savings(self, current_weights: Dict[str, float], 
                              target_weights: Dict[str, float], 
                              optimized_weights: np.ndarray, 
                              portfolio_value: float) -> float:
        """λΉ„μ© μ μ•½ κ³„μ‚°"""
        # μ§μ ‘ μ¬μ΅°μ • λΉ„μ©
        direct_cost = 0
        for asset in target_weights.keys():
            if asset in current_weights:
                trade_value = abs(target_weights[asset] - current_weights[asset]) * portfolio_value
                direct_cost += trade_value * self.config.transaction_cost
        
        # μµμ ν™”λ μ¬μ΅°μ • λΉ„μ©
        optimized_cost = 0
        assets = list(target_weights.keys())
        for i, asset in enumerate(assets):
            if asset in current_weights:
                trade_value = abs(optimized_weights[i] - current_weights[asset]) * portfolio_value
                optimized_cost += trade_value * self.config.transaction_cost
        
        return direct_cost - optimized_cost
    
    def execute_rebalancing(self, trades: Dict[str, Any], 
                          portfolio_value: float) -> Dict[str, Any]:
        """μ¬μ΅°μ • μ‹¤ν–‰"""
        execution_result = {
            'executed_trades': {},
            'execution_costs': 0.0,
            'actual_slippage': 0.0,
            'execution_time': datetime.now()
        }
        
        for asset, trade_info in trades['trades'].items():
            try:
                # μ‹¤μ  κ±°λ μ‹¤ν–‰ (μ‹λ®¬λ μ΄μ…)
                trade_value = trade_info['trade_value']
                execution_cost = abs(trade_value) * self.config.transaction_cost
                
                # μ¬λ¦¬ν”Όμ§€ μ‹λ®¬λ μ΄μ…
                slippage = abs(trade_value) * 0.0001  # 0.01%
                
                execution_result['executed_trades'][asset] = {
                    'trade_value': trade_value,
                    'execution_cost': execution_cost,
                    'slippage': slippage,
                    'status': 'executed'
                }
                
                execution_result['execution_costs'] += execution_cost
                execution_result['actual_slippage'] += slippage
                
            except Exception as e:
                logger.error(f"Trade execution failed for {asset}: {e}")
                execution_result['executed_trades'][asset] = {
                    'status': 'failed',
                    'error': str(e)
                }
        
        # μ¬μ΅°μ • νμ¤ν† λ¦¬ κΈ°λ΅
        self.rebalancing_history.append({
            'timestamp': execution_result['execution_time'],
            'portfolio_value': portfolio_value,
            'execution_result': execution_result
        })
        
        return execution_result
```

## π“ μ„±κ³Ό μ§€ν‘

### ν¬νΈν΄λ¦¬μ¤ μµμ ν™” μ„±κ³Ό
- **μƒ¤ν”„ λΉ„μ¨**: > 1.5
- **μµλ€ λ‚™ν­**: < 15%
- **μμµλ¥  λ©ν‘ λ‹¬μ„±**: > 80%
- **μ„ν— κ΄€λ¦¬**: VaR < 2%

### μ¬μ΅°μ • μ„±κ³Ό
- **μ¬μ΅°μ • λΉλ„**: μ›” 1-2ν
- **κ±°λ λΉ„μ©**: < 0.5% (μ—°κ°„)
- **μ¬λ¦¬ν”Όμ§€**: < 0.1% (κ±°λλ‹Ή)
- **μ¬μ΅°μ • μ •ν™•λ„**: > 95%

### μ„ν— κ΄€λ¦¬ μ„±κ³Ό
- **μ„ν— κΈ°μ—¬λ„ κ· λ“±ν™”**: ν‘μ¤€νΈμ°¨ < 5%
- **ν¬νΈν΄λ¦¬μ¤ λ³€λ™μ„±**: λ©ν‘ Β±10%
- **μƒκ΄€κ΄€κ³„ κ΄€λ¦¬**: ν‰κ·  μƒκ΄€κ΄€κ³„ < 0.3
- **λ¶„μ‚° ν¨κ³Ό**: > 70%

## π”„ κ°λ° λ΅λ“λ§µ

### 1λ‹¨κ³„: Modern Portfolio Theory (2025-11-01 ~ 2025-11-15)
- [x] ν¨μ¨μ  ν”„λ΅ ν‹°μ–΄ κ³„μ‚°
- [x] μ„ν—-μμµλ¥  μµμ ν™”
- [ ] ν¬νΈν΄λ¦¬μ¤ λ¶„μ„κΈ°
- [ ] λ°±ν…μ¤ν… μ‹μ¤ν…

### 2λ‹¨κ³„: Black-Litterman λ¨λΈ (2025-11-16 ~ 2025-11-30)
- [x] μ‹μ¥ κ· ν• κ³„μ‚°
- [x] ν¬μμ κ²¬ν•΄ ν†µν•©
- [x] Black-Litterman μµμ ν™”
- [ ] κ²¬ν•΄ λ¶ν™•μ‹¤μ„± κ΄€λ¦¬

### 3λ‹¨κ³„: Risk Parity (2025-12-01 ~ 2025-12-15)
- [x] μ„ν— κΈ°μ—¬λ„ κ³„μ‚°
- [x] λ™μΌ μ„ν— κ°€μ¤‘μΉ
- [x] μ„ν— μμ‚° κ΄€λ¦¬
- [ ] λ™μ  μ„ν— μ΅°μ •

### 4λ‹¨κ³„: λ™μ  μ¬μ΅°μ • (2025-12-16 ~ 2025-12-31)
- [x] μ¬μ΅°μ • ν•„μ”μ„± ν™•μΈ
- [x] κ±°λ λΉ„μ© μµμ ν™”
- [x] μ¬μ΅°μ • μ‹¤ν–‰
- [ ] μ„±κ³Ό λ¨λ‹ν„°λ§

### 5λ‹¨κ³„: ν†µν•© λ° μµμ ν™” (2026-01-01 ~ 2026-01-15)
- [ ] λ¨λ“  λ¨λ“ ν†µν•©
- [ ] μ„±λ¥ μµμ ν™”
- [ ] μ‚¬μ©μ μΈν„°νμ΄μ¤
- [ ] λ¬Έμ„ν™” μ™„λ£

## π”— κ΄€λ ¨ λ¬Έμ„
- [κ³ κΈ‰ μ„ν— κ΄€λ¦¬](3.5.7_ADVANCED_RISK_MANAGEMENT.md)
- [μ‹μ¥ λ§μ΄ν¬λ΅κµ¬μ΅°](3.5.11_MARKET_MICROSTRUCTURE.md)
- [μ‹¤ν–‰ μµμ ν™”](3.5.12_EXECUTION_OPTIMIZATION.md) 