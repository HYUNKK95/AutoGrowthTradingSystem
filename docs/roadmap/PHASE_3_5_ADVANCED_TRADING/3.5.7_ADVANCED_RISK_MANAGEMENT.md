# 🛡️ Phase 3.5.7: 고급 위험 관리 시스템

## 🎯 목표
- **VaR/CVaR 계산**: 포트폴리오 위험 측정 및 관리
- **포지션 한도 관리**: 개별 자산 및 전체 포트폴리오 한도 설정
- **변동성 기반 포지션 크기 조정**: 시장 변동성에 따른 동적 조정
- **최대 손실 한도**: 절대적 손실 한도 및 회복 메커니즘

## 📊 성능 목표
- **VaR 계산 속도**: < 1초 (실시간)
- **리스크 모니터링**: < 100ms (지연 시간)
- **포지션 조정**: < 500ms (자동 조정)
- **알림 발송**: < 50ms (위험 임계값 초과 시)

## 🏗️ 아키텍처

```
advanced-trading/
├── risk-management-advanced/
│   ├── risk-calculator/
│   │   ├── var-cvar-calculator.py
│   │   ├── stress-testing.py
│   │   └── scenario-analysis.py
│   ├── position-manager/
│   │   ├── position-limits.py
│   │   ├── volatility-sizing.py
│   │   └── dynamic-adjustment.py
│   ├── loss-control/
│   │   ├── stop-loss-manager.py
│   │   ├── drawdown-control.py
│   │   └── recovery-mechanism.py
│   ├── portfolio-risk/
│   │   ├── correlation-analysis.py
│   │   ├── concentration-risk.py
│   │   └── sector-exposure.py
│   └── monitoring/
│       ├── real-time-monitor.py
│       ├── alert-system.py
│       └── risk-dashboard.py
```

## 🔧 핵심 구성 요소

### 1. VaR/CVaR 계산기

```python
import numpy as np
import pandas as pd
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass
from datetime import datetime, timedelta
import logging
from scipy import stats
from scipy.optimize import minimize

logger = logging.getLogger(__name__)

@dataclass
class RiskConfig:
    """위험 관리 설정"""
    confidence_level: float = 0.95
    time_horizon: int = 1  # 일
    var_method: str = 'historical'  # historical, parametric, monte_carlo
    lookback_period: int = 252  # 1년
    max_position_size: float = 0.1  # 10%
    max_portfolio_risk: float = 0.02  # 2%
    volatility_lookback: int = 30  # 30일

class VaRCVaRCalculator:
    """VaR/CVaR 계산기"""
    
    def __init__(self, config: RiskConfig):
        self.config = config
        self.portfolio_data = {}
        self.risk_metrics = {}
    
    def calculate_portfolio_var(self, portfolio: Dict[str, float], 
                              returns_data: pd.DataFrame) -> Dict[str, float]:
        """포트폴리오 VaR 계산"""
        try:
            # 포트폴리오 수익률 계산
            portfolio_returns = self._calculate_portfolio_returns(portfolio, returns_data)
            
            # VaR 계산
            var_value = self._calculate_var(portfolio_returns)
            
            # CVaR 계산
            cvar_value = self._calculate_cvar(portfolio_returns, var_value)
            
            # 추가 위험 지표
            risk_metrics = self._calculate_additional_risk_metrics(portfolio_returns)
            
            result = {
                'var': var_value,
                'cvar': cvar_value,
                'volatility': risk_metrics['volatility'],
                'skewness': risk_metrics['skewness'],
                'kurtosis': risk_metrics['kurtosis'],
                'max_drawdown': risk_metrics['max_drawdown'],
                'confidence_level': self.config.confidence_level,
                'time_horizon': self.config.time_horizon
            }
            
            logger.info(f"포트폴리오 VaR 계산 완료: VaR={var_value:.4f}, CVaR={cvar_value:.4f}")
            return result
            
        except Exception as e:
            logger.error(f"VaR 계산 중 오류 발생: {e}")
            raise
    
    def _calculate_portfolio_returns(self, portfolio: Dict[str, float], 
                                   returns_data: pd.DataFrame) -> pd.Series:
        """포트폴리오 수익률 계산"""
        portfolio_returns = pd.Series(0.0, index=returns_data.index)
        
        for asset, weight in portfolio.items():
            if asset in returns_data.columns:
                asset_returns = returns_data[asset].fillna(0)
                portfolio_returns += weight * asset_returns
        
        return portfolio_returns
    
    def _calculate_var(self, returns: pd.Series) -> float:
        """VaR 계산"""
        if self.config.var_method == 'historical':
            return self._historical_var(returns)
        elif self.config.var_method == 'parametric':
            return self._parametric_var(returns)
        elif self.config.var_method == 'monte_carlo':
            return self._monte_carlo_var(returns)
        else:
            raise ValueError(f"지원하지 않는 VaR 방법: {self.config.var_method}")
    
    def _historical_var(self, returns: pd.Series) -> float:
        """히스토리컬 VaR"""
        # 최근 데이터만 사용
        recent_returns = returns.tail(self.config.lookback_period)
        
        # 백분위수 계산
        var_percentile = (1 - self.config.confidence_level) * 100
        var_value = np.percentile(recent_returns, var_percentile)
        
        return abs(var_value)
    
    def _parametric_var(self, returns: pd.Series) -> float:
        """파라미트릭 VaR (정규분포 가정)"""
        # 최근 데이터만 사용
        recent_returns = returns.tail(self.config.lookback_period)
        
        # 평균과 표준편차 계산
        mean_return = recent_returns.mean()
        std_return = recent_returns.std()
        
        # 정규분포 가정 하에서 VaR 계산
        z_score = stats.norm.ppf(1 - self.config.confidence_level)
        var_value = mean_return - z_score * std_return
        
        return abs(var_value)
    
    def _monte_carlo_var(self, returns: pd.Series, n_simulations: int = 10000) -> float:
        """몬테카를로 VaR"""
        # 최근 데이터만 사용
        recent_returns = returns.tail(self.config.lookback_period)
        
        # 부트스트랩 샘플링
        simulated_returns = np.random.choice(
            recent_returns, 
            size=n_simulations, 
            replace=True
        )
        
        # 백분위수 계산
        var_percentile = (1 - self.config.confidence_level) * 100
        var_value = np.percentile(simulated_returns, var_percentile)
        
        return abs(var_value)
    
    def _calculate_cvar(self, returns: pd.Series, var_value: float) -> float:
        """CVaR (Expected Shortfall) 계산"""
        # VaR보다 큰 손실들의 평균
        tail_returns = returns[returns <= -var_value]
        
        if len(tail_returns) == 0:
            return var_value
        
        cvar_value = abs(tail_returns.mean())
        return cvar_value
    
    def _calculate_additional_risk_metrics(self, returns: pd.Series) -> Dict[str, float]:
        """추가 위험 지표 계산"""
        # 변동성
        volatility = returns.std() * np.sqrt(252)
        
        # 왜도
        skewness = returns.skew()
        
        # 첨도
        kurtosis = returns.kurtosis()
        
        # 최대 낙폭
        cumulative_returns = (1 + returns).cumprod()
        running_max = cumulative_returns.expanding().max()
        drawdown = (cumulative_returns - running_max) / running_max
        max_drawdown = abs(drawdown.min())
        
        return {
            'volatility': volatility,
            'skewness': skewness,
            'kurtosis': kurtosis,
            'max_drawdown': max_drawdown
        }
    
    def stress_test_portfolio(self, portfolio: Dict[str, float], 
                            returns_data: pd.DataFrame) -> Dict[str, Any]:
        """포트폴리오 스트레스 테스트"""
        stress_scenarios = {
            'market_crash': self._market_crash_scenario,
            'volatility_spike': self._volatility_spike_scenario,
            'correlation_breakdown': self._correlation_breakdown_scenario,
            'liquidity_crisis': self._liquidity_crisis_scenario
        }
        
        stress_results = {}
        
        for scenario_name, scenario_func in stress_scenarios.items():
            logger.info(f"스트레스 테스트 실행: {scenario_name}")
            
            # 스트레스 시나리오 적용
            stressed_returns = scenario_func(returns_data)
            
            # 스트레스 하에서 VaR 계산
            stressed_var = self._calculate_var(stressed_returns)
            stressed_cvar = self._calculate_cvar(stressed_returns, stressed_var)
            
            stress_results[scenario_name] = {
                'var': stressed_var,
                'cvar': stressed_cvar,
                'var_increase': stressed_var / self._calculate_var(returns_data) - 1,
                'cvar_increase': stressed_cvar / self._calculate_cvar(returns_data, self._calculate_var(returns_data)) - 1
            }
        
        return stress_results
    
    def _market_crash_scenario(self, returns_data: pd.DataFrame) -> pd.Series:
        """시장 폭락 시나리오"""
        portfolio_returns = returns_data.mean(axis=1)
        
        # 시장 폭락 효과: 수익률 -20%, 변동성 3배
        crash_returns = portfolio_returns * 3 - 0.20 / 252
        
        return crash_returns
    
    def _volatility_spike_scenario(self, returns_data: pd.DataFrame) -> pd.Series:
        """변동성 급증 시나리오"""
        portfolio_returns = returns_data.mean(axis=1)
        
        # 변동성 급증 효과: 변동성 4배
        spike_returns = portfolio_returns * 4
        
        return spike_returns
    
    def _correlation_breakdown_scenario(self, returns_data: pd.DataFrame) -> pd.Series:
        """상관관계 붕괴 시나리오"""
        portfolio_returns = returns_data.mean(axis=1)
        
        # 상관관계 붕괴 효과: 다각화 효과 감소
        breakdown_returns = portfolio_returns * 2
        
        return breakdown_returns
    
    def _liquidity_crisis_scenario(self, returns_data: pd.DataFrame) -> pd.Series:
        """유동성 위기 시나리오"""
        portfolio_returns = returns_data.mean(axis=1)
        
        # 유동성 위기 효과: 추가 손실 5%
        crisis_returns = portfolio_returns - 0.05 / 252
        
        return crisis_returns
```

### 2. 포지션 한도 관리자

```python
class PositionLimitManager:
    """포지션 한도 관리자"""
    
    def __init__(self, config: RiskConfig):
        self.config = config
        self.position_limits = {}
        self.current_positions = {}
        self.limit_violations = []
    
    def set_position_limits(self, limits: Dict[str, Dict[str, float]]):
        """포지션 한도 설정"""
        for asset, limit_config in limits.items():
            self.position_limits[asset] = {
                'max_weight': limit_config.get('max_weight', 0.1),
                'max_notional': limit_config.get('max_notional', 1000000),
                'max_risk_contribution': limit_config.get('max_risk_contribution', 0.02),
                'concentration_limit': limit_config.get('concentration_limit', 0.2)
            }
    
    def check_position_limits(self, portfolio: Dict[str, float], 
                            portfolio_value: float) -> Dict[str, Any]:
        """포지션 한도 검사"""
        violations = []
        warnings = []
        
        for asset, weight in portfolio.items():
            if asset in self.position_limits:
                limit = self.position_limits[asset]
                
                # 가중치 한도 검사
                if weight > limit['max_weight']:
                    violations.append({
                        'asset': asset,
                        'type': 'weight_limit',
                        'current': weight,
                        'limit': limit['max_weight'],
                        'excess': weight - limit['max_weight']
                    })
                
                # 명목가치 한도 검사
                notional_value = weight * portfolio_value
                if notional_value > limit['max_notional']:
                    violations.append({
                        'asset': asset,
                        'type': 'notional_limit',
                        'current': notional_value,
                        'limit': limit['max_notional'],
                        'excess': notional_value - limit['max_notional']
                    })
                
                # 집중도 한도 검사
                if weight > limit['concentration_limit']:
                    warnings.append({
                        'asset': asset,
                        'type': 'concentration_warning',
                        'current': weight,
                        'limit': limit['concentration_limit']
                    })
        
        # 전체 포트폴리오 한도 검사
        total_weight = sum(portfolio.values())
        if total_weight > 1.0:
            violations.append({
                'asset': 'portfolio',
                'type': 'total_weight_limit',
                'current': total_weight,
                'limit': 1.0,
                'excess': total_weight - 1.0
            })
        
        return {
            'violations': violations,
            'warnings': warnings,
            'is_compliant': len(violations) == 0
        }
    
    def suggest_position_adjustments(self, violations: List[Dict[str, Any]], 
                                   portfolio: Dict[str, float]) -> Dict[str, float]:
        """포지션 조정 제안"""
        adjusted_portfolio = portfolio.copy()
        
        for violation in violations:
            asset = violation['asset']
            if asset == 'portfolio':
                # 전체 포트폴리오 가중치 조정
                excess = violation['excess']
                for asset_name in adjusted_portfolio:
                    if adjusted_portfolio[asset_name] > 0:
                        reduction = excess * (adjusted_portfolio[asset_name] / sum(adjusted_portfolio.values()))
                        adjusted_portfolio[asset_name] -= reduction
            else:
                # 개별 자산 한도 조정
                if violation['type'] == 'weight_limit':
                    adjusted_portfolio[asset] = violation['limit']
                elif violation['type'] == 'notional_limit':
                    # 명목가치 한도에 맞춰 가중치 조정
                    portfolio_value = 1000000  # 예시 값
                    adjusted_portfolio[asset] = violation['limit'] / portfolio_value
        
        return adjusted_portfolio
    
    def calculate_risk_contribution(self, portfolio: Dict[str, float], 
                                  covariance_matrix: pd.DataFrame) -> Dict[str, float]:
        """리스크 기여도 계산"""
        portfolio_vector = np.array(list(portfolio.values()))
        
        # 포트폴리오 변동성
        portfolio_variance = portfolio_vector.T @ covariance_matrix @ portfolio_vector
        portfolio_volatility = np.sqrt(portfolio_variance)
        
        # 각 자산의 리스크 기여도
        risk_contributions = {}
        for i, asset in enumerate(portfolio.keys()):
            # 한계 리스크 기여도
            marginal_contribution = (covariance_matrix @ portfolio_vector)[i]
            risk_contribution = portfolio_vector[i] * marginal_contribution / portfolio_volatility
            
            risk_contributions[asset] = risk_contribution
        
        return risk_contributions
```

### 3. 변동성 기반 포지션 크기 조정

```python
class VolatilityBasedSizing:
    """변동성 기반 포지션 크기 조정"""
    
    def __init__(self, config: RiskConfig):
        self.config = config
        self.volatility_history = {}
        self.target_volatility = 0.15  # 15% 목표 변동성
    
    def calculate_volatility_adjusted_weights(self, portfolio: Dict[str, float], 
                                            returns_data: pd.DataFrame) -> Dict[str, float]:
        """변동성 조정 가중치 계산"""
        adjusted_weights = {}
        
        for asset, weight in portfolio.items():
            if asset in returns_data.columns:
                # 자산별 변동성 계산
                asset_volatility = self._calculate_asset_volatility(returns_data[asset])
                
                # 변동성 조정 계수
                volatility_adjustment = self._calculate_volatility_adjustment(asset_volatility)
                
                # 조정된 가중치
                adjusted_weights[asset] = weight * volatility_adjustment
        
        # 정규화
        total_weight = sum(adjusted_weights.values())
        if total_weight > 0:
            adjusted_weights = {k: v / total_weight for k, v in adjusted_weights.items()}
        
        return adjusted_weights
    
    def _calculate_asset_volatility(self, returns: pd.Series) -> float:
        """자산별 변동성 계산"""
        # 최근 데이터만 사용
        recent_returns = returns.tail(self.config.volatility_lookback)
        
        # 연간 변동성
        volatility = recent_returns.std() * np.sqrt(252)
        
        return volatility
    
    def _calculate_volatility_adjustment(self, asset_volatility: float) -> float:
        """변동성 조정 계수 계산"""
        if asset_volatility == 0:
            return 1.0
        
        # 목표 변동성 대비 조정
        adjustment = self.target_volatility / asset_volatility
        
        # 조정 범위 제한 (0.5 ~ 2.0)
        adjustment = np.clip(adjustment, 0.5, 2.0)
        
        return adjustment
    
    def dynamic_position_sizing(self, portfolio: Dict[str, float], 
                              returns_data: pd.DataFrame, 
                              market_volatility: float) -> Dict[str, float]:
        """동적 포지션 크기 조정"""
        # 시장 변동성에 따른 전체 포지션 크기 조정
        market_adjustment = self._calculate_market_adjustment(market_volatility)
        
        # 개별 자산 변동성 조정
        volatility_adjusted = self.calculate_volatility_adjusted_weights(portfolio, returns_data)
        
        # 최종 조정된 포지션
        final_positions = {}
        for asset, weight in volatility_adjusted.items():
            final_positions[asset] = weight * market_adjustment
        
        return final_positions
    
    def _calculate_market_adjustment(self, market_volatility: float) -> float:
        """시장 변동성 조정 계수"""
        if market_volatility == 0:
            return 1.0
        
        # 시장 변동성이 높을수록 포지션 크기 감소
        adjustment = self.target_volatility / market_volatility
        
        # 조정 범위 제한 (0.3 ~ 1.5)
        adjustment = np.clip(adjustment, 0.3, 1.5)
        
        return adjustment
    
    def calculate_kelly_criterion(self, returns: pd.Series) -> float:
        """켈리 기준 계산"""
        # 평균 수익률과 변동성
        mean_return = returns.mean()
        volatility = returns.std()
        
        if volatility == 0:
            return 0.0
        
        # 켈리 비율
        kelly_ratio = mean_return / (volatility ** 2)
        
        # 보수적 조정 (50%만 사용)
        conservative_kelly = kelly_ratio * 0.5
        
        # 범위 제한 (0 ~ 1)
        return np.clip(conservative_kelly, 0, 1)
```

### 4. 손실 제어 시스템

```python
class LossControlSystem:
    """손실 제어 시스템"""
    
    def __init__(self, config: RiskConfig):
        self.config = config
        self.stop_loss_levels = {}
        self.drawdown_limits = {}
        self.recovery_thresholds = {}
    
    def set_stop_loss_levels(self, stop_loss_config: Dict[str, Dict[str, float]]):
        """손절매 수준 설정"""
        for asset, config in stop_loss_config.items():
            self.stop_loss_levels[asset] = {
                'hard_stop': config.get('hard_stop', 0.10),  # 10% 하드 스탑
                'trailing_stop': config.get('trailing_stop', 0.05),  # 5% 트레일링 스탑
                'time_stop': config.get('time_stop', 30)  # 30일 시간 스탑
            }
    
    def check_stop_loss_conditions(self, portfolio: Dict[str, float], 
                                 current_prices: Dict[str, float], 
                                 entry_prices: Dict[str, float]) -> List[Dict[str, Any]]:
        """손절매 조건 검사"""
        stop_signals = []
        
        for asset, position in portfolio.items():
            if asset in self.stop_loss_levels and asset in current_prices and asset in entry_prices:
                current_price = current_prices[asset]
                entry_price = entry_prices[asset]
                
                # 손실률 계산
                loss_rate = (entry_price - current_price) / entry_price
                
                # 하드 스탑 검사
                if loss_rate >= self.stop_loss_levels[asset]['hard_stop']:
                    stop_signals.append({
                        'asset': asset,
                        'type': 'hard_stop',
                        'loss_rate': loss_rate,
                        'threshold': self.stop_loss_levels[asset]['hard_stop'],
                        'action': 'close_position'
                    })
                
                # 트레일링 스탑 검사
                elif loss_rate >= self.stop_loss_levels[asset]['trailing_stop']:
                    stop_signals.append({
                        'asset': asset,
                        'type': 'trailing_stop',
                        'loss_rate': loss_rate,
                        'threshold': self.stop_loss_levels[asset]['trailing_stop'],
                        'action': 'reduce_position'
                    })
        
        return stop_signals
    
    def set_drawdown_limits(self, limits: Dict[str, float]):
        """낙폭 한도 설정"""
        self.drawdown_limits = limits
    
    def check_drawdown_limits(self, equity_curve: pd.Series) -> Dict[str, Any]:
        """낙폭 한도 검사"""
        # 최대 낙폭 계산
        cumulative_returns = (1 + equity_curve).cumprod()
        running_max = cumulative_returns.expanding().max()
        drawdown = (cumulative_returns - running_max) / running_max
        current_drawdown = abs(drawdown.iloc[-1])
        
        # 한도 검사
        violations = []
        for limit_name, limit_value in self.drawdown_limits.items():
            if current_drawdown > limit_value:
                violations.append({
                    'limit_name': limit_name,
                    'current_drawdown': current_drawdown,
                    'limit_value': limit_value,
                    'excess': current_drawdown - limit_value
                })
        
        return {
            'current_drawdown': current_drawdown,
            'max_drawdown': abs(drawdown.min()),
            'violations': violations,
            'is_within_limits': len(violations) == 0
        }
    
    def set_recovery_thresholds(self, thresholds: Dict[str, float]):
        """회복 임계값 설정"""
        self.recovery_thresholds = thresholds
    
    def check_recovery_conditions(self, equity_curve: pd.Series) -> Dict[str, Any]:
        """회복 조건 검사"""
        # 최근 성과 계산
        recent_performance = equity_curve.tail(30).mean()  # 최근 30일
        
        recovery_signals = []
        for threshold_name, threshold_value in self.recovery_thresholds.items():
            if recent_performance > threshold_value:
                recovery_signals.append({
                    'threshold_name': threshold_name,
                    'recent_performance': recent_performance,
                    'threshold_value': threshold_value,
                    'action': 'increase_position'
                })
        
        return {
            'recent_performance': recent_performance,
            'recovery_signals': recovery_signals,
            'can_increase_position': len(recovery_signals) > 0
        }
    
    def calculate_max_loss_limit(self, portfolio_value: float, 
                               risk_budget: float) -> float:
        """최대 손실 한도 계산"""
        # 리스크 예산 기반 최대 손실 한도
        max_loss_limit = portfolio_value * risk_budget
        
        return max_loss_limit
    
    def check_max_loss_violation(self, current_loss: float, 
                               max_loss_limit: float) -> Dict[str, Any]:
        """최대 손실 한도 위반 검사"""
        if current_loss > max_loss_limit:
            return {
                'violated': True,
                'current_loss': current_loss,
                'max_loss_limit': max_loss_limit,
                'excess_loss': current_loss - max_loss_limit,
                'action': 'emergency_close_all'
            }
        else:
            return {
                'violated': False,
                'current_loss': current_loss,
                'max_loss_limit': max_loss_limit,
                'remaining_buffer': max_loss_limit - current_loss
            }
```

### 5. 실시간 위험 모니터링

```python
class RealTimeRiskMonitor:
    """실시간 위험 모니터링"""
    
    def __init__(self, config: RiskConfig):
        self.config = config
        self.risk_calculator = VaRCVaRCalculator(config)
        self.position_manager = PositionLimitManager(config)
        self.volatility_sizer = VolatilityBasedSizing(config)
        self.loss_controller = LossControlSystem(config)
        self.alert_system = RiskAlertSystem()
    
    def monitor_portfolio_risk(self, portfolio: Dict[str, float], 
                             returns_data: pd.DataFrame, 
                             portfolio_value: float) -> Dict[str, Any]:
        """포트폴리오 위험 모니터링"""
        monitoring_results = {}
        
        # VaR/CVaR 계산
        var_results = self.risk_calculator.calculate_portfolio_var(portfolio, returns_data)
        monitoring_results['var_metrics'] = var_results
        
        # 포지션 한도 검사
        limit_check = self.position_manager.check_position_limits(portfolio, portfolio_value)
        monitoring_results['position_limits'] = limit_check
        
        # 변동성 기반 조정
        volatility_adjusted = self.volatility_sizer.calculate_volatility_adjusted_weights(
            portfolio, returns_data
        )
        monitoring_results['volatility_adjustment'] = volatility_adjusted
        
        # 손실 제어 검사
        current_prices = self._get_current_prices(returns_data)
        entry_prices = self._get_entry_prices(portfolio)  # 실제 구현에서는 진입가격 저장 필요
        
        stop_loss_check = self.loss_controller.check_stop_loss_conditions(
            portfolio, current_prices, entry_prices
        )
        monitoring_results['stop_loss'] = stop_loss_check
        
        # 전체 위험 상태 평가
        risk_status = self._evaluate_overall_risk_status(monitoring_results)
        monitoring_results['overall_risk_status'] = risk_status
        
        # 알림 발송
        self._send_alerts(monitoring_results)
        
        return monitoring_results
    
    def _evaluate_overall_risk_status(self, monitoring_results: Dict[str, Any]) -> str:
        """전체 위험 상태 평가"""
        risk_score = 0
        
        # VaR 기반 위험 점수
        var_metrics = monitoring_results.get('var_metrics', {})
        if var_metrics.get('var', 0) > self.config.max_portfolio_risk:
            risk_score += 3
        
        # 포지션 한도 위반
        position_limits = monitoring_results.get('position_limits', {})
        if not position_limits.get('is_compliant', True):
            risk_score += 2
        
        # 손절매 신호
        stop_loss = monitoring_results.get('stop_loss', [])
        if len(stop_loss) > 0:
            risk_score += len(stop_loss)
        
        # 위험 등급 결정
        if risk_score >= 5:
            return 'CRITICAL'
        elif risk_score >= 3:
            return 'HIGH'
        elif risk_score >= 1:
            return 'MEDIUM'
        else:
            return 'LOW'
    
    def _send_alerts(self, monitoring_results: Dict[str, Any]):
        """알림 발송"""
        risk_status = monitoring_results.get('overall_risk_status', 'LOW')
        
        if risk_status in ['CRITICAL', 'HIGH']:
            self.alert_system.send_urgent_alert(
                f"위험 수준: {risk_status}",
                monitoring_results
            )
        
        # 개별 위반 사항 알림
        position_limits = monitoring_results.get('position_limits', {})
        for violation in position_limits.get('violations', []):
            self.alert_system.send_violation_alert(violation)
        
        stop_loss = monitoring_results.get('stop_loss', [])
        for signal in stop_loss:
            self.alert_system.send_stop_loss_alert(signal)
    
    def _get_current_prices(self, returns_data: pd.DataFrame) -> Dict[str, float]:
        """현재 가격 조회 (예시)"""
        # 실제 구현에서는 실시간 가격 데이터 사용
        current_prices = {}
        for asset in returns_data.columns:
            # 간단한 예시: 마지막 수익률을 기반으로 가격 추정
            current_prices[asset] = 100.0  # 예시 가격
        
        return current_prices
    
    def _get_entry_prices(self, portfolio: Dict[str, float]) -> Dict[str, float]:
        """진입 가격 조회 (예시)"""
        # 실제 구현에서는 거래 기록에서 진입가격 조회
        entry_prices = {}
        for asset in portfolio.keys():
            entry_prices[asset] = 100.0  # 예시 진입가격
        
        return entry_prices

class RiskAlertSystem:
    """위험 알림 시스템"""
    
    def __init__(self):
        self.alert_history = []
        self.alert_config = {
            'critical_threshold': 0.05,  # 5%
            'high_threshold': 0.03,      # 3%
            'medium_threshold': 0.02     # 2%
        }
    
    def send_urgent_alert(self, message: str, data: Dict[str, Any]):
        """긴급 알림 발송"""
        alert = {
            'timestamp': datetime.now(),
            'level': 'URGENT',
            'message': message,
            'data': data
        }
        
        self.alert_history.append(alert)
        logger.critical(f"긴급 알림: {message}")
        
        # 실제 구현에서는 이메일, SMS, 웹훅 등으로 알림 발송
    
    def send_violation_alert(self, violation: Dict[str, Any]):
        """위반 알림 발송"""
        alert = {
            'timestamp': datetime.now(),
            'level': 'VIOLATION',
            'message': f"포지션 한도 위반: {violation['asset']}",
            'data': violation
        }
        
        self.alert_history.append(alert)
        logger.warning(f"위반 알림: {violation}")
    
    def send_stop_loss_alert(self, signal: Dict[str, Any]):
        """손절매 알림 발송"""
        alert = {
            'timestamp': datetime.now(),
            'level': 'STOP_LOSS',
            'message': f"손절매 신호: {signal['asset']}",
            'data': signal
        }
        
        self.alert_history.append(alert)
        logger.warning(f"손절매 알림: {signal}")
    
    def get_recent_alerts(self, hours: int = 24) -> List[Dict[str, Any]]:
        """최근 알림 조회"""
        cutoff_time = datetime.now() - timedelta(hours=hours)
        
        recent_alerts = [
            alert for alert in self.alert_history
            if alert['timestamp'] >= cutoff_time
        ]
        
        return recent_alerts
```

## 📈 성과 지표

### 위험 관리 성과
- **VaR 정확도**: 실제 손실이 VaR을 초과하는 빈도 < 5%
- **리스크 대비 수익률**: 샤프 비율 > 1.5
- **최대 낙폭**: < 15%
- **포지션 한도 준수율**: 100%

### 실시간 모니터링
- **위험 계산 지연**: < 1초
- **알림 발송 지연**: < 50ms
- **포지션 조정 지연**: < 500ms
- **시스템 가용성**: > 99.9%

### 손실 제어
- **손절매 실행률**: 100%
- **최대 손실 한도 준수**: 100%
- **회복 시간**: < 90일
- **리스크 예산 효율성**: > 80%

## 🔄 개발 로드맵

### 1단계: 기본 위험 계산 (2025-05-01 ~ 2025-05-15)
- [x] VaR/CVaR 계산기 구현
- [x] 스트레스 테스트 시스템
- [ ] 파라미트릭 VaR 구현
- [ ] 몬테카를로 VaR 구현

### 2단계: 포지션 관리 (2025-05-16 ~ 2025-05-31)
- [ ] 포지션 한도 관리자 구현
- [ ] 리스크 기여도 계산
- [ ] 동적 포지션 조정
- [ ] 집중도 위험 관리

### 3단계: 변동성 기반 조정 (2025-06-01 ~ 2025-06-15)
- [ ] 변동성 기반 포지션 크기 조정
- [ ] 켈리 기준 구현
- [ ] 시장 변동성 모니터링
- [ ] 동적 가중치 조정

### 4단계: 손실 제어 (2025-06-16 ~ 2025-06-30)
- [ ] 손절매 시스템 구현
- [ ] 낙폭 제어 시스템
- [ ] 회복 메커니즘
- [ ] 최대 손실 한도 관리

### 5단계: 실시간 모니터링 (2025-07-01 ~ 2025-07-15)
- [ ] 실시간 위험 모니터링
- [ ] 알림 시스템 구현
- [ ] 대시보드 개발
- [ ] 통합 테스트

## 🔗 관련 문서
- [거래 시뮬레이터](3.5.6_TRADING_SIMULATOR.md)
- [데이터 거버넌스](3.5.8_DATA_GOVERNANCE.md)
- [포트폴리오 최적화](3.5.10_PORTFOLIO_OPTIMIZATION.md)
- [시장 마이크로구조](3.5.11_MARKET_MICROSTRUCTURE.md) 