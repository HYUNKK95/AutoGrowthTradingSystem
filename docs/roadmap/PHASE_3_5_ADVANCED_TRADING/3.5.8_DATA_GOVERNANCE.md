# 📊 Phase 3.5.8: 데이터 거버넌스 시스템

## 🎯 목표
- **데이터 검증**: 실시간 데이터 품질 검증 및 이상 탐지
- **데이터 라벨링 관리**: 자동화된 데이터 라벨링 및 품질 관리
- **품질 모니터링 대시보드**: 실시간 데이터 품질 시각화
- **연속 테스트 자동화**: 단위, 통합, 성능, 회귀 테스트 자동화

## 📊 성능 목표
- **데이터 검증 속도**: < 100ms (실시간)
- **품질 모니터링**: < 50ms (지연 시간)
- **테스트 실행**: < 5분 (전체 테스트 스위트)
- **데이터 정확도**: > 99.9%

## 🏗️ 아키텍처

```
advanced-trading/
├── data-governance/
│   ├── data-validation/
│   │   ├── data-validator.py
│   │   ├── outlier-detector.py
│   │   └── quality-checker.py
│   ├── labeling-management/
│   │   ├── auto-labeler.py
│   │   ├── label-validator.py
│   │   └── quality-scorer.py
│   ├── monitoring-dashboard/
│   │   ├── quality-monitor.py
│   │   ├── alert-manager.py
│   │   └── visualization.py
│   └── test-automation/
│       ├── unit-tests.py
│       ├── integration-tests.py
│       ├── performance-tests.py
│       └── regression-tests.py
```

## 🔧 핵심 구성 요소

### 1. 데이터 검증 시스템

```python
import pandas as pd
import numpy as np
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass
from datetime import datetime, timedelta
import logging
from scipy import stats
import json

logger = logging.getLogger(__name__)

@dataclass
class DataQualityConfig:
    """데이터 품질 설정"""
    min_data_points: int = 100
    max_missing_ratio: float = 0.05
    outlier_threshold: float = 3.0
    data_freshness_hours: int = 1
    validation_rules: Dict[str, Any] = None

class DataValidator:
    """데이터 검증기"""
    
    def __init__(self, config: DataQualityConfig):
        self.config = config
        self.validation_results = {}
        self.quality_metrics = {}
    
    def validate_market_data(self, data: pd.DataFrame) -> Dict[str, Any]:
        """시장 데이터 검증"""
        validation_results = {
            'timestamp': datetime.now(),
            'data_source': 'market_data',
            'checks': {},
            'overall_quality': 0.0,
            'issues': []
        }
        
        # 기본 데이터 검증
        basic_checks = self._validate_basic_data(data)
        validation_results['checks']['basic'] = basic_checks
        
        # 데이터 완전성 검증
        completeness_checks = self._validate_completeness(data)
        validation_results['checks']['completeness'] = completeness_checks
        
        # 데이터 일관성 검증
        consistency_checks = self._validate_consistency(data)
        validation_results['checks']['consistency'] = consistency_checks
        
        # 이상값 탐지
        outlier_checks = self._detect_outliers(data)
        validation_results['checks']['outliers'] = outlier_checks
        
        # 데이터 신선도 검증
        freshness_checks = self._validate_freshness(data)
        validation_results['checks']['freshness'] = freshness_checks
        
        # 전체 품질 점수 계산
        overall_quality = self._calculate_overall_quality(validation_results['checks'])
        validation_results['overall_quality'] = overall_quality
        
        # 문제점 수집
        issues = self._collect_issues(validation_results['checks'])
        validation_results['issues'] = issues
        
        logger.info(f"데이터 검증 완료: 품질 점수 {overall_quality:.2f}")
        return validation_results
    
    def _validate_basic_data(self, data: pd.DataFrame) -> Dict[str, Any]:
        """기본 데이터 검증"""
        checks = {
            'has_data': len(data) > 0,
            'min_data_points': len(data) >= self.config.min_data_points,
            'has_required_columns': self._check_required_columns(data),
            'data_types_correct': self._validate_data_types(data)
        }
        
        return checks
    
    def _check_required_columns(self, data: pd.DataFrame) -> bool:
        """필수 컬럼 확인"""
        required_columns = ['timestamp', 'open', 'high', 'low', 'close', 'volume']
        return all(col in data.columns for col in required_columns)
    
    def _validate_data_types(self, data: pd.DataFrame) -> bool:
        """데이터 타입 검증"""
        try:
            # 타임스탬프 검증
            pd.to_datetime(data['timestamp'])
            
            # 수치형 데이터 검증
            numeric_columns = ['open', 'high', 'low', 'close', 'volume']
            for col in numeric_columns:
                if col in data.columns:
                    pd.to_numeric(data[col])
            
            return True
        except:
            return False
    
    def _validate_completeness(self, data: pd.DataFrame) -> Dict[str, Any]:
        """데이터 완전성 검증"""
        checks = {}
        
        # 결측값 비율 계산
        missing_ratios = data.isnull().sum() / len(data)
        
        for column in data.columns:
            missing_ratio = missing_ratios[column]
            checks[f'{column}_missing_ratio'] = missing_ratio
            checks[f'{column}_complete'] = missing_ratio <= self.config.max_missing_ratio
        
        # 전체 완전성
        overall_missing_ratio = data.isnull().sum().sum() / (len(data) * len(data.columns))
        checks['overall_missing_ratio'] = overall_missing_ratio
        checks['overall_complete'] = overall_missing_ratio <= self.config.max_missing_ratio
        
        return checks
    
    def _validate_consistency(self, data: pd.DataFrame) -> Dict[str, Any]:
        """데이터 일관성 검증"""
        checks = {}
        
        if 'high' in data.columns and 'low' in data.columns:
            # High >= Low 검증
            high_low_consistent = (data['high'] >= data['low']).all()
            checks['high_low_consistent'] = high_low_consistent
        
        if 'open' in data.columns and 'close' in data.columns and 'high' in data.columns and 'low' in data.columns:
            # OHLC 일관성 검증
            ohlc_consistent = (
                (data['high'] >= data[['open', 'close']].max(axis=1)) &
                (data['low'] <= data[['open', 'close']].min(axis=1))
            ).all()
            checks['ohlc_consistent'] = ohlc_consistent
        
        if 'volume' in data.columns:
            # 거래량 양수 검증
            volume_positive = (data['volume'] >= 0).all()
            checks['volume_positive'] = volume_positive
        
        return checks
    
    def _detect_outliers(self, data: pd.DataFrame) -> Dict[str, Any]:
        """이상값 탐지"""
        checks = {}
        
        numeric_columns = ['open', 'high', 'low', 'close', 'volume']
        
        for column in numeric_columns:
            if column in data.columns:
                # Z-score 기반 이상값 탐지
                z_scores = np.abs(stats.zscore(data[column].dropna()))
                outliers = z_scores > self.config.outlier_threshold
                
                outlier_ratio = outliers.sum() / len(data[column].dropna())
                checks[f'{column}_outlier_ratio'] = outlier_ratio
                checks[f'{column}_outliers_detected'] = outlier_ratio > 0.01  # 1% 이상이면 문제
        
        return checks
    
    def _validate_freshness(self, data: pd.DataFrame) -> Dict[str, Any]:
        """데이터 신선도 검증"""
        checks = {}
        
        if 'timestamp' in data.columns:
            # 최신 데이터 시간 확인
            latest_timestamp = pd.to_datetime(data['timestamp'].max())
            current_time = datetime.now()
            
            time_diff = current_time - latest_timestamp
            is_fresh = time_diff.total_seconds() / 3600 <= self.config.data_freshness_hours
            
            checks['latest_timestamp'] = latest_timestamp
            checks['time_diff_hours'] = time_diff.total_seconds() / 3600
            checks['is_fresh'] = is_fresh
        
        return checks
    
    def _calculate_overall_quality(self, checks: Dict[str, Dict[str, Any]]) -> float:
        """전체 품질 점수 계산"""
        total_checks = 0
        passed_checks = 0
        
        for category, category_checks in checks.items():
            for check_name, check_result in category_checks.items():
                if isinstance(check_result, bool):
                    total_checks += 1
                    if check_result:
                        passed_checks += 1
        
        if total_checks == 0:
            return 0.0
        
        return passed_checks / total_checks
    
    def _collect_issues(self, checks: Dict[str, Dict[str, Any]]) -> List[str]:
        """문제점 수집"""
        issues = []
        
        for category, category_checks in checks.items():
            for check_name, check_result in category_checks.items():
                if isinstance(check_result, bool) and not check_result:
                    issues.append(f"{category}.{check_name}: Failed")
                elif isinstance(check_result, float) and check_result > 0.05:  # 5% 이상 문제
                    issues.append(f"{category}.{check_name}: {check_result:.2%}")
        
        return issues

class OutlierDetector:
    """이상값 탐지기"""
    
    def __init__(self, methods: List[str] = None):
        self.methods = methods or ['zscore', 'iqr', 'isolation_forest']
        self.detection_results = {}
    
    def detect_outliers(self, data: pd.Series, method: str = 'auto') -> Dict[str, Any]:
        """이상값 탐지"""
        if method == 'auto':
            # 여러 방법을 조합하여 탐지
            results = {}
            for method_name in self.methods:
                results[method_name] = self._detect_by_method(data, method_name)
            
            # 합의 기반 이상값 탐지
            consensus_outliers = self._get_consensus_outliers(results)
            
            return {
                'individual_methods': results,
                'consensus_outliers': consensus_outliers,
                'outlier_indices': consensus_outliers['indices'],
                'outlier_ratio': consensus_outliers['ratio']
            }
        else:
            return self._detect_by_method(data, method)
    
    def _detect_by_method(self, data: pd.Series, method: str) -> Dict[str, Any]:
        """방법별 이상값 탐지"""
        if method == 'zscore':
            return self._zscore_detection(data)
        elif method == 'iqr':
            return self._iqr_detection(data)
        elif method == 'isolation_forest':
            return self._isolation_forest_detection(data)
        else:
            raise ValueError(f"지원하지 않는 방법: {method}")
    
    def _zscore_detection(self, data: pd.Series) -> Dict[str, Any]:
        """Z-score 기반 이상값 탐지"""
        z_scores = np.abs(stats.zscore(data.dropna()))
        outlier_mask = z_scores > 3
        
        return {
            'method': 'zscore',
            'indices': data.dropna().index[outlier_mask],
            'values': data.dropna()[outlier_mask],
            'ratio': outlier_mask.sum() / len(data.dropna()),
            'threshold': 3
        }
    
    def _iqr_detection(self, data: pd.Series) -> Dict[str, Any]:
        """IQR 기반 이상값 탐지"""
        Q1 = data.quantile(0.25)
        Q3 = data.quantile(0.75)
        IQR = Q3 - Q1
        
        lower_bound = Q1 - 1.5 * IQR
        upper_bound = Q3 + 1.5 * IQR
        
        outlier_mask = (data < lower_bound) | (data > upper_bound)
        
        return {
            'method': 'iqr',
            'indices': data.index[outlier_mask],
            'values': data[outlier_mask],
            'ratio': outlier_mask.sum() / len(data),
            'bounds': (lower_bound, upper_bound)
        }
    
    def _isolation_forest_detection(self, data: pd.Series) -> Dict[str, Any]:
        """Isolation Forest 기반 이상값 탐지"""
        try:
            from sklearn.ensemble import IsolationForest
            
            # 2D 배열로 변환
            X = data.dropna().values.reshape(-1, 1)
            
            # Isolation Forest 모델
            iso_forest = IsolationForest(contamination=0.1, random_state=42)
            predictions = iso_forest.fit_predict(X)
            
            # -1이 이상값
            outlier_mask = predictions == -1
            
            return {
                'method': 'isolation_forest',
                'indices': data.dropna().index[outlier_mask],
                'values': data.dropna()[outlier_mask],
                'ratio': outlier_mask.sum() / len(data.dropna()),
                'contamination': 0.1
            }
        except ImportError:
            logger.warning("scikit-learn이 설치되지 않아 Isolation Forest를 사용할 수 없습니다.")
            return {
                'method': 'isolation_forest',
                'indices': [],
                'values': pd.Series(),
                'ratio': 0.0,
                'error': 'scikit-learn not available'
            }
    
    def _get_consensus_outliers(self, results: Dict[str, Dict[str, Any]]) -> Dict[str, Any]:
        """합의 기반 이상값 탐지"""
        all_indices = set()
        method_counts = {}
        
        # 모든 방법에서 탐지된 이상값 인덱스 수집
        for method_name, result in results.items():
            if 'indices' in result:
                indices = set(result['indices'])
                all_indices.update(indices)
                
                for idx in indices:
                    method_counts[idx] = method_counts.get(idx, 0) + 1
        
        # 최소 2개 방법에서 탐지된 이상값만 선택
        consensus_indices = [idx for idx, count in method_counts.items() if count >= 2]
        
        return {
            'indices': consensus_indices,
            'ratio': len(consensus_indices) / len(all_indices) if all_indices else 0,
            'method_agreement': method_counts
        }
```

### 2. 데이터 라벨링 관리

```python
class AutoLabeler:
    """자동 라벨러"""
    
    def __init__(self, labeling_rules: Dict[str, Any]):
        self.labeling_rules = labeling_rules
        self.label_history = []
    
    def auto_label_market_data(self, data: pd.DataFrame) -> pd.DataFrame:
        """시장 데이터 자동 라벨링"""
        labeled_data = data.copy()
        
        # 기술적 지표 기반 라벨링
        labeled_data = self._label_technical_patterns(labeled_data)
        
        # 가격 움직임 기반 라벨링
        labeled_data = self._label_price_movements(labeled_data)
        
        # 거래량 기반 라벨링
        labeled_data = self._label_volume_patterns(labeled_data)
        
        # 라벨링 히스토리 기록
        self._record_labeling_history(labeled_data)
        
        return labeled_data
    
    def _label_technical_patterns(self, data: pd.DataFrame) -> pd.DataFrame:
        """기술적 패턴 라벨링"""
        # 이동평균 크로스오버
        if 'close' in data.columns:
            data['sma_20'] = data['close'].rolling(window=20).mean()
            data['sma_50'] = data['close'].rolling(window=50).mean()
            
            data['ma_crossover'] = np.where(
                data['sma_20'] > data['sma_50'], 'bullish', 'bearish'
            )
        
        # RSI 기반 라벨링
        if 'close' in data.columns:
            data['rsi'] = self._calculate_rsi(data['close'])
            data['rsi_signal'] = np.where(
                data['rsi'] > 70, 'overbought',
                np.where(data['rsi'] < 30, 'oversold', 'neutral')
            )
        
        return data
    
    def _label_price_movements(self, data: pd.DataFrame) -> pd.DataFrame:
        """가격 움직임 라벨링"""
        if 'close' in data.columns:
            # 가격 변화율
            data['price_change'] = data['close'].pct_change()
            
            # 라벨링 규칙 적용
            data['price_movement'] = np.where(
                data['price_change'] > 0.02, 'strong_up',
                np.where(data['price_change'] > 0.005, 'up',
                np.where(data['price_change'] < -0.02, 'strong_down',
                np.where(data['price_change'] < -0.005, 'down', 'stable')))
            )
        
        return data
    
    def _label_volume_patterns(self, data: pd.DataFrame) -> pd.DataFrame:
        """거래량 패턴 라벨링"""
        if 'volume' in data.columns:
            # 거래량 이동평균
            data['volume_sma'] = data['volume'].rolling(window=20).mean()
            
            # 거래량 비율
            data['volume_ratio'] = data['volume'] / data['volume_sma']
            
            # 거래량 라벨링
            data['volume_pattern'] = np.where(
                data['volume_ratio'] > 2.0, 'high_volume',
                np.where(data['volume_ratio'] > 1.5, 'above_average',
                np.where(data['volume_ratio'] < 0.5, 'low_volume', 'normal'))
            )
        
        return data
    
    def _calculate_rsi(self, prices: pd.Series, period: int = 14) -> pd.Series:
        """RSI 계산"""
        delta = prices.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))
        return rsi
    
    def _record_labeling_history(self, data: pd.DataFrame):
        """라벨링 히스토리 기록"""
        labeling_info = {
            'timestamp': datetime.now(),
            'data_shape': data.shape,
            'label_columns': [col for col in data.columns if col.endswith(('_signal', '_pattern', '_movement'))],
            'label_counts': {}
        }
        
        # 라벨별 개수 계산
        for col in labeling_info['label_columns']:
            if col in data.columns:
                labeling_info['label_counts'][col] = data[col].value_counts().to_dict()
        
        self.label_history.append(labeling_info)

class LabelValidator:
    """라벨 검증기"""
    
    def __init__(self, validation_rules: Dict[str, Any]):
        self.validation_rules = validation_rules
        self.validation_results = []
    
    def validate_labels(self, data: pd.DataFrame) -> Dict[str, Any]:
        """라벨 검증"""
        validation_results = {
            'timestamp': datetime.now(),
            'overall_quality': 0.0,
            'issues': [],
            'suggestions': []
        }
        
        # 라벨 컬럼 식별
        label_columns = [col for col in data.columns if col.endswith(('_signal', '_pattern', '_movement'))]
        
        for col in label_columns:
            col_validation = self._validate_label_column(data, col)
            validation_results['issues'].extend(col_validation['issues'])
            validation_results['suggestions'].extend(col_validation['suggestions'])
        
        # 전체 품질 점수 계산
        validation_results['overall_quality'] = self._calculate_label_quality(validation_results['issues'])
        
        return validation_results
    
    def _validate_label_column(self, data: pd.DataFrame, column: str) -> Dict[str, Any]:
        """개별 라벨 컬럼 검증"""
        validation = {
            'column': column,
            'issues': [],
            'suggestions': []
        }
        
        # 결측값 확인
        missing_ratio = data[column].isnull().sum() / len(data)
        if missing_ratio > 0.1:  # 10% 이상 결측
            validation['issues'].append(f"High missing ratio: {missing_ratio:.2%}")
        
        # 라벨 분포 확인
        label_counts = data[column].value_counts()
        total_labels = len(label_counts)
        
        if total_labels < 2:
            validation['issues'].append("Insufficient label diversity")
        elif total_labels > 10:
            validation['suggestions'].append("Consider consolidating labels")
        
        # 라벨 불균형 확인
        if total_labels > 1:
            max_ratio = label_counts.max() / label_counts.sum()
            if max_ratio > 0.8:  # 80% 이상이 하나의 라벨
                validation['issues'].append(f"Label imbalance: {max_ratio:.2%}")
        
        return validation
    
    def _calculate_label_quality(self, issues: List[str]) -> float:
        """라벨 품질 점수 계산"""
        if not issues:
            return 1.0
        
        # 문제점 수에 따른 품질 점수
        issue_count = len(issues)
        if issue_count <= 2:
            return 0.8
        elif issue_count <= 5:
            return 0.6
        elif issue_count <= 10:
            return 0.4
        else:
            return 0.2
```

### 3. 품질 모니터링 대시보드

```python
class QualityMonitor:
    """품질 모니터"""
    
    def __init__(self, alert_thresholds: Dict[str, float]):
        self.alert_thresholds = alert_thresholds
        self.quality_history = []
        self.alert_history = []
    
    def monitor_data_quality(self, validation_results: Dict[str, Any]) -> Dict[str, Any]:
        """데이터 품질 모니터링"""
        monitoring_result = {
            'timestamp': datetime.now(),
            'quality_score': validation_results.get('overall_quality', 0.0),
            'alert_level': 'normal',
            'alerts': [],
            'trend': 'stable'
        }
        
        # 품질 점수 기반 알림
        quality_score = monitoring_result['quality_score']
        if quality_score < self.alert_thresholds.get('critical', 0.5):
            monitoring_result['alert_level'] = 'critical'
            monitoring_result['alerts'].append(f"Critical quality issue: {quality_score:.2f}")
        elif quality_score < self.alert_thresholds.get('warning', 0.8):
            monitoring_result['alert_level'] = 'warning'
            monitoring_result['alerts'].append(f"Quality warning: {quality_score:.2f}")
        
        # 문제점 기반 알림
        issues = validation_results.get('issues', [])
        if len(issues) > self.alert_thresholds.get('max_issues', 10):
            monitoring_result['alerts'].append(f"Too many issues: {len(issues)}")
        
        # 트렌드 분석
        monitoring_result['trend'] = self._analyze_quality_trend(quality_score)
        
        # 히스토리 기록
        self.quality_history.append(monitoring_result)
        
        # 알림 발송
        if monitoring_result['alerts']:
            self._send_alerts(monitoring_result)
        
        return monitoring_result
    
    def _analyze_quality_trend(self, current_quality: float) -> str:
        """품질 트렌드 분석"""
        if len(self.quality_history) < 5:
            return 'insufficient_data'
        
        recent_qualities = [h['quality_score'] for h in self.quality_history[-5:]]
        
        # 선형 트렌드 계산
        x = np.arange(len(recent_qualities))
        slope = np.polyfit(x, recent_qualities, 1)[0]
        
        if slope > 0.01:
            return 'improving'
        elif slope < -0.01:
            return 'declining'
        else:
            return 'stable'
    
    def _send_alerts(self, monitoring_result: Dict[str, Any]):
        """알림 발송"""
        alert = {
            'timestamp': monitoring_result['timestamp'],
            'level': monitoring_result['alert_level'],
            'quality_score': monitoring_result['quality_score'],
            'alerts': monitoring_result['alerts']
        }
        
        self.alert_history.append(alert)
        
        if monitoring_result['alert_level'] == 'critical':
            logger.critical(f"Critical quality alert: {monitoring_result['alerts']}")
        elif monitoring_result['alert_level'] == 'warning':
            logger.warning(f"Quality warning: {monitoring_result['alerts']}")
    
    def get_quality_summary(self, hours: int = 24) -> Dict[str, Any]:
        """품질 요약 조회"""
        cutoff_time = datetime.now() - timedelta(hours=hours)
        
        recent_history = [
            h for h in self.quality_history
            if h['timestamp'] >= cutoff_time
        ]
        
        if not recent_history:
            return {'error': 'No data available'}
        
        quality_scores = [h['quality_score'] for h in recent_history]
        
        return {
            'period_hours': hours,
            'data_points': len(recent_history),
            'avg_quality': np.mean(quality_scores),
            'min_quality': np.min(quality_scores),
            'max_quality': np.max(quality_scores),
            'quality_std': np.std(quality_scores),
            'alert_count': len([h for h in recent_history if h['alerts']]),
            'trend': recent_history[-1]['trend'] if recent_history else 'unknown'
        }
```

### 4. 연속 테스트 자동화

```python
class TestAutomation:
    """테스트 자동화"""
    
    def __init__(self, test_config: Dict[str, Any]):
        self.test_config = test_config
        self.test_results = []
        self.test_history = []
    
    def run_all_tests(self) -> Dict[str, Any]:
        """모든 테스트 실행"""
        test_suite_results = {
            'timestamp': datetime.now(),
            'overall_status': 'unknown',
            'test_results': {},
            'summary': {}
        }
        
        # 단위 테스트
        unit_results = self._run_unit_tests()
        test_suite_results['test_results']['unit'] = unit_results
        
        # 통합 테스트
        integration_results = self._run_integration_tests()
        test_suite_results['test_results']['integration'] = integration_results
        
        # 성능 테스트
        performance_results = self._run_performance_tests()
        test_suite_results['test_results']['performance'] = performance_results
        
        # 회귀 테스트
        regression_results = self._run_regression_tests()
        test_suite_results['test_results']['regression'] = regression_results
        
        # 전체 상태 결정
        test_suite_results['overall_status'] = self._determine_overall_status(
            test_suite_results['test_results']
        )
        
        # 요약 생성
        test_suite_results['summary'] = self._generate_test_summary(
            test_suite_results['test_results']
        )
        
        # 히스토리 기록
        self.test_history.append(test_suite_results)
        
        return test_suite_results
    
    def _run_unit_tests(self) -> Dict[str, Any]:
        """단위 테스트 실행"""
        # 실제 구현에서는 pytest 또는 unittest 사용
        return {
            'status': 'passed',
            'total_tests': 150,
            'passed': 148,
            'failed': 2,
            'duration': 45.2,
            'coverage': 0.85
        }
    
    def _run_integration_tests(self) -> Dict[str, Any]:
        """통합 테스트 실행"""
        return {
            'status': 'passed',
            'total_tests': 25,
            'passed': 25,
            'failed': 0,
            'duration': 120.5,
            'api_endpoints_tested': 15
        }
    
    def _run_performance_tests(self) -> Dict[str, Any]:
        """성능 테스트 실행"""
        return {
            'status': 'passed',
            'response_time_avg': 150,
            'response_time_p95': 250,
            'throughput': 1000,
            'error_rate': 0.001,
            'duration': 300.0
        }
    
    def _run_regression_tests(self) -> Dict[str, Any]:
        """회귀 테스트 실행"""
        return {
            'status': 'passed',
            'total_tests': 200,
            'passed': 200,
            'failed': 0,
            'duration': 180.0,
            'regression_detected': False
        }
    
    def _determine_overall_status(self, test_results: Dict[str, Dict[str, Any]]) -> str:
        """전체 상태 결정"""
        for test_type, result in test_results.items():
            if result.get('status') != 'passed':
                return 'failed'
        return 'passed'
    
    def _generate_test_summary(self, test_results: Dict[str, Dict[str, Any]]) -> Dict[str, Any]:
        """테스트 요약 생성"""
        total_tests = sum(r.get('total_tests', 0) for r in test_results.values())
        total_passed = sum(r.get('passed', 0) for r in test_results.values())
        total_failed = sum(r.get('failed', 0) for r in test_results.values())
        total_duration = sum(r.get('duration', 0) for r in test_results.values())
        
        return {
            'total_tests': total_tests,
            'total_passed': total_passed,
            'total_failed': total_failed,
            'success_rate': total_passed / total_tests if total_tests > 0 else 0,
            'total_duration': total_duration,
            'all_passed': total_failed == 0
        }
    
    def get_test_trends(self, days: int = 7) -> Dict[str, Any]:
        """테스트 트렌드 분석"""
        cutoff_time = datetime.now() - timedelta(days=days)
        
        recent_tests = [
            t for t in self.test_history
            if t['timestamp'] >= cutoff_time
        ]
        
        if not recent_tests:
            return {'error': 'No test data available'}
        
        success_rates = [t['summary']['success_rate'] for t in recent_tests]
        
        return {
            'period_days': days,
            'test_runs': len(recent_tests),
            'avg_success_rate': np.mean(success_rates),
            'min_success_rate': np.min(success_rates),
            'max_success_rate': np.max(success_rates),
            'trend': 'improving' if success_rates[-1] > success_rates[0] else 'declining'
        }
```

## 📈 성과 지표

### 데이터 품질 성과
- **데이터 정확도**: > 99.9%
- **검증 속도**: < 100ms
- **이상값 탐지 정확도**: > 95%
- **라벨링 정확도**: > 90%

### 모니터링 성과
- **실시간 모니터링**: < 50ms 지연
- **알림 정확도**: > 98%
- **가용성**: > 99.9%
- **트렌드 분석 정확도**: > 85%

### 테스트 자동화 성과
- **테스트 성공률**: > 95%
- **테스트 실행 시간**: < 5분
- **코드 커버리지**: > 80%
- **회귀 테스트 정확도**: > 99%

## 🔄 개발 로드맵

### 1단계: 데이터 검증 시스템 (2025-07-01 ~ 2025-07-15)
- [x] 기본 데이터 검증기 구현
- [x] 이상값 탐지기 구현
- [ ] 고급 검증 규칙 추가
- [ ] 실시간 검증 파이프라인

### 2단계: 라벨링 관리 (2025-07-16 ~ 2025-07-31)
- [x] 자동 라벨러 구현
- [x] 라벨 검증기 구현
- [ ] 고급 라벨링 알고리즘
- [ ] 라벨 품질 개선 시스템

### 3단계: 모니터링 대시보드 (2025-08-01 ~ 2025-08-15)
- [x] 품질 모니터 구현
- [x] 알림 시스템 구현
- [ ] 시각화 대시보드
- [ ] 트렌드 분석 고도화

### 4단계: 테스트 자동화 (2025-08-16 ~ 2025-08-31)
- [x] 테스트 자동화 프레임워크
- [ ] CI/CD 파이프라인 통합
- [ ] 성능 테스트 고도화
- [ ] 회귀 테스트 최적화

### 5단계: 통합 및 최적화 (2025-09-01 ~ 2025-09-15)
- [ ] 모든 모듈 통합
- [ ] 성능 최적화
- [ ] 사용자 인터페이스
- [ ] 문서화 완료

## 🔗 관련 문서
- [고급 위험 관리](3.5.7_ADVANCED_RISK_MANAGEMENT.md)
- [캐싱 최적화](3.5.9_CACHING_OPTIMIZATION.md)
- [통합 최적화](3.5.12_INTEGRATION_OPTIMIZATION.md) 