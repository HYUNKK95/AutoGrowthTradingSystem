# 📊 Phase 3.5.11: 시장 마이크로구조 분석 시스템

## 🎯 목표
- **주문장 분석**: 실시간 주문장 깊이 및 유동성 분석
- **유동성 메트릭**: 스프레드, 깊이, 회복성 측정
- **시장 영향 분석**: 거래 규모별 시장 영향도 계산
- **실시간 유동성 모니터링**: 다중 거래소 유동성 통합 분석

## 📊 성능 목표
- **주문장 분석 속도**: < 10ms (실시간)
- **유동성 계산**: < 5ms (메트릭당)
- **시장 영향 분석**: < 50ms (거래 규모별)
- **다중 거래소 통합**: < 100ms (전체)

## 🏗️ 아키텍처

```
advanced-trading/
├── market-microstructure/
│   ├── order-book-analysis/
│   │   ├── order-book-parser.py
│   │   ├── depth-analyzer.py
│   │   └── spread-calculator.py
│   ├── liquidity-metrics/
│   │   ├── liquidity-calculator.py
│   │   ├── resilience-analyzer.py
│   │   └── market-impact.py
│   ├── market-impact/
│   │   ├── impact-calculator.py
│   │   ├── trade-size-analyzer.py
│   │   └── price-impact.py
│   ├── real-time-monitoring/
│   │   ├── liquidity-monitor.py
│   │   ├── multi-exchange-analyzer.py
│   │   └── alert-system.py
│   └── microstructure-signals/
│       ├── signal-generator.py
│       ├── pattern-recognizer.py
│       └── trading-signals.py
```

## 🔧 핵심 구성 요소

### 1. 주문장 분석

```python
import numpy as np
import pandas as pd
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass
from datetime import datetime, timedelta
import logging
from collections import defaultdict
import asyncio

logger = logging.getLogger(__name__)

@dataclass
class OrderBookLevel:
    """주문장 레벨"""
    price: float
    quantity: float
    order_count: int
    timestamp: datetime

@dataclass
class OrderBook:
    """주문장"""
    symbol: str
    timestamp: datetime
    bids: List[OrderBookLevel]
    asks: List[OrderBookLevel]
    last_price: float
    last_quantity: float

class OrderBookParser:
    """주문장 파서"""
    
    def __init__(self, max_depth: int = 20):
        self.max_depth = max_depth
        self.order_book_cache = {}
        self.update_history = []
    
    def parse_order_book(self, raw_data: Dict[str, Any]) -> OrderBook:
        """주문장 데이터 파싱"""
        try:
            symbol = raw_data.get('symbol', '')
            timestamp = datetime.fromtimestamp(raw_data.get('timestamp', 0) / 1000)
            
            # 매수 주문 파싱
            bids = []
            for bid_data in raw_data.get('bids', [])[:self.max_depth]:
                bid = OrderBookLevel(
                    price=float(bid_data[0]),
                    quantity=float(bid_data[1]),
                    order_count=int(bid_data[2]) if len(bid_data) > 2 else 1,
                    timestamp=timestamp
                )
                bids.append(bid)
            
            # 매도 주문 파싱
            asks = []
            for ask_data in raw_data.get('asks', [])[:self.max_depth]:
                ask = OrderBookLevel(
                    price=float(ask_data[0]),
                    quantity=float(ask_data[1]),
                    order_count=int(ask_data[2]) if len(ask_data) > 2 else 1,
                    timestamp=timestamp
                )
                asks.append(ask)
            
            order_book = OrderBook(
                symbol=symbol,
                timestamp=timestamp,
                bids=bids,
                asks=asks,
                last_price=float(raw_data.get('last_price', 0)),
                last_quantity=float(raw_data.get('last_quantity', 0))
            )
            
            # 캐시 업데이트
            self.order_book_cache[symbol] = order_book
            self.update_history.append({
                'symbol': symbol,
                'timestamp': timestamp,
                'bid_count': len(bids),
                'ask_count': len(asks)
            })
            
            return order_book
            
        except Exception as e:
            logger.error(f"Order book parsing failed: {e}")
            raise
    
    def get_order_book(self, symbol: str) -> Optional[OrderBook]:
        """캐시된 주문장 조회"""
        return self.order_book_cache.get(symbol)
    
    def get_order_book_snapshot(self, symbol: str, depth: int = 10) -> Dict[str, Any]:
        """주문장 스냅샷 생성"""
        order_book = self.get_order_book(symbol)
        if not order_book:
            return {}
        
        return {
            'symbol': symbol,
            'timestamp': order_book.timestamp,
            'bids': [
                {
                    'price': bid.price,
                    'quantity': bid.quantity,
                    'order_count': bid.order_count
                }
                for bid in order_book.bids[:depth]
            ],
            'asks': [
                {
                    'price': ask.price,
                    'quantity': ask.quantity,
                    'order_count': ask.order_count
                }
                for ask in order_book.asks[:depth]
            ],
            'best_bid': order_book.bids[0].price if order_book.bids else None,
            'best_ask': order_book.asks[0].price if order_book.asks else None,
            'last_price': order_book.last_price
        }

class DepthAnalyzer:
    """깊이 분석기"""
    
    def __init__(self):
        self.depth_metrics = {}
    
    def analyze_order_book_depth(self, order_book: OrderBook) -> Dict[str, Any]:
        """주문장 깊이 분석"""
        try:
            # 기본 메트릭
            best_bid = order_book.bids[0].price if order_book.bids else 0
            best_ask = order_book.asks[0].price if order_book.asks else 0
            mid_price = (best_bid + best_ask) / 2 if best_bid and best_ask else 0
            
            # 누적 깊이 계산
            cumulative_bids = self._calculate_cumulative_depth(order_book.bids, 'bid')
            cumulative_asks = self._calculate_cumulative_depth(order_book.asks, 'ask')
            
            # 깊이 불균형
            depth_imbalance = self._calculate_depth_imbalance(cumulative_bids, cumulative_asks)
            
            # 가격 레벨별 깊이
            price_level_depth = self._analyze_price_level_depth(order_book)
            
            return {
                'timestamp': order_book.timestamp,
                'symbol': order_book.symbol,
                'best_bid': best_bid,
                'best_ask': best_ask,
                'mid_price': mid_price,
                'spread': best_ask - best_bid if best_bid and best_ask else 0,
                'spread_bps': ((best_ask - best_bid) / mid_price * 10000) if mid_price else 0,
                'cumulative_bids': cumulative_bids,
                'cumulative_asks': cumulative_asks,
                'depth_imbalance': depth_imbalance,
                'price_level_depth': price_level_depth,
                'total_bid_quantity': sum(bid.quantity for bid in order_book.bids),
                'total_ask_quantity': sum(ask.quantity for ask in order_book.asks),
                'bid_order_count': sum(bid.order_count for bid in order_book.bids),
                'ask_order_count': sum(ask.order_count for ask in order_book.asks)
            }
            
        except Exception as e:
            logger.error(f"Depth analysis failed: {e}")
            raise
    
    def _calculate_cumulative_depth(self, levels: List[OrderBookLevel], side: str) -> List[Dict[str, float]]:
        """누적 깊이 계산"""
        cumulative_depth = []
        cumulative_quantity = 0
        cumulative_value = 0
        
        for level in levels:
            cumulative_quantity += level.quantity
            cumulative_value += level.quantity * level.price
            
            cumulative_depth.append({
                'price': level.price,
                'cumulative_quantity': cumulative_quantity,
                'cumulative_value': cumulative_value,
                'average_price': cumulative_value / cumulative_quantity if cumulative_quantity > 0 else 0
            })
        
        return cumulative_depth
    
    def _calculate_depth_imbalance(self, cumulative_bids: List[Dict[str, float]], 
                                 cumulative_asks: List[Dict[str, float]]) -> Dict[str, float]:
        """깊이 불균형 계산"""
        if not cumulative_bids or not cumulative_asks:
            return {'imbalance': 0, 'bias': 'neutral'}
        
        # 동일한 가격 범위에서 비교
        bid_quantity = cumulative_bids[-1]['cumulative_quantity'] if cumulative_bids else 0
        ask_quantity = cumulative_asks[-1]['cumulative_quantity'] if cumulative_asks else 0
        
        total_quantity = bid_quantity + ask_quantity
        if total_quantity == 0:
            return {'imbalance': 0, 'bias': 'neutral'}
        
        imbalance = (bid_quantity - ask_quantity) / total_quantity
        
        if imbalance > 0.1:
            bias = 'bid_heavy'
        elif imbalance < -0.1:
            bias = 'ask_heavy'
        else:
            bias = 'balanced'
        
        return {
            'imbalance': imbalance,
            'bias': bias,
            'bid_quantity': bid_quantity,
            'ask_quantity': ask_quantity
        }
    
    def _analyze_price_level_depth(self, order_book: OrderBook) -> Dict[str, Any]:
        """가격 레벨별 깊이 분석"""
        price_levels = {
            'bid_levels': len(order_book.bids),
            'ask_levels': len(order_book.asks),
            'bid_price_range': order_book.bids[-1].price - order_book.bids[0].price if len(order_book.bids) > 1 else 0,
            'ask_price_range': order_book.asks[-1].price - order_book.asks[0].price if len(order_book.asks) > 1 else 0,
            'bid_quantity_distribution': [bid.quantity for bid in order_book.bids],
            'ask_quantity_distribution': [ask.quantity for ask in order_book.asks]
        }
        
        return price_levels

class SpreadCalculator:
    """스프레드 계산기"""
    
    def __init__(self):
        self.spread_history = defaultdict(list)
        self.spread_stats = {}
    
    def calculate_spread_metrics(self, order_book: OrderBook) -> Dict[str, Any]:
        """스프레드 메트릭 계산"""
        try:
            if not order_book.bids or not order_book.asks:
                return {'error': 'Insufficient order book data'}
            
            best_bid = order_book.bids[0].price
            best_ask = order_book.asks[0].price
            mid_price = (best_bid + best_ask) / 2
            
            # 기본 스프레드
            absolute_spread = best_ask - best_bid
            relative_spread = absolute_spread / mid_price
            spread_bps = relative_spread * 10000
            
            # 가중 평균 스프레드 (깊이 고려)
            weighted_spread = self._calculate_weighted_spread(order_book)
            
            # 스프레드 통계 업데이트
            self._update_spread_stats(order_book.symbol, spread_bps)
            
            return {
                'timestamp': order_book.timestamp,
                'symbol': order_book.symbol,
                'absolute_spread': absolute_spread,
                'relative_spread': relative_spread,
                'spread_bps': spread_bps,
                'weighted_spread': weighted_spread,
                'best_bid': best_bid,
                'best_ask': best_ask,
                'mid_price': mid_price,
                'spread_stats': self.spread_stats.get(order_book.symbol, {})
            }
            
        except Exception as e:
            logger.error(f"Spread calculation failed: {e}")
            raise
    
    def _calculate_weighted_spread(self, order_book: OrderBook) -> float:
        """가중 평균 스프레드 계산"""
        if not order_book.bids or not order_book.asks:
            return 0
        
        # 매수/매도 깊이를 고려한 가중 평균
        bid_quantity = sum(bid.quantity for bid in order_book.bids[:5])  # 상위 5개 레벨
        ask_quantity = sum(ask.quantity for ask in order_book.asks[:5])
        
        if bid_quantity == 0 or ask_quantity == 0:
            return order_book.asks[0].price - order_book.bids[0].price
        
        # 가중 평균 가격
        weighted_bid = sum(bid.price * bid.quantity for bid in order_book.bids[:5]) / bid_quantity
        weighted_ask = sum(ask.price * ask.quantity for ask in order_book.asks[:5]) / ask_quantity
        
        return weighted_ask - weighted_bid
    
    def _update_spread_stats(self, symbol: str, spread_bps: float):
        """스프레드 통계 업데이트"""
        if symbol not in self.spread_stats:
            self.spread_stats[symbol] = {
                'values': [],
                'mean': 0,
                'std': 0,
                'min': float('inf'),
                'max': 0
            }
        
        stats = self.spread_stats[symbol]
        stats['values'].append(spread_bps)
        
        # 최근 1000개 값만 유지
        if len(stats['values']) > 1000:
            stats['values'] = stats['values'][-1000:]
        
        # 통계 재계산
        if stats['values']:
            stats['mean'] = np.mean(stats['values'])
            stats['std'] = np.std(stats['values'])
            stats['min'] = min(stats['values'])
            stats['max'] = max(stats['values'])
```

### 2. 유동성 메트릭

```python
class LiquidityCalculator:
    """유동성 계산기"""
    
    def __init__(self):
        self.liquidity_metrics = {}
    
    def calculate_liquidity_metrics(self, order_book: OrderBook, 
                                  trade_size: float = 10000) -> Dict[str, Any]:
        """유동성 메트릭 계산"""
        try:
            # 기본 유동성 메트릭
            basic_metrics = self._calculate_basic_liquidity(order_book)
            
            # 특정 거래 규모에 대한 유동성
            size_specific_metrics = self._calculate_size_specific_liquidity(order_book, trade_size)
            
            # 유동성 비율
            liquidity_ratios = self._calculate_liquidity_ratios(order_book)
            
            # 유동성 점수
            liquidity_score = self._calculate_liquidity_score(basic_metrics, size_specific_metrics)
            
            return {
                'timestamp': order_book.timestamp,
                'symbol': order_book.symbol,
                'basic_metrics': basic_metrics,
                'size_specific_metrics': size_specific_metrics,
                'liquidity_ratios': liquidity_ratios,
                'liquidity_score': liquidity_score,
                'trade_size': trade_size
            }
            
        except Exception as e:
            logger.error(f"Liquidity calculation failed: {e}")
            raise
    
    def _calculate_basic_liquidity(self, order_book: OrderBook) -> Dict[str, float]:
        """기본 유동성 메트릭"""
        if not order_book.bids or not order_book.asks:
            return {}
        
        best_bid = order_book.bids[0].price
        best_ask = order_book.asks[0].price
        mid_price = (best_bid + best_ask) / 2
        
        # 스프레드 기반 유동성
        spread = best_ask - best_bid
        relative_spread = spread / mid_price
        
        # 깊이 기반 유동성
        bid_depth = sum(bid.quantity for bid in order_book.bids[:5])
        ask_depth = sum(ask.quantity for ask in order_book.asks[:5])
        total_depth = bid_depth + ask_depth
        
        # 주문 수 기반 유동성
        bid_orders = sum(bid.order_count for bid in order_book.bids[:5])
        ask_orders = sum(ask.order_count for ask in order_book.asks[:5])
        total_orders = bid_orders + ask_orders
        
        return {
            'relative_spread': relative_spread,
            'spread_bps': relative_spread * 10000,
            'total_depth': total_depth,
            'total_orders': total_orders,
            'depth_per_order': total_depth / total_orders if total_orders > 0 else 0,
            'bid_ask_ratio': bid_depth / ask_depth if ask_depth > 0 else 0
        }
    
    def _calculate_size_specific_liquidity(self, order_book: OrderBook, 
                                         trade_size: float) -> Dict[str, Any]:
        """특정 거래 규모에 대한 유동성"""
        if not order_book.bids or not order_book.asks:
            return {}
        
        # 매수 유동성
        buy_liquidity = self._calculate_side_liquidity(order_book.bids, trade_size, 'buy')
        
        # 매도 유동성
        sell_liquidity = self._calculate_side_liquidity(order_book.asks, trade_size, 'sell')
        
        return {
            'buy_liquidity': buy_liquidity,
            'sell_liquidity': sell_liquidity,
            'average_liquidity': (buy_liquidity['effective_spread'] + sell_liquidity['effective_spread']) / 2
        }
    
    def _calculate_side_liquidity(self, levels: List[OrderBookLevel], 
                                trade_size: float, side: str) -> Dict[str, Any]:
        """한쪽 유동성 계산"""
        cumulative_quantity = 0
        cumulative_value = 0
        levels_used = 0
        
        for level in levels:
            if cumulative_quantity >= trade_size:
                break
            
            quantity_needed = min(level.quantity, trade_size - cumulative_quantity)
            cumulative_quantity += quantity_needed
            cumulative_value += quantity_needed * level.price
            levels_used += 1
        
        if cumulative_quantity == 0:
            return {
                'effective_spread': float('inf'),
                'levels_used': 0,
                'average_price': 0,
                'slippage': float('inf')
            }
        
        average_price = cumulative_value / cumulative_quantity
        reference_price = levels[0].price if levels else 0
        
        if side == 'buy':
            slippage = (average_price - reference_price) / reference_price
        else:
            slippage = (reference_price - average_price) / reference_price
        
        return {
            'effective_spread': average_price,
            'levels_used': levels_used,
            'average_price': average_price,
            'slippage': slippage,
            'cumulative_quantity': cumulative_quantity
        }
    
    def _calculate_liquidity_ratios(self, order_book: OrderBook) -> Dict[str, float]:
        """유동성 비율 계산"""
        if not order_book.bids or not order_book.asks:
            return {}
        
        # Amihud 유동성 비율 (거래량 대비 가격 변동)
        # 실제 구현에서는 거래량 데이터 필요
        
        # Roll 스프레드 추정
        roll_spread = self._estimate_roll_spread(order_book)
        
        # Kyle's lambda 추정
        kyle_lambda = self._estimate_kyle_lambda(order_book)
        
        return {
            'roll_spread': roll_spread,
            'kyle_lambda': kyle_lambda
        }
    
    def _estimate_roll_spread(self, order_book: OrderBook) -> float:
        """Roll 스프레드 추정"""
        # 간단한 추정: 실제 구현에서는 가격 변화 데이터 필요
        if not order_book.bids or not order_book.asks:
            return 0
        
        spread = order_book.asks[0].price - order_book.bids[0].price
        mid_price = (order_book.bids[0].price + order_book.asks[0].price) / 2
        
        return spread / mid_price
    
    def _estimate_kyle_lambda(self, order_book: OrderBook) -> float:
        """Kyle's lambda 추정"""
        # 간단한 추정: 실제 구현에서는 주문 흐름 데이터 필요
        if not order_book.bids or not order_book.asks:
            return 0
        
        # 가격 영향도 추정
        total_quantity = sum(bid.quantity for bid in order_book.bids[:5]) + sum(ask.quantity for ask in order_book.asks[:5])
        spread = order_book.asks[0].price - order_book.bids[0].price
        
        if total_quantity == 0:
            return 0
        
        return spread / total_quantity
    
    def _calculate_liquidity_score(self, basic_metrics: Dict[str, float], 
                                 size_metrics: Dict[str, Any]) -> float:
        """유동성 점수 계산"""
        score = 0
        
        # 스프레드 점수 (낮을수록 좋음)
        spread_bps = basic_metrics.get('spread_bps', 1000)
        if spread_bps < 10:
            score += 30
        elif spread_bps < 50:
            score += 20
        elif spread_bps < 100:
            score += 10
        
        # 깊이 점수
        total_depth = basic_metrics.get('total_depth', 0)
        if total_depth > 1000000:
            score += 30
        elif total_depth > 100000:
            score += 20
        elif total_depth > 10000:
            score += 10
        
        # 주문 수 점수
        total_orders = basic_metrics.get('total_orders', 0)
        if total_orders > 1000:
            score += 20
        elif total_orders > 100:
            score += 15
        elif total_orders > 10:
            score += 10
        
        # 거래 규모별 유동성 점수
        avg_liquidity = size_metrics.get('average_liquidity', float('inf'))
        if avg_liquidity < float('inf'):
            score += 20
        
        return min(score, 100)  # 최대 100점

class ResilienceAnalyzer:
    """회복성 분석기"""
    
    def __init__(self):
        self.resilience_history = defaultdict(list)
    
    def analyze_market_resilience(self, order_book: OrderBook, 
                                trade_impact: float) -> Dict[str, Any]:
        """시장 회복성 분석"""
        try:
            # 주문장 회복성
            order_book_resilience = self._analyze_order_book_resilience(order_book)
            
            # 가격 회복성
            price_resilience = self._analyze_price_resilience(order_book, trade_impact)
            
            # 유동성 회복성
            liquidity_resilience = self._analyze_liquidity_resilience(order_book)
            
            # 종합 회복성 점수
            overall_resilience = self._calculate_overall_resilience(
                order_book_resilience, price_resilience, liquidity_resilience
            )
            
            return {
                'timestamp': order_book.timestamp,
                'symbol': order_book.symbol,
                'order_book_resilience': order_book_resilience,
                'price_resilience': price_resilience,
                'liquidity_resilience': liquidity_resilience,
                'overall_resilience': overall_resilience
            }
            
        except Exception as e:
            logger.error(f"Resilience analysis failed: {e}")
            raise
    
    def _analyze_order_book_resilience(self, order_book: OrderBook) -> Dict[str, float]:
        """주문장 회복성 분석"""
        if not order_book.bids or not order_book.asks:
            return {}
        
        # 주문 분포의 균등성
        bid_quantities = [bid.quantity for bid in order_book.bids[:10]]
        ask_quantities = [ask.quantity for ask in order_book.asks[:10]]
        
        bid_std = np.std(bid_quantities) if bid_quantities else 0
        ask_std = np.std(ask_quantities) if ask_quantities else 0
        
        bid_mean = np.mean(bid_quantities) if bid_quantities else 0
        ask_mean = np.mean(ask_quantities) if ask_quantities else 0
        
        bid_cv = bid_std / bid_mean if bid_mean > 0 else 0
        ask_cv = ask_std / ask_mean if ask_mean > 0 else 0
        
        # 주문 수의 분포
        bid_orders = [bid.order_count for bid in order_book.bids[:10]]
        ask_orders = [ask.order_count for ask in order_book.asks[:10]]
        
        bid_order_std = np.std(bid_orders) if bid_orders else 0
        ask_order_std = np.std(ask_orders) if ask_orders else 0
        
        return {
            'bid_quantity_cv': bid_cv,
            'ask_quantity_cv': ask_cv,
            'bid_order_std': bid_order_std,
            'ask_order_std': ask_order_std,
            'order_distribution_score': 1 / (1 + (bid_cv + ask_cv) / 2)
        }
    
    def _analyze_price_resilience(self, order_book: OrderBook, 
                                trade_impact: float) -> Dict[str, float]:
        """가격 회복성 분석"""
        if not order_book.bids or not order_book.asks:
            return {}
        
        best_bid = order_book.bids[0].price
        best_ask = order_book.asks[0].price
        mid_price = (best_bid + best_ask) / 2
        
        # 가격 레벨 간격
        bid_intervals = []
        ask_intervals = []
        
        for i in range(1, min(5, len(order_book.bids))):
            interval = order_book.bids[i-1].price - order_book.bids[i].price
            bid_intervals.append(interval)
        
        for i in range(1, min(5, len(order_book.asks))):
            interval = order_book.asks[i].price - order_book.asks[i-1].price
            ask_intervals.append(interval)
        
        avg_bid_interval = np.mean(bid_intervals) if bid_intervals else 0
        avg_ask_interval = np.mean(ask_intervals) if ask_intervals else 0
        
        # 가격 회복성 점수 (간격이 작을수록 회복성 높음)
        price_resilience = 1 / (1 + (avg_bid_interval + avg_ask_interval) / (2 * mid_price))
        
        return {
            'avg_bid_interval': avg_bid_interval,
            'avg_ask_interval': avg_ask_interval,
            'price_resilience_score': price_resilience,
            'trade_impact_absorption': 1 / (1 + trade_impact / mid_price)
        }
    
    def _analyze_liquidity_resilience(self, order_book: OrderBook) -> Dict[str, float]:
        """유동성 회복성 분석"""
        if not order_book.bids or not order_book.asks:
            return {}
        
        # 깊이 분포
        bid_depths = [bid.quantity for bid in order_book.bids[:10]]
        ask_depths = [ask.quantity for ask in order_book.asks[:10]]
        
        # 깊이의 표준편차 (낮을수록 회복성 높음)
        bid_depth_std = np.std(bid_depths) if bid_depths else 0
        ask_depth_std = np.std(ask_depths) if ask_depths else 0
        
        # 깊이 회복성 점수
        depth_resilience = 1 / (1 + (bid_depth_std + ask_depth_std) / 2)
        
        # 주문 수 분포
        bid_orders = [bid.order_count for bid in order_book.bids[:10]]
        ask_orders = [ask.order_count for ask in order_book.asks[:10]]
        
        # 주문 수 회복성 (많을수록 회복성 높음)
        order_resilience = min(1, (np.mean(bid_orders) + np.mean(ask_orders)) / 100)
        
        return {
            'depth_resilience': depth_resilience,
            'order_resilience': order_resilience,
            'liquidity_resilience_score': (depth_resilience + order_resilience) / 2
        }
    
    def _calculate_overall_resilience(self, order_book_resilience: Dict[str, float], 
                                    price_resilience: Dict[str, float], 
                                    liquidity_resilience: Dict[str, float]) -> float:
        """종합 회복성 점수 계산"""
        scores = []
        
        # 주문장 회복성
        if 'order_distribution_score' in order_book_resilience:
            scores.append(order_book_resilience['order_distribution_score'])
        
        # 가격 회복성
        if 'price_resilience_score' in price_resilience:
            scores.append(price_resilience['price_resilience_score'])
        
        # 유동성 회복성
        if 'liquidity_resilience_score' in liquidity_resilience:
            scores.append(liquidity_resilience['liquidity_resilience_score'])
        
        if not scores:
            return 0
        
        return np.mean(scores)
```

### 3. 시장 영향 분석

```python
class MarketImpactCalculator:
    """시장 영향 계산기"""
    
    def __init__(self):
        self.impact_models = {}
        self.impact_history = defaultdict(list)
    
    def calculate_market_impact(self, order_book: OrderBook, 
                              trade_size: float, 
                              trade_side: str) -> Dict[str, Any]:
        """시장 영향 계산"""
        try:
            # 즉시 시장 영향
            immediate_impact = self._calculate_immediate_impact(order_book, trade_size, trade_side)
            
            # 영구 시장 영향
            permanent_impact = self._calculate_permanent_impact(order_book, trade_size, trade_side)
            
            # 총 시장 영향
            total_impact = immediate_impact['price_impact'] + permanent_impact['price_impact']
            
            # 영향 비용
            impact_cost = self._calculate_impact_cost(trade_size, total_impact, order_book)
            
            return {
                'timestamp': order_book.timestamp,
                'symbol': order_book.symbol,
                'trade_size': trade_size,
                'trade_side': trade_side,
                'immediate_impact': immediate_impact,
                'permanent_impact': permanent_impact,
                'total_impact': total_impact,
                'impact_cost': impact_cost,
                'impact_model': self._get_impact_model_name()
            }
            
        except Exception as e:
            logger.error(f"Market impact calculation failed: {e}")
            raise
    
    def _calculate_immediate_impact(self, order_book: OrderBook, 
                                  trade_size: float, 
                                  trade_side: str) -> Dict[str, float]:
        """즉시 시장 영향 계산"""
        if not order_book.bids or not order_book.asks:
            return {'price_impact': 0, 'levels_affected': 0}
        
        mid_price = (order_book.bids[0].price + order_book.asks[0].price) / 2
        
        if trade_side == 'buy':
            levels = order_book.asks
            impact_direction = 1
        else:
            levels = order_book.bids
            impact_direction = -1
        
        cumulative_quantity = 0
        weighted_price = 0
        levels_affected = 0
        
        for level in levels:
            if cumulative_quantity >= trade_size:
                break
            
            quantity_needed = min(level.quantity, trade_size - cumulative_quantity)
            cumulative_quantity += quantity_needed
            weighted_price += quantity_needed * level.price
            levels_affected += 1
        
        if cumulative_quantity == 0:
            return {'price_impact': 0, 'levels_affected': 0}
        
        average_price = weighted_price / cumulative_quantity
        price_impact = (average_price - mid_price) * impact_direction / mid_price
        
        return {
            'price_impact': price_impact,
            'levels_affected': levels_affected,
            'average_price': average_price,
            'mid_price': mid_price
        }
    
    def _calculate_permanent_impact(self, order_book: OrderBook, 
                                  trade_size: float, 
                                  trade_side: str) -> Dict[str, float]:
        """영구 시장 영향 계산"""
        # 간단한 모델: 거래 규모에 비례하는 영구 영향
        if not order_book.bids or not order_book.asks:
            return {'price_impact': 0}
        
        mid_price = (order_book.bids[0].price + order_book.asks[0].price) / 2
        
        # 거래 규모를 시장 깊이로 정규화
        total_depth = sum(bid.quantity for bid in order_book.bids[:5]) + sum(ask.quantity for ask in order_book.asks[:5])
        
        if total_depth == 0:
            return {'price_impact': 0}
        
        # 영구 영향 계수 (거래 규모의 제곱근에 비례)
        impact_coefficient = 0.1  # 10% 기본 영향
        normalized_size = trade_size / total_depth
        permanent_impact = impact_coefficient * np.sqrt(normalized_size)
        
        return {
            'price_impact': permanent_impact,
            'impact_coefficient': impact_coefficient,
            'normalized_size': normalized_size
        }
    
    def _calculate_impact_cost(self, trade_size: float, 
                             total_impact: float, 
                             order_book: OrderBook) -> Dict[str, float]:
        """영향 비용 계산"""
        if not order_book.bids or not order_book.asks:
            return {'total_cost': 0, 'impact_cost': 0, 'transaction_cost': 0}
        
        mid_price = (order_book.bids[0].price + order_book.asks[0].price) / 2
        
        # 거래 비용
        transaction_cost = trade_size * 0.001  # 0.1% 거래 비용
        
        # 영향 비용
        impact_cost = trade_size * total_impact
        
        # 총 비용
        total_cost = transaction_cost + impact_cost
        
        return {
            'total_cost': total_cost,
            'impact_cost': impact_cost,
            'transaction_cost': transaction_cost,
            'cost_bps': total_cost / trade_size * 10000
        }
    
    def _get_impact_model_name(self) -> str:
        """영향 모델 이름"""
        return "Linear_Impact_Model"
    
    def estimate_optimal_trade_size(self, order_book: OrderBook, 
                                  target_impact: float) -> Dict[str, float]:
        """최적 거래 규모 추정"""
        try:
            if not order_book.bids or not order_book.asks:
                return {'optimal_size': 0, 'estimated_impact': 0}
            
            mid_price = (order_book.bids[0].price + order_book.asks[0].price) / 2
            total_depth = sum(bid.quantity for bid in order_book.bids[:5]) + sum(ask.quantity for ask in order_book.asks[:5])
            
            if total_depth == 0:
                return {'optimal_size': 0, 'estimated_impact': 0}
            
            # 목표 영향에 따른 최적 거래 규모 추정
            impact_coefficient = 0.1
            optimal_size = (target_impact / impact_coefficient) ** 2 * total_depth
            
            return {
                'optimal_size': optimal_size,
                'estimated_impact': target_impact,
                'market_depth': total_depth
            }
            
        except Exception as e:
            logger.error(f"Optimal trade size estimation failed: {e}")
            raise
```

## 📈 성과 지표

### 주문장 분석 성과
- **분석 속도**: < 10ms (실시간)
- **깊이 분석 정확도**: > 95%
- **스프레드 계산 정확도**: > 99%
- **주문장 업데이트 빈도**: > 100Hz

### 유동성 메트릭 성과
- **유동성 계산 속도**: < 5ms
- **메트릭 정확도**: > 90%
- **실시간 모니터링**: < 50ms 지연
- **알림 정확도**: > 95%

### 시장 영향 분석 성과
- **영향 계산 속도**: < 50ms
- **영향 예측 정확도**: > 80%
- **최적 거래 규모 추정**: > 85%
- **비용 계산 정확도**: > 90%

## 🔄 개발 로드맵

### 1단계: 주문장 분석 (2026-01-01 ~ 2026-01-15)
- [x] 주문장 파서 구현
- [x] 깊이 분석기 구현
- [x] 스프레드 계산기 구현
- [ ] 실시간 주문장 처리

### 2단계: 유동성 메트릭 (2026-01-16 ~ 2026-01-31)
- [x] 유동성 계산기 구현
- [x] 회복성 분석기 구현
- [x] 시장 영향 계산기 구현
- [ ] 고급 유동성 모델

### 3단계: 시장 영향 분석 (2026-02-01 ~ 2026-02-15)
- [x] 즉시 영향 계산
- [x] 영구 영향 계산
- [x] 영향 비용 계산
- [ ] 최적 거래 규모 추정

### 4단계: 실시간 모니터링 (2026-02-16 ~ 2026-02-29)
- [ ] 실시간 유동성 모니터
- [ ] 다중 거래소 분석기
- [ ] 알림 시스템
- [ ] 대시보드 개발

### 5단계: 통합 및 최적화 (2026-03-01 ~ 2026-03-15)
- [ ] 모든 모듈 통합
- [ ] 성능 최적화
- [ ] 사용자 인터페이스
- [ ] 문서화 완료

## 🔗 관련 문서
- [포트폴리오 최적화](3.5.10_PORTFOLIO_OPTIMIZATION.md)
- [실행 최적화](3.5.12_EXECUTION_OPTIMIZATION.md)
- [고급 위험 관리](3.5.7_ADVANCED_RISK_MANAGEMENT.md) 