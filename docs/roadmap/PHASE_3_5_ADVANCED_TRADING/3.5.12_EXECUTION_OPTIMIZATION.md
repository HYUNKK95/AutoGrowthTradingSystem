# ⚡ Phase 3.5.12: 실행 최적화 시스템

## 🎯 목표
- **TWAP/VWAP 알고리즘**: 시간/거래량 가중 평균 가격 실행
- **스마트 주문 라우팅**: 다중 거래소 최적 경로 선택
- **실행 비용 최적화**: 슬리피지 및 수수료 최소화
- **실행 성능 모니터링**: 실시간 실행 품질 추적

## 📊 성능 목표
- **TWAP/VWAP 실행**: 목표 가격 대비 ±0.1% 이내
- **스마트 라우팅**: < 50ms 경로 선택
- **실행 비용**: < 0.05% (거래당)
- **실행 성공률**: > 99.5%

## 🏗️ 아키텍처

```
advanced-trading/
├── execution-optimization/
│   ├── twap-vwap-algorithms/
│   │   ├── twap-executor.py
│   │   ├── vwap-executor.py
│   │   └── adaptive-executor.py
│   ├── smart-order-routing/
│   │   ├── route-optimizer.py
│   │   ├── exchange-selector.py
│   │   └── latency-analyzer.py
│   ├── execution-cost/
│   │   ├── cost-calculator.py
│   │   ├── slippage-minimizer.py
│   │   └── fee-optimizer.py
│   ├── performance-monitoring/
│   │   ├── execution-monitor.py
│   │   ├── quality-analyzer.py
│   │   └── benchmark-comparison.py
│   └── execution-strategies/
│       ├── strategy-manager.py
│       ├── order-splitter.py
│       └── timing-optimizer.py
```

## 🔧 핵심 구성 요소

### 1. TWAP/VWAP 알고리즘

```python
import numpy as np
import pandas as pd
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass
from datetime import datetime, timedelta
import logging
import asyncio
from enum import Enum

logger = logging.getLogger(__name__)

class ExecutionType(Enum):
    TWAP = "twap"
    VWAP = "vwap"
    ADAPTIVE = "adaptive"

@dataclass
class ExecutionConfig:
    """실행 설정"""
    execution_type: ExecutionType
    total_quantity: float
    start_time: datetime
    end_time: datetime
    target_price: Optional[float] = None
    max_slippage: float = 0.001  # 0.1%
    min_order_size: float = 0.01
    max_order_size: float = 1000.0

class TWAPExecutor:
    """TWAP 실행기"""
    
    def __init__(self, config: ExecutionConfig):
        self.config = config
        self.execution_history = []
        self.current_quantity = 0.0
        self.avg_price = 0.0
    
    async def execute_twap(self, market_data: pd.DataFrame) -> Dict[str, Any]:
        """TWAP 실행"""
        try:
            execution_start = datetime.now()
            
            # 시간 간격 계산
            total_duration = (self.config.end_time - self.config.start_time).total_seconds()
            time_intervals = self._calculate_time_intervals(total_duration)
            
            # 주문 분할
            order_splits = self._calculate_order_splits(time_intervals)
            
            execution_results = []
            
            for i, (interval_start, interval_end, quantity) in enumerate(order_splits):
                # 주문 실행
                order_result = await self._execute_order(quantity, interval_start, interval_end, market_data)
                execution_results.append(order_result)
                
                # 진행 상황 업데이트
                self.current_quantity += quantity
                self._update_average_price(order_result['executed_price'], quantity)
                
                logger.info(f"TWAP order {i+1}/{len(order_splits)} executed: {quantity} @ {order_result['executed_price']}")
            
            # 실행 결과 요약
            summary = self._create_execution_summary(execution_results, execution_start)
            
            return summary
            
        except Exception as e:
            logger.error(f"TWAP execution failed: {e}")
            raise
    
    def _calculate_time_intervals(self, total_duration: float) -> List[Tuple[datetime, datetime]]:
        """시간 간격 계산"""
        intervals = []
        interval_count = max(1, int(total_duration / 60))  # 1분 간격
        
        for i in range(interval_count):
            start_time = self.config.start_time + timedelta(seconds=i * total_duration / interval_count)
            end_time = self.config.start_time + timedelta(seconds((i + 1) * total_duration / interval_count)
            intervals.append((start_time, end_time))
        
        return intervals
    
    def _calculate_order_splits(self, time_intervals: List[Tuple[datetime, datetime]]) -> List[Tuple[datetime, datetime, float]]:
        """주문 분할 계산"""
        splits = []
        quantity_per_interval = self.config.total_quantity / len(time_intervals)
        
        for start_time, end_time in time_intervals:
            # 주문 크기 제한 적용
            order_size = np.clip(quantity_per_interval, 
                               self.config.min_order_size, 
                               self.config.max_order_size)
            
            splits.append((start_time, end_time, order_size))
        
        return splits
    
    async def _execute_order(self, quantity: float, start_time: datetime, 
                           end_time: datetime, market_data: pd.DataFrame) -> Dict[str, Any]:
        """개별 주문 실행"""
        # 시장 데이터 필터링
        interval_data = market_data[
            (market_data.index >= start_time) & 
            (market_data.index <= end_time)
        ]
        
        if interval_data.empty:
            return {
                'executed_quantity': 0,
                'executed_price': 0,
                'execution_time': datetime.now(),
                'status': 'no_market_data'
            }
        
        # TWAP 가격 계산
        twap_price = self._calculate_twap_price(interval_data)
        
        # 주문 실행 (시뮬레이션)
        executed_price = self._simulate_order_execution(quantity, twap_price, interval_data)
        
        return {
            'executed_quantity': quantity,
            'executed_price': executed_price,
            'execution_time': datetime.now(),
            'twap_price': twap_price,
            'status': 'executed'
        }
    
    def _calculate_twap_price(self, market_data: pd.DataFrame) -> float:
        """TWAP 가격 계산"""
        if market_data.empty:
            return 0
        
        # 시간 가중 평균 가격
        total_weight = 0
        weighted_price = 0
        
        for i, (timestamp, row) in enumerate(market_data.iterrows()):
            weight = 1  # 균등 가중치
            weighted_price += row['close'] * weight
            total_weight += weight
        
        return weighted_price / total_weight if total_weight > 0 else 0
    
    def _simulate_order_execution(self, quantity: float, target_price: float, 
                                market_data: pd.DataFrame) -> float:
        """주문 실행 시뮬레이션"""
        # 슬리피지 시뮬레이션
        slippage = np.random.normal(0, 0.0001)  # 0.01% 평균 슬리피지
        executed_price = target_price * (1 + slippage)
        
        return executed_price
    
    def _update_average_price(self, executed_price: float, quantity: float):
        """평균 가격 업데이트"""
        if self.current_quantity == 0:
            self.avg_price = executed_price
        else:
            total_value = self.avg_price * (self.current_quantity - quantity) + executed_price * quantity
            self.avg_price = total_value / self.current_quantity
    
    def _create_execution_summary(self, execution_results: List[Dict[str, Any]], 
                                execution_start: datetime) -> Dict[str, Any]:
        """실행 요약 생성"""
        total_executed = sum(result['executed_quantity'] for result in execution_results)
        total_value = sum(result['executed_quantity'] * result['executed_price'] for result in execution_results)
        
        avg_execution_price = total_value / total_executed if total_executed > 0 else 0
        
        execution_duration = (datetime.now() - execution_start).total_seconds()
        
        return {
            'execution_type': 'TWAP',
            'total_quantity': self.config.total_quantity,
            'executed_quantity': total_executed,
            'avg_execution_price': avg_execution_price,
            'target_price': self.config.target_price,
            'price_deviation': (avg_execution_price - self.config.target_price) / self.config.target_price if self.config.target_price else 0,
            'execution_duration': execution_duration,
            'order_count': len(execution_results),
            'success_rate': sum(1 for r in execution_results if r['status'] == 'executed') / len(execution_results),
            'execution_results': execution_results
        }

class VWAPExecutor:
    """VWAP 실행기"""
    
    def __init__(self, config: ExecutionConfig):
        self.config = config
        self.execution_history = []
        self.volume_profile = {}
    
    async def execute_vwap(self, market_data: pd.DataFrame) -> Dict[str, Any]:
        """VWAP 실행"""
        try:
            execution_start = datetime.now()
            
            # 거래량 프로파일 분석
            volume_profile = self._analyze_volume_profile(market_data)
            
            # 거래량 기반 주문 분할
            order_splits = self._calculate_volume_based_splits(volume_profile)
            
            execution_results = []
            
            for i, (time_window, quantity, target_vwap) in enumerate(order_splits):
                # 주문 실행
                order_result = await self._execute_volume_order(quantity, time_window, target_vwap, market_data)
                execution_results.append(order_result)
                
                logger.info(f"VWAP order {i+1}/{len(order_splits)} executed: {quantity} @ {order_result['executed_price']}")
            
            # 실행 결과 요약
            summary = self._create_vwap_summary(execution_results, execution_start, volume_profile)
            
            return summary
            
        except Exception as e:
            logger.error(f"VWAP execution failed: {e}")
            raise
    
    def _analyze_volume_profile(self, market_data: pd.DataFrame) -> Dict[str, Any]:
        """거래량 프로파일 분석"""
        if market_data.empty:
            return {}
        
        # 시간대별 거래량 분석
        market_data['hour'] = market_data.index.hour
        volume_by_hour = market_data.groupby('hour')['volume'].sum()
        
        # 거래량 가중치 계산
        total_volume = volume_by_hour.sum()
        volume_weights = volume_by_hour / total_volume if total_volume > 0 else volume_by_hour * 0
        
        return {
            'volume_by_hour': volume_by_hour.to_dict(),
            'volume_weights': volume_weights.to_dict(),
            'total_volume': total_volume,
            'peak_hours': volume_by_hour.nlargest(3).index.tolist()
        }
    
    def _calculate_volume_based_splits(self, volume_profile: Dict[str, Any]) -> List[Tuple[datetime, datetime, float, float]]:
        """거래량 기반 주문 분할"""
        splits = []
        
        if not volume_profile:
            # 기본 균등 분할
            interval_count = 10
            quantity_per_interval = self.config.total_quantity / interval_count
            
            for i in range(interval_count):
                start_time = self.config.start_time + timedelta(minutes=i * 6)
                end_time = self.config.start_time + timedelta(minutes=(i + 1) * 6)
                splits.append((start_time, end_time, quantity_per_interval, 0))
        
        else:
            # 거래량 가중 분할
            volume_weights = volume_profile['volume_weights']
            
            for hour, weight in volume_weights.items():
                if weight > 0.01:  # 1% 이상의 거래량
                    start_time = self.config.start_time.replace(hour=int(hour), minute=0, second=0)
                    end_time = start_time + timedelta(hours=1)
                    
                    quantity = self.config.total_quantity * weight
                    target_vwap = self._calculate_target_vwap(hour, volume_profile)
                    
                    splits.append((start_time, end_time, quantity, target_vwap))
        
        return splits
    
    def _calculate_target_vwap(self, hour: int, volume_profile: Dict[str, Any]) -> float:
        """목표 VWAP 계산"""
        # 실제 구현에서는 해당 시간대의 VWAP 계산
        return 100.0  # 예시 값
    
    async def _execute_volume_order(self, quantity: float, time_window: Tuple[datetime, datetime], 
                                  target_vwap: float, market_data: pd.DataFrame) -> Dict[str, Any]:
        """거래량 기반 주문 실행"""
        start_time, end_time = time_window
        
        # 시간대별 시장 데이터 필터링
        interval_data = market_data[
            (market_data.index >= start_time) & 
            (market_data.index <= end_time)
        ]
        
        if interval_data.empty:
            return {
                'executed_quantity': 0,
                'executed_price': 0,
                'execution_time': datetime.now(),
                'status': 'no_market_data'
            }
        
        # VWAP 가격 계산
        vwap_price = self._calculate_vwap_price(interval_data)
        
        # 주문 실행
        executed_price = self._simulate_volume_execution(quantity, vwap_price, interval_data)
        
        return {
            'executed_quantity': quantity,
            'executed_price': executed_price,
            'execution_time': datetime.now(),
            'vwap_price': vwap_price,
            'target_vwap': target_vwap,
            'status': 'executed'
        }
    
    def _calculate_vwap_price(self, market_data: pd.DataFrame) -> float:
        """VWAP 가격 계산"""
        if market_data.empty:
            return 0
        
        # 거래량 가중 평균 가격
        total_volume = market_data['volume'].sum()
        
        if total_volume == 0:
            return market_data['close'].mean()
        
        vwap = (market_data['close'] * market_data['volume']).sum() / total_volume
        return vwap
    
    def _simulate_volume_execution(self, quantity: float, target_price: float, 
                                 market_data: pd.DataFrame) -> float:
        """거래량 기반 실행 시뮬레이션"""
        # 거래량에 따른 슬리피지 조정
        market_volume = market_data['volume'].sum()
        volume_ratio = quantity / market_volume if market_volume > 0 else 0
        
        # 거래량이 클수록 슬리피지 증가
        slippage = np.random.normal(0, 0.0001 * (1 + volume_ratio))
        executed_price = target_price * (1 + slippage)
        
        return executed_price
    
    def _create_vwap_summary(self, execution_results: List[Dict[str, Any]], 
                           execution_start: datetime, 
                           volume_profile: Dict[str, Any]) -> Dict[str, Any]:
        """VWAP 실행 요약"""
        total_executed = sum(result['executed_quantity'] for result in execution_results)
        total_value = sum(result['executed_quantity'] * result['executed_price'] for result in execution_results)
        
        avg_execution_price = total_value / total_executed if total_executed > 0 else 0
        
        # VWAP 대비 성과
        vwap_deviations = []
        for result in execution_results:
            if result['vwap_price'] > 0:
                deviation = (result['executed_price'] - result['vwap_price']) / result['vwap_price']
                vwap_deviations.append(deviation)
        
        avg_vwap_deviation = np.mean(vwap_deviations) if vwap_deviations else 0
        
        return {
            'execution_type': 'VWAP',
            'total_quantity': self.config.total_quantity,
            'executed_quantity': total_executed,
            'avg_execution_price': avg_execution_price,
            'avg_vwap_deviation': avg_vwap_deviation,
            'volume_profile': volume_profile,
            'execution_duration': (datetime.now() - execution_start).total_seconds(),
            'order_count': len(execution_results),
            'success_rate': sum(1 for r in execution_results if r['status'] == 'executed') / len(execution_results),
            'execution_results': execution_results
        }
```

### 2. 스마트 주문 라우팅

```python
class SmartOrderRouter:
    """스마트 주문 라우터"""
    
    def __init__(self, exchanges: List[str]):
        self.exchanges = exchanges
        self.latency_data = {}
        self.liquidity_data = {}
        self.cost_data = {}
    
    def select_optimal_route(self, order: Dict[str, Any]) -> Dict[str, Any]:
        """최적 경로 선택"""
        try:
            # 거래소별 메트릭 계산
            exchange_metrics = self._calculate_exchange_metrics(order)
            
            # 최적 거래소 선택
            optimal_exchange = self._select_best_exchange(exchange_metrics, order)
            
            # 라우팅 전략 결정
            routing_strategy = self._determine_routing_strategy(order, optimal_exchange)
            
            return {
                'selected_exchange': optimal_exchange,
                'routing_strategy': routing_strategy,
                'exchange_metrics': exchange_metrics,
                'selection_reason': self._get_selection_reason(exchange_metrics, optimal_exchange)
            }
            
        except Exception as e:
            logger.error(f"Route selection failed: {e}")
            raise
    
    def _calculate_exchange_metrics(self, order: Dict[str, Any]) -> Dict[str, Dict[str, float]]:
        """거래소별 메트릭 계산"""
        metrics = {}
        
        for exchange in self.exchanges:
            # 지연 시간
            latency = self._get_exchange_latency(exchange)
            
            # 유동성
            liquidity = self._get_exchange_liquidity(exchange, order['symbol'])
            
            # 비용
            cost = self._get_exchange_cost(exchange, order['quantity'])
            
            # 종합 점수
            score = self._calculate_exchange_score(latency, liquidity, cost)
            
            metrics[exchange] = {
                'latency': latency,
                'liquidity': liquidity,
                'cost': cost,
                'score': score
            }
        
        return metrics
    
    def _get_exchange_latency(self, exchange: str) -> float:
        """거래소 지연 시간 조회"""
        # 실제 구현에서는 실시간 지연 시간 측정
        base_latencies = {
            'binance': 50,
            'coinbase': 80,
            'kraken': 70,
            'bitfinex': 60
        }
        
        return base_latencies.get(exchange, 100) + np.random.normal(0, 10)
    
    def _get_exchange_liquidity(self, exchange: str, symbol: str) -> float:
        """거래소 유동성 조회"""
        # 실제 구현에서는 실시간 유동성 데이터 조회
        base_liquidity = {
            'binance': 1000000,
            'coinbase': 800000,
            'kraken': 600000,
            'bitfinex': 500000
        }
        
        return base_liquidity.get(exchange, 100000) * (0.8 + np.random.random() * 0.4)
    
    def _get_exchange_cost(self, exchange: str, quantity: float) -> float:
        """거래소 비용 조회"""
        # 수수료 구조
        fee_structures = {
            'binance': 0.001,  # 0.1%
            'coinbase': 0.005,  # 0.5%
            'kraken': 0.0026,   # 0.26%
            'bitfinex': 0.002   # 0.2%
        }
        
        base_fee = fee_structures.get(exchange, 0.003)
        
        # 거래량 할인
        volume_discount = min(0.5, quantity / 1000000)  # 100만 이상 거래 시 최대 50% 할인
        
        return base_fee * (1 - volume_discount)
    
    def _calculate_exchange_score(self, latency: float, liquidity: float, cost: float) -> float:
        """거래소 종합 점수 계산"""
        # 정규화
        normalized_latency = 1 / (1 + latency / 100)  # 낮을수록 좋음
        normalized_liquidity = min(1, liquidity / 1000000)  # 높을수록 좋음
        normalized_cost = 1 / (1 + cost * 100)  # 낮을수록 좋음
        
        # 가중 평균
        weights = {'latency': 0.3, 'liquidity': 0.4, 'cost': 0.3}
        
        score = (weights['latency'] * normalized_latency + 
                weights['liquidity'] * normalized_liquidity + 
                weights['cost'] * normalized_cost)
        
        return score
    
    def _select_best_exchange(self, metrics: Dict[str, Dict[str, float]], 
                            order: Dict[str, Any]) -> str:
        """최적 거래소 선택"""
        # 점수 기반 선택
        best_exchange = max(metrics.keys(), key=lambda x: metrics[x]['score'])
        
        # 특별한 조건 확인
        if order['quantity'] > 100000:  # 대량 주문
            # 유동성이 높은 거래소 우선
            best_exchange = max(metrics.keys(), key=lambda x: metrics[x]['liquidity'])
        
        elif order['urgency'] == 'high':  # 긴급 주문
            # 지연 시간이 낮은 거래소 우선
            best_exchange = min(metrics.keys(), key=lambda x: metrics[x]['latency'])
        
        return best_exchange
    
    def _determine_routing_strategy(self, order: Dict[str, Any], 
                                  selected_exchange: str) -> Dict[str, Any]:
        """라우팅 전략 결정"""
        strategy = {
            'type': 'single_exchange',
            'exchanges': [selected_exchange],
            'allocation': [1.0]
        }
        
        # 대량 주문인 경우 다중 거래소 분할
        if order['quantity'] > 500000:
            strategy['type'] = 'multi_exchange'
            strategy['exchanges'] = self._select_multiple_exchanges(order)
            strategy['allocation'] = self._calculate_allocation(strategy['exchanges'], order)
        
        return strategy
    
    def _select_multiple_exchanges(self, order: Dict[str, Any]) -> List[str]:
        """다중 거래소 선택"""
        # 상위 3개 거래소 선택
        all_metrics = self._calculate_exchange_metrics(order)
        sorted_exchanges = sorted(all_metrics.keys(), 
                                key=lambda x: all_metrics[x]['score'], 
                                reverse=True)
        
        return sorted_exchanges[:3]
    
    def _calculate_allocation(self, exchanges: List[str], 
                            order: Dict[str, Any]) -> List[float]:
        """거래소별 할당 비율 계산"""
        # 점수 기반 가중 할당
        all_metrics = self._calculate_exchange_metrics(order)
        
        scores = [all_metrics[ex]['score'] for ex in exchanges]
        total_score = sum(scores)
        
        if total_score == 0:
            return [1.0 / len(exchanges)] * len(exchanges)
        
        return [score / total_score for score in scores]
    
    def _get_selection_reason(self, metrics: Dict[str, Dict[str, float]], 
                            selected_exchange: str) -> str:
        """선택 이유 설명"""
        selected_metrics = metrics[selected_exchange]
        
        reasons = []
        if selected_metrics['latency'] < 60:
            reasons.append("low_latency")
        if selected_metrics['liquidity'] > 800000:
            reasons.append("high_liquidity")
        if selected_metrics['cost'] < 0.002:
            reasons.append("low_cost")
        
        return "_".join(reasons) if reasons else "best_overall_score"
```

### 3. 실행 비용 최적화

```python
class ExecutionCostOptimizer:
    """실행 비용 최적화"""
    
    def __init__(self):
        self.cost_models = {}
        self.optimization_history = []
    
    def optimize_execution_cost(self, order: Dict[str, Any], 
                              market_data: pd.DataFrame) -> Dict[str, Any]:
        """실행 비용 최적화"""
        try:
            # 비용 구성 요소 분석
            cost_components = self._analyze_cost_components(order, market_data)
            
            # 최적화 전략 수립
            optimization_strategy = self._determine_optimization_strategy(cost_components, order)
            
            # 최적화 실행
            optimized_order = self._apply_optimization(order, optimization_strategy, market_data)
            
            # 비용 절약 계산
            cost_savings = self._calculate_cost_savings(order, optimized_order, cost_components)
            
            return {
                'original_order': order,
                'optimized_order': optimized_order,
                'cost_components': cost_components,
                'optimization_strategy': optimization_strategy,
                'cost_savings': cost_savings,
                'optimization_timestamp': datetime.now()
            }
            
        except Exception as e:
            logger.error(f"Cost optimization failed: {e}")
            raise
    
    def _analyze_cost_components(self, order: Dict[str, Any], 
                               market_data: pd.DataFrame) -> Dict[str, float]:
        """비용 구성 요소 분석"""
        # 거래 수수료
        transaction_fee = self._calculate_transaction_fee(order)
        
        # 슬리피지
        slippage_cost = self._estimate_slippage_cost(order, market_data)
        
        # 시장 영향 비용
        market_impact_cost = self._estimate_market_impact_cost(order, market_data)
        
        # 기회 비용
        opportunity_cost = self._estimate_opportunity_cost(order, market_data)
        
        total_cost = transaction_fee + slippage_cost + market_impact_cost + opportunity_cost
        
        return {
            'transaction_fee': transaction_fee,
            'slippage_cost': slippage_cost,
            'market_impact_cost': market_impact_cost,
            'opportunity_cost': opportunity_cost,
            'total_cost': total_cost,
            'cost_bps': total_cost / order['quantity'] * 10000
        }
    
    def _calculate_transaction_fee(self, order: Dict[str, Any]) -> float:
        """거래 수수료 계산"""
        base_fee_rate = 0.001  # 0.1%
        
        # 거래량 할인
        volume_discount = min(0.5, order['quantity'] / 1000000)
        
        # VIP 할인 (예시)
        vip_discount = 0.2 if order.get('vip_level', 0) > 0 else 0
        
        effective_fee_rate = base_fee_rate * (1 - volume_discount) * (1 - vip_discount)
        
        return order['quantity'] * effective_fee_rate
    
    def _estimate_slippage_cost(self, order: Dict[str, Any], 
                              market_data: pd.DataFrame) -> float:
        """슬리피지 비용 추정"""
        if market_data.empty:
            return 0
        
        # 변동성 기반 슬리피지 추정
        volatility = market_data['close'].pct_change().std()
        
        # 거래 규모에 따른 슬리피지
        market_volume = market_data['volume'].mean()
        size_impact = order['quantity'] / market_volume if market_volume > 0 else 0
        
        # 슬리피지 = 변동성 * 거래 규모 영향 * 거래량
        slippage_rate = volatility * np.sqrt(size_impact) * 0.1
        
        return order['quantity'] * slippage_rate
    
    def _estimate_market_impact_cost(self, order: Dict[str, Any], 
                                   market_data: pd.DataFrame) -> float:
        """시장 영향 비용 추정"""
        if market_data.empty:
            return 0
        
        # 거래 규모를 시장 깊이로 정규화
        market_depth = market_data['volume'].sum()
        normalized_size = order['quantity'] / market_depth if market_depth > 0 else 0
        
        # 영구 영향 (거래 규모의 제곱근에 비례)
        permanent_impact = 0.1 * np.sqrt(normalized_size)
        
        return order['quantity'] * permanent_impact
    
    def _estimate_opportunity_cost(self, order: Dict[str, Any], 
                                 market_data: pd.DataFrame) -> float:
        """기회 비용 추정"""
        if market_data.empty:
            return 0
        
        # 시장 트렌드 기반 기회 비용
        price_trend = market_data['close'].iloc[-1] - market_data['close'].iloc[0]
        trend_strength = abs(price_trend) / market_data['close'].iloc[0]
        
        # 긴급도에 따른 기회 비용
        urgency_multiplier = 1.0
        if order.get('urgency') == 'high':
            urgency_multiplier = 2.0
        elif order.get('urgency') == 'low':
            urgency_multiplier = 0.5
        
        opportunity_cost = trend_strength * urgency_multiplier * order['quantity'] * 0.01
        
        return opportunity_cost
    
    def _determine_optimization_strategy(self, cost_components: Dict[str, float], 
                                       order: Dict[str, Any]) -> Dict[str, Any]:
        """최적화 전략 결정"""
        strategy = {
            'order_splitting': False,
            'timing_optimization': False,
            'venue_selection': False,
            'order_type_optimization': False
        }
        
        # 가장 큰 비용 구성 요소에 따른 전략 선택
        max_cost_component = max(cost_components.items(), key=lambda x: x[1] if x[0] != 'total_cost' else 0)
        
        if max_cost_component[0] == 'slippage_cost' and max_cost_component[1] > cost_components['total_cost'] * 0.3:
            strategy['order_splitting'] = True
        
        if max_cost_component[0] == 'market_impact_cost' and max_cost_component[1] > cost_components['total_cost'] * 0.3:
            strategy['timing_optimization'] = True
        
        if max_cost_component[0] == 'transaction_fee' and max_cost_component[1] > cost_components['total_cost'] * 0.3:
            strategy['venue_selection'] = True
        
        # 대량 주문인 경우 주문 분할
        if order['quantity'] > 100000:
            strategy['order_splitting'] = True
        
        return strategy
    
    def _apply_optimization(self, order: Dict[str, Any], 
                          strategy: Dict[str, bool], 
                          market_data: pd.DataFrame) -> Dict[str, Any]:
        """최적화 적용"""
        optimized_order = order.copy()
        
        if strategy['order_splitting']:
            optimized_order = self._optimize_order_splitting(optimized_order, market_data)
        
        if strategy['timing_optimization']:
            optimized_order = self._optimize_timing(optimized_order, market_data)
        
        if strategy['venue_selection']:
            optimized_order = self._optimize_venue_selection(optimized_order)
        
        if strategy['order_type_optimization']:
            optimized_order = self._optimize_order_type(optimized_order, market_data)
        
        return optimized_order
    
    def _optimize_order_splitting(self, order: Dict[str, Any], 
                                market_data: pd.DataFrame) -> Dict[str, Any]:
        """주문 분할 최적화"""
        optimized_order = order.copy()
        
        # 변동성 기반 분할
        if not market_data.empty:
            volatility = market_data['close'].pct_change().std()
            
            # 변동성이 높을수록 더 작은 단위로 분할
            if volatility > 0.02:  # 2% 이상 변동성
                split_count = min(10, max(3, int(order['quantity'] / 10000)))
            else:
                split_count = min(5, max(2, int(order['quantity'] / 20000)))
            
            optimized_order['split_count'] = split_count
            optimized_order['split_quantity'] = order['quantity'] / split_count
        
        return optimized_order
    
    def _optimize_timing(self, order: Dict[str, Any], 
                        market_data: pd.DataFrame) -> Dict[str, Any]:
        """타이밍 최적화"""
        optimized_order = order.copy()
        
        if not market_data.empty:
            # 변동성 패턴 분석
            hourly_volatility = market_data.groupby(market_data.index.hour)['close'].pct_change().std()
            
            # 변동성이 낮은 시간대 선택
            low_volatility_hours = hourly_volatility.nsmallest(3).index.tolist()
            
            optimized_order['optimal_hours'] = low_volatility_hours
            optimized_order['timing_strategy'] = 'low_volatility'
        
        return optimized_order
    
    def _optimize_venue_selection(self, order: Dict[str, Any]) -> Dict[str, Any]:
        """거래소 선택 최적화"""
        optimized_order = order.copy()
        
        # 수수료가 낮은 거래소 우선
        optimized_order['preferred_venues'] = ['binance', 'bitfinex']  # 예시
        optimized_order['venue_strategy'] = 'low_fee_first'
        
        return optimized_order
    
    def _optimize_order_type(self, order: Dict[str, Any], 
                           market_data: pd.DataFrame) -> Dict[str, Any]:
        """주문 타입 최적화"""
        optimized_order = order.copy()
        
        if not market_data.empty:
            # 시장 상황에 따른 주문 타입 선택
            volatility = market_data['close'].pct_change().std()
            
            if volatility > 0.03:  # 3% 이상 변동성
                optimized_order['order_type'] = 'limit'
                optimized_order['limit_offset'] = 0.002  # 0.2% 오프셋
            else:
                optimized_order['order_type'] = 'market'
        
        return optimized_order
    
    def _calculate_cost_savings(self, original_order: Dict[str, Any], 
                              optimized_order: Dict[str, Any], 
                              original_costs: Dict[str, float]) -> Dict[str, float]:
        """비용 절약 계산"""
        # 최적화된 주문의 비용 계산
        optimized_costs = self._analyze_cost_components(optimized_order, pd.DataFrame())
        
        savings = {}
        for component in ['transaction_fee', 'slippage_cost', 'market_impact_cost', 'opportunity_cost', 'total_cost']:
            if component in original_costs and component in optimized_costs:
                savings[component] = original_costs[component] - optimized_costs[component]
                savings[f'{component}_reduction'] = savings[component] / original_costs[component] if original_costs[component] > 0 else 0
        
        return savings
```

## 📈 성과 지표

### TWAP/VWAP 실행 성과
- **TWAP 정확도**: 목표 가격 대비 ±0.1% 이내
- **VWAP 정확도**: VWAP 대비 ±0.2% 이내
- **실행 성공률**: > 99.5%
- **실행 속도**: < 5초 (전체 주문)

### 스마트 라우팅 성과
- **경로 선택 속도**: < 50ms
- **라우팅 정확도**: > 95%
- **비용 절약**: > 20%
- **지연 시간 최적화**: > 30%

### 실행 비용 최적화 성과
- **비용 절약률**: > 25%
- **슬리피지 감소**: > 40%
- **수수료 최적화**: > 30%
- **시장 영향 최소화**: > 35%

## 🔄 개발 로드맵

### 1단계: TWAP/VWAP 알고리즘 (2026-03-01 ~ 2026-03-15)
- [x] TWAP 실행기 구현
- [x] VWAP 실행기 구현
- [ ] 적응형 실행기 구현
- [ ] 백테스팅 시스템

### 2단계: 스마트 라우팅 (2026-03-16 ~ 2026-03-31)
- [x] 경로 최적화 구현
- [x] 거래소 선택기 구현
- [x] 지연 시간 분석기 구현
- [ ] 다중 거래소 통합

### 3단계: 실행 비용 최적화 (2026-04-01 ~ 2026-04-15)
- [x] 비용 계산기 구현
- [x] 슬리피지 최소화 구현
- [x] 수수료 최적화 구현
- [ ] 고급 비용 모델

### 4단계: 성능 모니터링 (2026-04-16 ~ 2026-04-30)
- [ ] 실행 모니터 구현
- [ ] 품질 분석기 구현
- [ ] 벤치마크 비교 구현
- [ ] 실시간 대시보드

### 5단계: 통합 및 최적화 (2026-05-01 ~ 2026-05-15)
- [ ] 모든 모듈 통합
- [ ] 성능 최적화
- [ ] 사용자 인터페이스
- [ ] 문서화 완료

## 🔗 관련 문서
- [시장 마이크로구조](3.5.11_MARKET_MICROSTRUCTURE.md)
- [포트폴리오 최적화](3.5.10_PORTFOLIO_OPTIMIZATION.md)
- [고급 위험 관리](3.5.7_ADVANCED_RISK_MANAGEMENT.md) 